[
  {
    "sectionId": "tech-algorithm-programming",
    "category": "テクノロジ系",
    "chapter": "アルゴリズムとプログラミング",
    "title": "アルゴリズムとプログラミング",
    "overview": {
      "analogy": "アルゴリズムとは「問題を解くための手順書」のことです。料理のレシピに例えると、材料（データ）をどんな手順で調理（処理）すれば美味しい料理（正しい結果）ができるかを書いたものです。プログラミングは、このレシピをコンピュータが理解できる言葉で書くことです。",
      "summary": "アルゴリズムは問題を解くための手順を明確に定義したものです。データ構造（配列・リスト・スタック・キュー）はデータの整理方法、ソート・探索アルゴリズムはデータの並べ替え・検索方法です。計算量（オーダ）でアルゴリズムの効率を評価します。"
    },
    "content": [
      {
        "heading": "データ構造の基本（配列、リスト、スタック、キュー）",
        "body": "データ構造とは、データを効率よく管理するための「整理方法」です。配列は、ロッカーのように番号をつけて順番にデータを並べる最も基本的な構造です。番号（添字）を指定すれば、すぐに目的のデータにアクセスできます。連結リストは、各データが次のデータへの道順（ポインタ）を持つ構造です。電車の車両のように、先頭からたどっていくことでデータを辿ります。途中にデータを追加・削除しやすいのが特徴です。スタックは「最後に入れたものを最初に取り出す（LIFO）」構造で、お皿の積み重ねに似ています。一番上のお皿から取り出します。キューは「最初に入れたものを最初に取り出す（FIFO）」構造で、レジの待ち行列と同じです。先に並んだ人から順番にサービスを受けます。",
        "diagram": null
      },
      {
        "heading": "ソートアルゴリズム（バブル、選択、挿入、クイック、マージ）",
        "body": "ソートとは、データを一定の規則（昇順・降順）で並べ替えることです。バブルソートは、隣り合う2つを比較して交換を繰り返す方法です。水中の泡が浮かび上がるように、大きい値が徐々に後ろに移動します。理解しやすいですが遅い（計算量O(n²)）のが欠点です。選択ソートは、未整列部分から最小値を見つけて先頭に置く方法です。トランプを手札から一番小さいカードを探して左端に置く感覚です。挿入ソートは、未整列のデータを整列済み部分の正しい位置に差し込む方法です。手持ちのトランプを1枚ずつ正しい位置に挿入する感覚です。クイックソートは、基準値（ピボット）を決めて「基準より小さいグループ」と「大きいグループ」に分け、それぞれを再帰的にソートする高速な方法です（平均O(n log n)）。マージソートは、データを半分ずつ分割してからそれぞれをソートし、統合（マージ）する方法です。安定で計算量が常にO(n log n)です。",
        "diagram": null
      },
      {
        "heading": "探索アルゴリズム（線形探索、二分探索）",
        "body": "探索とは、データの中から目的の値を見つけ出す処理です。線形探索（リニアサーチ）は、データを先頭から順番に1つずつ調べる方法です。本棚の本を左から順番にタイトルを確認していくイメージです。データが整列されていなくても使えますが、データ量が多いと時間がかかります（計算量O(n)）。二分探索（バイナリサーチ）は、整列済みのデータに対して使える高速な方法です。辞書で単語を探すとき、真ん中あたりのページを開いて「目的の単語はこれより前？後？」と判断し、半分ずつ範囲を絞り込んでいきます。毎回データを半分に減らせるため、非常に高速です（計算量O(log n)）。1000個のデータでも約10回の比較で見つかります。ただし、データが事前にソートされている必要があります。",
        "diagram": null
      },
      {
        "heading": "再帰とその応用",
        "body": "再帰（リカージョン）とは、関数が自分自身を呼び出す手法です。合わせ鏡のように、鏡の中にまた鏡が映っているイメージです。最もわかりやすい例は階乗の計算です。5!=5×4×3×2×1ですが、これは5×4!と書き直せます。つまり「5の階乗」は「5×4の階乗」で、「4の階乗」は「4×3の階乗」で…と自分自身を呼び出し続け、1!=1で止まります。この「止まる条件」を基底条件（ベースケース）と呼び、これがないと無限に呼び出しが続いてエラーになります。再帰はツリー構造の探索（フォルダの中のフォルダを辿る）、分割統治法（クイックソート、マージソート）、フィボナッチ数列の計算などで活用されます。再帰は直感的にわかりやすい反面、呼び出しが深くなるとメモリを大量に消費する場合があります。計算量の分析では、オーダ記法（O記法）を使い、O(1)は定数時間、O(n)は線形時間、O(n²)は二乗時間、O(log n)は対数時間と表します。",
        "diagram": null
      }
    ],
    "keyTerms": [
      {
        "term": "アルゴリズム",
        "definition": "問題を解くための明確な手順や方法のこと。入力に対して有限回の手順で正しい出力を得る。",
        "analogy": "料理のレシピのようなもの。材料（入力）に対して、手順通りに調理すれば必ず完成品（出力）ができます。"
      },
      {
        "term": "データ構造",
        "definition": "データを効率的に管理・操作するための整理方法。配列、リスト、スタック、キュー、木、グラフなどがある。",
        "analogy": "本の整理方法。本棚に番号順に並べる（配列）、しおりで次の本を示す（リスト）など、目的に合った整理法を選びます。"
      },
      {
        "term": "ソート",
        "definition": "データを昇順または降順に並べ替える処理。代表的な方法にバブルソート、クイックソート、マージソートなどがある。",
        "analogy": "トランプのカードを数字の小さい順に並べ替える作業と同じです。やり方によって速さが大きく変わります。"
      },
      {
        "term": "探索",
        "definition": "データの集まりの中から目的のデータを見つけ出す処理。線形探索と二分探索が代表的。",
        "analogy": "辞書で単語を探す作業。1ページ目から順に見る（線形探索）か、真ん中から絞り込む（二分探索）かで速さが変わります。"
      },
      {
        "term": "再帰",
        "definition": "関数やプログラムが自分自身を呼び出す手法。基底条件で再帰を停止させる必要がある。",
        "analogy": "ロシアの入れ子人形（マトリョーシカ）のように、大きな問題の中に同じ形の小さな問題が入っています。一番小さな人形で止まります。"
      },
      {
        "term": "計算量(オーダ)",
        "definition": "アルゴリズムの効率を示す指標。O記法でデータ量nに対する処理時間の増加の度合いを表す。",
        "analogy": "引っ越し作業の大変さ。荷物が2倍になったとき作業時間が2倍（O(n)）なら効率的、4倍（O(n²)）なら非効率的です。"
      },
      {
        "term": "スタック",
        "definition": "LIFO（Last In, First Out）方式のデータ構造。最後に追加したデータを最初に取り出す。",
        "analogy": "積み重ねたお皿。一番上に置いた皿を一番最初に取り出します。「元に戻す」機能はスタックで実現されています。"
      },
      {
        "term": "キュー",
        "definition": "FIFO（First In, First Out）方式のデータ構造。最初に追加したデータを最初に取り出す。",
        "analogy": "コンビニのレジ待ち行列。先に並んだ人から順番にサービスを受けます。プリンタの印刷順も同じ仕組みです。"
      }
    ],
    "relatedQuestions": ["q-algo-001", "q-algo-002", "q-algo-003", "q-algo-004", "q-algo-005"],
    "difficulty": "hard"
  }
]
