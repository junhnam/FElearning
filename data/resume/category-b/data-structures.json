[
  {
    "sectionId": "b-data-structures",
    "category": "科目B",
    "chapter": "データ構造",
    "title": "データ構造の基本と応用",
    "overview": {
      "analogy": "データ構造とは、データの「整理整頓の方法」です。洋服をクローゼットに収納するとき、ハンガーにかける（配列）、引き出しに重ねる（スタック）、収納ボックスに入れる（キュー）など、用途に応じた方法を選びます。適切な整理方法を選べば、必要なものをすぐ取り出せるのと同じように、適切なデータ構造を選べば、プログラムが効率的に動きます。",
      "summary": "科目Bで出題されるデータ構造として、配列、連結リスト、スタック、キュー、木構造、ハッシュテーブルを学びます。各データ構造の特徴と、擬似言語での操作方法を理解することが重要です。"
    },
    "content": [
      {
        "heading": "配列",
        "body": "配列は、同じ種類のデータを番号（添字・インデックス）を付けて順番に並べたデータ構造です。駅のコインロッカーに例えるとわかりやすいです。各ロッカーに0番、1番、2番…と番号が振られていて、番号を指定すればすぐに中身を取り出せます。配列の添字は0から始まるのが基本です。要素数5の配列なら添字は0〜4です。配列の利点は、添字を指定すれば一瞬でアクセスできること（ランダムアクセス、計算量O(1)）です。欠点は、途中にデータを挿入・削除するとき、後ろの要素を全部ずらす必要があること（計算量O(n)）です。二次元配列は配列の配列で、表のように行と列でデータを管理します。座席表のように「3行目の2列目」でデータを指定します。",
        "diagram": null
      },
      {
        "heading": "連結リスト",
        "body": "連結リストは、各データ（ノード）が「次のデータへの参照（ポインタ）」を持つデータ構造です。電車の車両に例えるとわかりやすいです。各車両（ノード）には乗客（データ）と次の車両への連結器（ポインタ）があります。先頭車両から順にたどっていけば、すべての車両を訪問できます。連結リストの利点は、途中にデータを追加・削除するのが簡単なことです。車両を切り離して新しい車両を連結するだけで、他の車両を動かす必要がありません。欠点は、n番目のデータにアクセスするには先頭から順にたどる必要があること（計算量O(n)）です。双方向リストは前後両方へのポインタを持ち、どちらの方向にもたどれます。擬似言語ではノードをクラスで表現し、「node.next」で次のノードを参照します。",
        "diagram": null
      },
      {
        "heading": "スタックとキュー",
        "body": "スタックは「後入れ先出し（LIFO: Last In, First Out）」のデータ構造です。お皿の積み重ねに例えられます。最後に積んだお皿を最初に取り出します。主な操作はpush（データを積む）とpop（データを取り出す）です。Webブラウザの「戻る」ボタンや、テキストエディタの「元に戻す（Undo）」機能はスタックで実現されています。キューは「先入れ先出し（FIFO: First In, First Out）」のデータ構造です。レジの待ち行列そのものです。先に並んだ人から順にサービスを受けます。主な操作はenqueue（データを末尾に追加）とdequeue（先頭からデータを取り出し）です。プリンタの印刷順や、OSのプロセススケジューリングに使われます。科目Bの問題では、配列を使ってスタックやキューを実装する擬似言語コードのトレースが出題されます。",
        "diagram": null
      },
      {
        "heading": "木構造とグラフ",
        "body": "木構造は、データが親子関係で階層的に繋がった構造です。家系図や会社の組織図を思い浮かべてください。一番上の節（ルート）から枝分かれして、末端の節（リーフ）まで続きます。二分木は各ノードが最大2つの子を持つ木です。二分探索木は、左の子 < 親 < 右の子というルールを持ち、効率的にデータを検索できます。木の走査方法には、前順（根→左→右）、中順（左→根→右）、後順（左→右→根）があります。中順走査では二分探索木のデータを小さい順に取得できます。グラフは、ノード（頂点）とエッジ（辺）で構成される、より一般的な構造です。駅と路線の関係（路線図）がわかりやすい例です。BFS（幅優先探索）は近い駅から順に探す方法、DFS（深さ優先探索）は1つの路線を終点まで行ってから戻る方法です。",
        "diagram": null
      },
      {
        "heading": "ハッシュテーブル",
        "body": "ハッシュテーブルは、キー（名前）から直接値（データ）を取得できる高速なデータ構造です。図書館の蔵書検索に例えるとわかりやすいです。本のタイトル（キー）から書架の場所（ハッシュ値）を計算し、直接その棚に行って本を取り出します。ハッシュ関数は、キーを配列の添字に変換する関数です。理想的には計算量O(1)でデータにアクセスできます。しかし、異なるキーが同じハッシュ値になること（衝突・コリジョン）があります。これは2冊の本が同じ棚番号になってしまうようなものです。衝突の解決方法として、チェイン法（同じ場所にリストでつなげる）とオープンアドレス法（空いている別の場所に入れる）があります。科目Bではハッシュ関数の計算と衝突時の動作をトレースする問題が出題されます。",
        "diagram": null
      }
    ],
    "keyTerms": [
      {
        "term": "配列",
        "definition": "同じ型のデータを連続した領域に格納し、添字（インデックス）でアクセスするデータ構造。",
        "analogy": "駅のコインロッカー。番号を指定すればすぐに中身を取り出せます。"
      },
      {
        "term": "添字",
        "definition": "配列の各要素を識別するための番号。通常0から始まる。",
        "analogy": "ロッカーの番号。0番から数え始めるのがプログラミングの約束事です。"
      },
      {
        "term": "連結リスト",
        "definition": "各ノードがデータと次のノードへの参照（ポインタ）を持つデータ構造。",
        "analogy": "電車の連結車両。各車両は次の車両と連結器でつながっていて、先頭から順にたどれます。"
      },
      {
        "term": "ポインタ",
        "definition": "データが格納されている場所（アドレス）を指し示す値。連結リストでは次のノードの場所を示す。",
        "analogy": "宝探しゲームの「次のヒントは○○にあります」という矢印カード。次のデータの場所を教えてくれます。"
      },
      {
        "term": "スタック",
        "definition": "LIFO方式のデータ構造。push（追加）とpop（取り出し）の操作を持つ。",
        "analogy": "積み重ねたお皿。最後に積んだお皿を最初に取り出します。ブラウザの「戻る」ボタンの仕組みです。"
      },
      {
        "term": "キュー",
        "definition": "FIFO方式のデータ構造。enqueue（追加）とdequeue（取り出し）の操作を持つ。",
        "analogy": "レジの待ち行列。先に並んだ人から順にサービスを受けます。"
      },
      {
        "term": "LIFO",
        "definition": "Last In, First Out（後入れ先出し）。最後に追加したデータを最初に取り出す方式。",
        "analogy": "エレベーターに最後に乗った人が最初に降りる状況です。"
      },
      {
        "term": "FIFO",
        "definition": "First In, First Out（先入れ先出し）。最初に追加したデータを最初に取り出す方式。",
        "analogy": "スーパーの商品棚。先に仕入れた（古い）商品が手前に置かれ、先に売れていきます。"
      },
      {
        "term": "二分木",
        "definition": "各ノードが最大2つの子ノードを持つ木構造。二分探索木は左<親<右の規則を持つ。",
        "analogy": "トーナメント表。各試合（ノード）から2つのチーム（子ノード）が分岐しています。"
      },
      {
        "term": "ハッシュ",
        "definition": "キーからハッシュ関数で配列の添字を計算し、高速にデータにアクセスする仕組み。",
        "analogy": "図書館の蔵書検索。本のタイトルから書架の場所を計算して、直接取りに行きます。"
      }
    ],
    "relatedQuestions": ["q-ds-001", "q-ds-002", "q-ds-003", "q-ds-005", "q-ds-009"],
    "difficulty": "hard"
  }
]
