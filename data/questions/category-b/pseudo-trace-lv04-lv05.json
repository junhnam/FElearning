[
  {
    "questionId": "q-trace-025",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "関数呼び出しのトレース",
    "level": 4,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の関数: 二倍加算(整数型: a, 整数型: b)\n  return a * 2 + b\n\n○整数型: x, y, result\nx ← 3\ny ← 5\nresult ← 二倍加算(x, y) + 二倍加算(y, x)\n表示(result)",
    "choices": [
      {
        "text": "24",
        "isCorrect": true,
        "whyCorrect": "二倍加算(3,5) = 3*2+5 = 11、二倍加算(5,3) = 5*2+3 = 13 で、11+13 = 24 です。関数に渡す引数の順番が違うため、2回の呼び出しで異なる結果になります。",
        "analogy": "レストランで「Aセット（メイン2皿＋サイド1皿）」を注文するとき、メインがステーキ(3)でサイドがサラダ(5)なら3×2+5=11品目、逆にメインがサラダ(5)でサイドがステーキ(3)なら5×2+3=13品目。合計で24品目です。",
        "deepDive": "関数呼び出しでは、実引数が仮引数に順番通りに渡されます。同じ関数でも引数の順番が変わると結果が変わることがあります。これは関数の「引数の位置」が重要であることを示しています。"
      },
      {
        "text": "22",
        "isCorrect": false,
        "whyWrong": "これは二倍加算を両方とも二倍加算(3,5)=11 で計算し、11+11=22 とした場合の値です。2回目の呼び出しでは引数の順番が逆（y,x）になっていることに注意してください。",
        "analogy": "同じレシピでも材料の分量を入れ替えれば味が変わります。引数の順番をよく確認しましょう。"
      },
      {
        "text": "26",
        "isCorrect": false,
        "whyWrong": "これは二倍加算を両方とも二倍加算(5,3)=13 で計算し、13+13=26 とした場合の値です。1回目の呼び出しは二倍加算(x,y)=二倍加算(3,5) です。",
        "analogy": "2回の注文を両方とも同じ内容だと思い込むと、金額を間違えるのと同じです。"
      },
      {
        "text": "30",
        "isCorrect": false,
        "whyWrong": "これは関数の計算式を a*2+b*2 と勘違いした場合の値です（(3*2+5*2)+(5*2+3*2)=16+16=32ではなく）。正しくは a*2+b で、bは2倍しません。",
        "analogy": "レシピで「メインだけ2皿」と書いてあるのに「メインもサイドも2皿ずつ」と読み違えるようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"x": "未定義", "y": "未定義", "result": "未定義"}, "action": "変数 x, y, result を宣言"},
      {"step": 2, "variables": {"x": 3, "y": "未定義", "result": "未定義"}, "action": "x に 3 を代入"},
      {"step": 3, "variables": {"x": 3, "y": 5, "result": "未定義"}, "action": "y に 5 を代入"},
      {"step": 4, "variables": {"x": 3, "y": 5, "a": 3, "b": 5}, "action": "二倍加算(3, 5) を呼び出し。a←3, b←5"},
      {"step": 5, "variables": {"x": 3, "y": 5, "a": 3, "b": 5, "戻り値": 11}, "action": "a*2+b = 3*2+5 = 6+5 = 11 を返す"},
      {"step": 6, "variables": {"x": 3, "y": 5, "a": 5, "b": 3}, "action": "二倍加算(5, 3) を呼び出し。a←5, b←3"},
      {"step": 7, "variables": {"x": 3, "y": 5, "a": 5, "b": 3, "戻り値": 13}, "action": "a*2+b = 5*2+3 = 10+3 = 13 を返す"},
      {"step": 8, "variables": {"x": 3, "y": 5, "result": 24}, "action": "result ← 11 + 13 = 24"},
      {"step": 9, "variables": {"x": 3, "y": 5, "result": 24}, "action": "result の値 24 を表示"}
    ],
    "traceAnalogy": "料理人に「この材料でこのレシピで作って」と2回お願いする作業です。1回目は肉(3)をメインにサラダ(5)を添え、2回目はサラダ(5)をメインに肉(3)を添えます。同じレシピでも食材の役割が違うので、出来上がりが異なります。",
    "overallExplanation": "関数呼び出しの基本的なトレース問題です。同じ関数を異なる引数の順番で2回呼び出しています。関数に渡す引数（実引数）と関数が受け取る引数（仮引数）の対応を正しく追うことが重要です。二倍加算(x,y)ではa=3,b=5、二倍加算(y,x)ではa=5,b=3となり、それぞれ11と13を返します。"
  },
  {
    "questionId": "q-trace-026",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "バブルソートのトレース",
    "level": 4,
    "question": "次の擬似言語プログラムを実行したとき、配列 A の最終的な内容として正しいものはどれか。",
    "pseudoCode": "○整数型の配列: A ← {5, 3, 1, 4}\n○整数型: i, j, temp\n○整数型: n ← 4\ni を 1 から n-1 まで 1 ずつ増やしながら繰り返す\n  j を 1 から n-i まで 1 ずつ増やしながら繰り返す\n    もし A[j] > A[j+1] ならば\n      temp ← A[j]\n      A[j] ← A[j+1]\n      A[j+1] ← temp\n    を実行する\n  を繰り返す\nを繰り返す\n表示(A)",
    "choices": [
      {
        "text": "{1, 3, 4, 5}",
        "isCorrect": true,
        "whyCorrect": "バブルソートにより、隣接する要素を比較・交換して昇順に並べ替えます。{5,3,1,4} → 1パス目で{3,1,4,5} → 2パス目で{1,3,4,5} → 3パス目で変化なし、の結果 {1,3,4,5} になります。",
        "analogy": "背の高い順に並んでいる子どもたちを背の低い順に並べ替えるとき、隣同士で「右の子が低ければ入れ替え」を端から繰り返します。大きい子がシャボン玉(バブル)のように右端へ浮かび上がっていきます。",
        "deepDive": "バブルソートは最も基本的なソートアルゴリズムで、隣接要素の比較・交換を繰り返します。1パスごとに最大値が末尾に確定するため、内側ループの範囲が毎回1つ短くなります（n-i）。時間計算量はO(n^2)です。"
      },
      {
        "text": "{5, 4, 3, 1}",
        "isCorrect": false,
        "whyWrong": "これは降順（大きい順）に並べた場合の結果です。プログラムの条件は A[j]>A[j+1] で交換するため、大きい値が後ろに移動し、昇順（小さい順）になります。",
        "analogy": "エスカレーターの上りと下りを間違えると、逆方向に進んでしまいます。比較条件の向きを確認しましょう。"
      },
      {
        "text": "{3, 1, 4, 5}",
        "isCorrect": false,
        "whyWrong": "これは1パス目だけ実行した結果です。バブルソートは外側ループで n-1=3 回のパスを実行するため、すべてのパスを追跡する必要があります。",
        "analogy": "洗濯を1回しただけで干してしまうと、まだ汚れが残っているかもしれません。何度も繰り返して初めて完全にきれいになります。"
      },
      {
        "text": "{1, 3, 5, 4}",
        "isCorrect": false,
        "whyWrong": "これは途中段階の不完全なソート結果です。2パス目以降の交換処理を正しく追跡すると、5と4も正しい位置に配置されます。",
        "analogy": "整理整頓を途中でやめると、まだ散らかった部分が残ります。最後まできちんと並べ替えましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"A": "{5,3,1,4}", "n": 4}, "action": "配列Aと変数nを初期化"},
      {"step": 2, "variables": {"A": "{5,3,1,4}", "i": 1, "j": 1}, "action": "i=1, j=1: A[1]=5 > A[2]=3 → 交換"},
      {"step": 3, "variables": {"A": "{3,5,1,4}", "i": 1, "j": 2}, "action": "i=1, j=2: A[2]=5 > A[3]=1 → 交換"},
      {"step": 4, "variables": {"A": "{3,1,5,4}", "i": 1, "j": 3}, "action": "i=1, j=3: A[3]=5 > A[4]=4 → 交換"},
      {"step": 5, "variables": {"A": "{3,1,4,5}", "i": 1}, "action": "1パス目完了。最大値5が末尾に確定"},
      {"step": 6, "variables": {"A": "{3,1,4,5}", "i": 2, "j": 1}, "action": "i=2, j=1: A[1]=3 > A[2]=1 → 交換"},
      {"step": 7, "variables": {"A": "{1,3,4,5}", "i": 2, "j": 2}, "action": "i=2, j=2: A[2]=3 > A[3]=4 → 交換しない"},
      {"step": 8, "variables": {"A": "{1,3,4,5}", "i": 2}, "action": "2パス目完了。4,5が確定"},
      {"step": 9, "variables": {"A": "{1,3,4,5}", "i": 3, "j": 1}, "action": "i=3, j=1: A[1]=1 > A[2]=3 → 交換しない"},
      {"step": 10, "variables": {"A": "{1,3,4,5}"}, "action": "3パス目完了。全要素が昇順に確定。表示: {1,3,4,5}"}
    ],
    "traceAnalogy": "運動会の背の順整列です。先生が「隣の人と比べて、左が大きかったら入れ替えて」と指示します。1回目の見回りで一番背の高い子が一番右に移動し、2回目で2番目に高い子が右から2番目に移動し、これを繰り返して全員がきれいに並びます。",
    "overallExplanation": "バブルソートは最も基本的な整列アルゴリズムです。外側ループ(i)が各パスを制御し、内側ループ(j)が隣接要素の比較・交換を行います。各パスで最大値が末尾方向に移動するため、内側ループの範囲を n-i に制限できます。配列{5,3,1,4}は3パスで{1,3,4,5}に整列されます。"
  },
  {
    "questionId": "q-trace-027",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "二次元配列の操作",
    "level": 4,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の二次元配列: M ← {{1,2,3},{4,5,6},{7,8,9}}\n○整数型: sum ← 0\n○整数型: i\ni を 1 から 3 まで 1 ずつ増やしながら繰り返す\n  sum ← sum + M[i][i]\nを繰り返す\n表示(sum)",
    "choices": [
      {
        "text": "15",
        "isCorrect": true,
        "whyCorrect": "M[i][i]は対角要素を取得します。M[1][1]=1, M[2][2]=5, M[3][3]=9 で、合計は 1+5+9=15 です。",
        "analogy": "3×3のマス目（九宮格）で左上から右下への斜めライン（対角線）のマスだけを拾う操作です。ビンゴカードの斜めラインと同じ考え方です。",
        "deepDive": "M[i][i]のように行と列のインデックスが同じ要素を「対角要素」と呼びます。行列の対角要素の和は「トレース(trace)」と呼ばれ、線形代数で重要な概念です。"
      },
      {
        "text": "45",
        "isCorrect": false,
        "whyWrong": "これは配列の全要素（1+2+3+4+5+6+7+8+9=45）を合計した場合の値です。このプログラムではM[i][i]で対角要素のみを合計しています。",
        "analogy": "お弁当の全部のおかずを食べるのではなく、対角線上のおかずだけを食べる指示です。全部食べると45ですが、指示通りなら15です。"
      },
      {
        "text": "12",
        "isCorrect": false,
        "whyWrong": "これは1行目の合計（1+2+3=6）と2行目の1つ目（4）と3行目の1つ目（7）を足すなど、インデックスを誤って解釈した場合です。M[i][i]は行番号と列番号が同じ要素です。",
        "analogy": "住所の番地と部屋番号を間違えると、別の場所に届いてしまいます。行と列の両方が i であることを確認しましょう。"
      },
      {
        "text": "18",
        "isCorrect": false,
        "whyWrong": "これは3行目の合計（7+8+9=24ではなく）や別の組み合わせです。対角要素M[1][1]=1, M[2][2]=5, M[3][3]=9を正しく特定する必要があります。",
        "analogy": "地図で座標を読み間違えると目的地にたどり着けません。二次元配列の行と列を正確に追いましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"M": "{{1,2,3},{4,5,6},{7,8,9}}", "sum": 0}, "action": "二次元配列Mとsumを初期化"},
      {"step": 2, "variables": {"i": 1, "sum": 0}, "action": "i=1: M[1][1]=1 を参照"},
      {"step": 3, "variables": {"i": 1, "sum": 1}, "action": "sum ← 0+1 = 1"},
      {"step": 4, "variables": {"i": 2, "sum": 1}, "action": "i=2: M[2][2]=5 を参照"},
      {"step": 5, "variables": {"i": 2, "sum": 6}, "action": "sum ← 1+5 = 6"},
      {"step": 6, "variables": {"i": 3, "sum": 6}, "action": "i=3: M[3][3]=9 を参照"},
      {"step": 7, "variables": {"i": 3, "sum": 15}, "action": "sum ← 6+9 = 15"},
      {"step": 8, "variables": {"sum": 15}, "action": "sum の値 15 を表示"}
    ],
    "traceAnalogy": "チェス盤の左上から右下に向かって斜めに歩く人が、各マスに書かれた数字を拾い集める作業です。(1,1)のマスで1、(2,2)のマスで5、(3,3)のマスで9を拾い、合計15を報告します。",
    "overallExplanation": "二次元配列の対角要素へのアクセスを問う問題です。M[i][i]は行番号と列番号が等しい要素（対角要素）を指します。3×3の配列では、M[1][1]=1, M[2][2]=5, M[3][3]=9が対角要素であり、その合計は15です。二次元配列では[行][列]の2つのインデックスを正しく追跡することが重要です。"
  },
  {
    "questionId": "q-trace-028",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "再帰の初歩（階乗）",
    "level": 4,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の関数: 階乗(整数型: n)\n  もし n ≦ 1 ならば\n    return 1\n  そうでなければ\n    return n × 階乗(n - 1)\n  を実行する\n\n表示(階乗(5))",
    "choices": [
      {
        "text": "120",
        "isCorrect": true,
        "whyCorrect": "階乗(5)=5×階乗(4)=5×4×階乗(3)=5×4×3×階乗(2)=5×4×3×2×階乗(1)=5×4×3×2×1=120 です。再帰呼び出しでnが1になるまで掛け続けます。",
        "analogy": "マトリョーシカ人形のように、大きい人形(5)の中に小さい人形(4)があり、さらに小さい人形(3)...と続き、一番小さい人形(1)で止まります。そこから順に掛け算して戻ります。",
        "deepDive": "再帰(recursion)は、関数が自分自身を呼び出す手法です。必ず「基底条件（ベースケース）」が必要で、この問題ではn≦1が基底条件です。基底条件がないと無限ループになります。"
      },
      {
        "text": "24",
        "isCorrect": false,
        "whyWrong": "これは 4! = 4×3×2×1 = 24 で、階乗(4)の値です。問題では階乗(5)を呼び出しているので、5×24=120 が正解です。",
        "analogy": "5段の階段を登るのに4段目で止まってしまったようなものです。最後の1段（5を掛ける操作）を忘れないようにしましょう。"
      },
      {
        "text": "15",
        "isCorrect": false,
        "whyWrong": "これは 5+4+3+2+1=15 で、掛け算ではなく足し算をした場合の値です。階乗は n × 階乗(n-1) なので、掛け算を使います。",
        "analogy": "レシピで「材料を混ぜる（掛ける）」と書いてあるのに「並べる（足す）」と解釈したようなものです。演算子を確認しましょう。"
      },
      {
        "text": "25",
        "isCorrect": false,
        "whyWrong": "これは 5×5=25 で、5の二乗の値です。階乗は n×(n-1)×(n-2)×...×1 であり、nをn回掛けるのではありません。",
        "analogy": "「5段の階段を1段ずつ降りながら掛ける」のであって、「5を5回掛ける」のではありません。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"n": 5}, "action": "階乗(5)を呼び出し。n=5、5>1なので再帰へ"},
      {"step": 2, "variables": {"n": 4}, "action": "階乗(4)を呼び出し。n=4、4>1なので再帰へ"},
      {"step": 3, "variables": {"n": 3}, "action": "階乗(3)を呼び出し。n=3、3>1なので再帰へ"},
      {"step": 4, "variables": {"n": 2}, "action": "階乗(2)を呼び出し。n=2、2>1なので再帰へ"},
      {"step": 5, "variables": {"n": 1}, "action": "階乗(1)を呼び出し。n=1、1≦1なので1を返す"},
      {"step": 6, "variables": {"n": 2, "戻り値": 2}, "action": "階乗(2)に戻る: 2×1=2 を返す"},
      {"step": 7, "variables": {"n": 3, "戻り値": 6}, "action": "階乗(3)に戻る: 3×2=6 を返す"},
      {"step": 8, "variables": {"n": 4, "戻り値": 24}, "action": "階乗(4)に戻る: 4×6=24 を返す"},
      {"step": 9, "variables": {"n": 5, "戻り値": 120}, "action": "階乗(5)に戻る: 5×24=120 を返す。120を表示"}
    ],
    "traceAnalogy": "伝言ゲームのようなものです。5番の人が「4番さん、あなたの階乗は？」と聞き、4番が3番に、3番が2番に、2番が1番に聞きます。1番は「1だよ」と答え、2番は「2×1=2」、3番は「3×2=6」、4番は「4×6=24」、5番は「5×24=120」と計算して答えが出ます。",
    "overallExplanation": "再帰関数の基本的なトレース問題です。階乗(n)はn≦1のとき1を返し、そうでなければn×階乗(n-1)を返します。再帰呼び出しはnが1になるまで深くなり、そこから逆順に掛け算の結果が返されます。5!=5×4×3×2×1=120です。再帰では「行き（潜る）」と「帰り（戻る）」の両方を追跡することが重要です。"
  },
  {
    "questionId": "q-trace-029",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "文字列の部分取得",
    "level": 4,
    "question": "次の擬似言語プログラムを実行したとき、表示される文字列は何か。",
    "pseudoCode": "○文字列型: s ← \"ABCDEFGH\"\n○文字列型: result ← \"\"\n○整数型: i\ni を 1 から 文字列長(s) まで 2 ずつ増やしながら繰り返す\n  result ← result + 部分文字列(s, i, 1)\nを繰り返す\n表示(result)",
    "choices": [
      {
        "text": "ACEG",
        "isCorrect": true,
        "whyCorrect": "iを2ずつ増やすので、i=1,3,5,7 の位置の文字を取得します。s[1]='A', s[3]='C', s[5]='E', s[7]='G' で、結合すると 'ACEG' です。",
        "analogy": "8人で横一列に並んだ人を「1人おきに」選ぶ操作です。1番目、3番目、5番目、7番目の人が選ばれます。縄跳びで1回おきに跳ぶイメージです。",
        "deepDive": "部分文字列(s, i, 1)は文字列sのi番目から1文字を取得する関数です。ループの増分を2にすることで、奇数番目の文字だけを抽出しています。この手法は文字列のフィルタリングに応用できます。"
      },
      {
        "text": "BDFH",
        "isCorrect": false,
        "whyWrong": "これは偶数番目の文字（2,4,6,8番目）を取得した場合の結果です。iは1から始まり2ずつ増えるので、1,3,5,7番目（奇数番目）の文字が取得されます。",
        "analogy": "列の2番目から数え始めると、選ばれる人が全員ずれてしまいます。開始位置が1番目であることを確認しましょう。"
      },
      {
        "text": "ABCDEFGH",
        "isCorrect": false,
        "whyWrong": "これはすべての文字を取得した場合です。iの増分は2なので、1文字おきに取得されます。1ずつ増やしているわけではありません。",
        "analogy": "1つおきにお皿を取る指示なのに、全部のお皿を取ってしまったようなものです。ステップ幅に注意しましょう。"
      },
      {
        "text": "ACE",
        "isCorrect": false,
        "whyWrong": "これは i=1,3,5 の3文字分だけ取得した場合です。文字列長は8なので、i=7も条件を満たし（7≦8）、s[7]='G' も取得されます。",
        "analogy": "マラソンでゴール手前で止まってしまったようなものです。i=7は文字列長8以下なので、まだループは続きます。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"s": "ABCDEFGH", "result": "", "文字列長": 8}, "action": "文字列sとresultを初期化。文字列長は8"},
      {"step": 2, "variables": {"i": 1, "result": ""}, "action": "i=1: 部分文字列(s,1,1)='A' を取得"},
      {"step": 3, "variables": {"i": 1, "result": "A"}, "action": "result ← ''+A' = 'A'"},
      {"step": 4, "variables": {"i": 3, "result": "A"}, "action": "i=3: 部分文字列(s,3,1)='C' を取得"},
      {"step": 5, "variables": {"i": 3, "result": "AC"}, "action": "result ← 'A'+'C' = 'AC'"},
      {"step": 6, "variables": {"i": 5, "result": "AC"}, "action": "i=5: 部分文字列(s,5,1)='E' を取得"},
      {"step": 7, "variables": {"i": 5, "result": "ACE"}, "action": "result ← 'AC'+'E' = 'ACE'"},
      {"step": 8, "variables": {"i": 7, "result": "ACE"}, "action": "i=7: 部分文字列(s,7,1)='G' を取得"},
      {"step": 9, "variables": {"i": 7, "result": "ACEG"}, "action": "result ← 'ACE'+'G' = 'ACEG'"},
      {"step": 10, "variables": {"i": 9, "result": "ACEG"}, "action": "i=9 > 8 でループ終了。'ACEG' を表示"}
    ],
    "traceAnalogy": "本棚に並んだ8冊の本(A〜H)から、1冊おきに本を取り出す作業です。1冊目(A)を取り、2冊目(B)を飛ばし、3冊目(C)を取り、4冊目(D)を飛ばし...と繰り返すと、手元にはA,C,E,Gの4冊が残ります。",
    "overallExplanation": "文字列操作とループの増分値を組み合わせた問題です。ループ変数iを2ずつ増やすことで、奇数位置の文字だけを抽出しています。部分文字列(s,i,1)は位置iから1文字を取得する関数です。ループの開始値・終了値・増分値とインデックスの対応を正確に追跡することがポイントです。"
  },
  {
    "questionId": "q-trace-030",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "while文と配列の複合操作",
    "level": 4,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: A ← {2, 7, 1, 8, 3}\n○整数型: max ← A[1]\n○整数型: pos ← 1\n○整数型: i ← 2\nA[1] が未定義でない間繰り返す\n  もし i > 5 ならば\n    繰り返しを抜ける\n  を実行する\n  もし A[i] > max ならば\n    max ← A[i]\n    pos ← i\n  を実行する\n  i ← i + 1\nを繰り返す\n表示(pos)",
    "choices": [
      {
        "text": "4",
        "isCorrect": true,
        "whyCorrect": "配列の最大値を探す処理です。A[1]=2, A[2]=7(更新), A[3]=1, A[4]=8(更新), A[5]=3 と比較し、最大値8の位置は4番目なので pos=4 が表示されます。",
        "analogy": "クラスで一番背の高い子を探すとき、最初の子の身長を基準に一人ずつ比較し、より背の高い子がいたら「一番の子」を更新していきます。最終的にその子の出席番号（位置）を答えます。",
        "deepDive": "この処理は「最大値探索」のアルゴリズムです。while文の中でカウンタ変数iを手動で更新しています。for文でも同じ処理ができますが、while文を使う場合はカウンタの初期化・更新を自分で管理する必要があります。"
      },
      {
        "text": "8",
        "isCorrect": false,
        "whyWrong": "8は最大値(max)そのものです。このプログラムが表示するのは pos（最大値の位置）であって、最大値そのものではありません。表示(pos) と書いてあることを確認してください。",
        "analogy": "「一番背の高い子は誰？」と聞かれて「身長180cm」と答えるのではなく、「出席番号4番の子」と答えるのが正しいです。"
      },
      {
        "text": "2",
        "isCorrect": false,
        "whyWrong": "2はA[2]=7の位置です。A[2]=7は一時的にmaxになりますが、A[4]=8がそれより大きいので、最終的にposは4に更新されます。",
        "analogy": "途中経過で一位だった子が、後から来たもっと背の高い子に抜かれるようなものです。最後まで比較を続けましょう。"
      },
      {
        "text": "1",
        "isCorrect": false,
        "whyWrong": "1は初期値のpos（A[1]の位置）です。A[2]=7やA[4]=8がmaxより大きいため、posは更新されます。初期値のままではありません。",
        "analogy": "一番最初の参加者がそのまま優勝するとは限りません。全員の結果を確認してから順位を決めましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"A": "{2,7,1,8,3}", "max": 2, "pos": 1, "i": 2}, "action": "初期化。max=A[1]=2, pos=1, i=2"},
      {"step": 2, "variables": {"i": 2, "max": 2, "pos": 1}, "action": "i=2: A[2]=7 > max=2 → 真"},
      {"step": 3, "variables": {"i": 2, "max": 7, "pos": 2}, "action": "max←7, pos←2 に更新。i←3"},
      {"step": 4, "variables": {"i": 3, "max": 7, "pos": 2}, "action": "i=3: A[3]=1 > max=7 → 偽。更新なし。i←4"},
      {"step": 5, "variables": {"i": 4, "max": 7, "pos": 2}, "action": "i=4: A[4]=8 > max=7 → 真"},
      {"step": 6, "variables": {"i": 4, "max": 8, "pos": 4}, "action": "max←8, pos←4 に更新。i←5"},
      {"step": 7, "variables": {"i": 5, "max": 8, "pos": 4}, "action": "i=5: A[5]=3 > max=8 → 偽。更新なし。i←6"},
      {"step": 8, "variables": {"i": 6, "max": 8, "pos": 4}, "action": "i=6 > 5 → 繰り返しを抜ける"},
      {"step": 9, "variables": {"pos": 4}, "action": "pos の値 4 を表示"}
    ],
    "traceAnalogy": "宝探しゲームです。5つの箱に宝石が入っていて、最も大きい宝石の箱番号を見つけます。1番の箱(2ct)を暫定1位にして、2番(7ct)で更新、3番(1ct)はパス、4番(8ct)で再び更新、5番(3ct)はパス。最終的に4番の箱が1位です。",
    "overallExplanation": "while文と条件分岐を組み合わせた最大値の位置探索問題です。max変数で暫定最大値を、pos変数でその位置を管理し、配列を走査しながら更新します。表示するのは最大値そのものではなく、その位置(pos)であることに注意が必要です。"
  },
  {
    "questionId": "q-trace-031",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "複数の関数の連携",
    "level": 4,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の関数: 絶対値(整数型: x)\n  もし x < 0 ならば\n    return -x\n  そうでなければ\n    return x\n  を実行する\n\n○整数型の関数: 差分(整数型: a, 整数型: b)\n  return 絶対値(a - b)\n\n○整数型: result\nresult ← 差分(3, 10) + 差分(10, 3)\n表示(result)",
    "choices": [
      {
        "text": "14",
        "isCorrect": true,
        "whyCorrect": "差分(3,10)=絶対値(3-10)=絶対値(-7)=7、差分(10,3)=絶対値(10-3)=絶対値(7)=7 で、7+7=14 です。どちらの順序でも差分は同じ7になります。",
        "analogy": "AさんとBさんの身長差は、「AからBを引いても」「BからAを引いても」同じ差になります。絶対値は常に正の値を返すため、引き算の順序に関係なく同じ結果になります。",
        "deepDive": "複数の関数が連携する場合、内側の関数呼び出しから順に評価されます。差分関数は絶対値関数を呼び出し、絶対値関数の戻り値を差分関数の戻り値として返します。この「関数の入れ子呼び出し」は実際のプログラミングでよく使われるパターンです。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "これは (3-10)+(10-3) = -7+7 = 0 と、絶対値を取らずに計算した場合の値です。差分関数は絶対値関数を呼び出すため、結果は常に正の値になります。",
        "analogy": "温度差を求めるとき、「-7度差」と「+7度差」を足すと0になりますが、絶対的な差は両方とも7度です。絶対値を取ることを忘れないでください。"
      },
      {
        "text": "7",
        "isCorrect": false,
        "whyWrong": "これは差分(3,10)=7 の1回分だけの値です。プログラムでは差分(3,10)+差分(10,3)=7+7=14 と2回の呼び出しの結果を加算しています。",
        "analogy": "往復の距離を求めるのに片道だけ計算したようなものです。行きも帰りも7kmなので、合計14kmです。"
      },
      {
        "text": "-14",
        "isCorrect": false,
        "whyWrong": "絶対値関数は負の値を正に変換するため、戻り値が負になることはありません。したがって結果も負にはなりません。",
        "analogy": "距離はマイナスにならないのと同じです。絶対値は常に0以上の値を返します。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {}, "action": "差分(3, 10)を呼び出し"},
      {"step": 2, "variables": {"a": 3, "b": 10}, "action": "差分の中: a-b = 3-10 = -7。絶対値(-7)を呼び出し"},
      {"step": 3, "variables": {"x": -7}, "action": "絶対値の中: x=-7 < 0 → -(-7)=7 を返す"},
      {"step": 4, "variables": {"差分(3,10)": 7}, "action": "差分(3,10)が7を返す"},
      {"step": 5, "variables": {}, "action": "差分(10, 3)を呼び出し"},
      {"step": 6, "variables": {"a": 10, "b": 3}, "action": "差分の中: a-b = 10-3 = 7。絶対値(7)を呼び出し"},
      {"step": 7, "variables": {"x": 7}, "action": "絶対値の中: x=7 ≧ 0 → 7 を返す"},
      {"step": 8, "variables": {"差分(10,3)": 7}, "action": "差分(10,3)が7を返す"},
      {"step": 9, "variables": {"result": 14}, "action": "result ← 7+7 = 14。14を表示"}
    ],
    "traceAnalogy": "東京から大阪までの距離を調べる旅行代理店です。お客さんが「東京→大阪の距離と、大阪→東京の距離を足して」と依頼します。代理店は距離計算係（差分関数）に頼み、距離計算係は「方向に関係なく距離だけ教えて」と絶対値係に頼みます。どちらも7で、合計14です。",
    "overallExplanation": "複数の関数が連携して動作するトレース問題です。差分関数は内部で絶対値関数を呼び出しており、関数の呼び出し階層を追跡する必要があります。絶対値関数により差分は常に正の値になるため、差分(3,10)と差分(10,3)は同じ値7を返し、合計は14になります。"
  },
  {
    "questionId": "q-trace-032",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "フィボナッチ再帰",
    "level": 5,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の関数: fib(整数型: n)\n  もし n ≦ 1 ならば\n    return n\n  そうでなければ\n    return fib(n - 1) + fib(n - 2)\n  を実行する\n\n表示(fib(6))",
    "choices": [
      {
        "text": "8",
        "isCorrect": true,
        "whyCorrect": "フィボナッチ数列は 0,1,1,2,3,5,8,13... です。fib(0)=0, fib(1)=1, fib(2)=1, fib(3)=2, fib(4)=3, fib(5)=5, fib(6)=8 となります。",
        "analogy": "ウサギの繁殖問題のようなものです。月ごとのウサギのつがい数は前月と前々月の合計になります。0月=0、1月=1、2月=1、3月=2、4月=3、5月=5、6月=8つがいです。",
        "deepDive": "フィボナッチ再帰は二分木状に展開されます。fib(6)の計算にはfib(5)とfib(4)が必要で、それぞれがさらに分岐します。同じ値を何度も計算するため効率が悪く、メモ化や動的計画法で改善できます。時間計算量はO(2^n)です。"
      },
      {
        "text": "13",
        "isCorrect": false,
        "whyWrong": "これはfib(7)=13の値です。fib(6)=fib(5)+fib(4)=5+3=8 であり、1つ先の値と混同しています。nの値を正確に追跡しましょう。",
        "analogy": "カレンダーを1日先に読み間違えるようなものです。6月の値を聞かれているのに7月の値を答えてしまっています。"
      },
      {
        "text": "5",
        "isCorrect": false,
        "whyWrong": "これはfib(5)=5の値です。fib(6)はfib(5)+fib(4)=5+3=8 なので、もう1段計算が必要です。",
        "analogy": "6階に行くのに5階で降りてしまったようなものです。あと1段階計算を進めましょう。"
      },
      {
        "text": "6",
        "isCorrect": false,
        "whyWrong": "fib(n)=n ではありません。フィボナッチ数列はn=0,1以外では前2項の和で求められるため、fib(6)=6とはなりません。",
        "analogy": "「何月？」と聞いて「6月だから答えも6」とは限りません。フィボナッチ数は引数そのものではなく、計算で求まる値です。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"n": 6}, "action": "fib(6)を呼び出し。6>1なので fib(5)+fib(4) を計算"},
      {"step": 2, "variables": {"n": 5}, "action": "fib(5)を計算: fib(4)+fib(3) が必要"},
      {"step": 3, "variables": {"n": 4}, "action": "fib(4)を計算: fib(3)+fib(2) が必要"},
      {"step": 4, "variables": {"n": 3}, "action": "fib(3)を計算: fib(2)+fib(1) = 1+1 = 2"},
      {"step": 5, "variables": {"n": 2}, "action": "fib(2)を計算: fib(1)+fib(0) = 1+0 = 1"},
      {"step": 6, "variables": {"fib(4)": 3}, "action": "fib(4) = fib(3)+fib(2) = 2+1 = 3"},
      {"step": 7, "variables": {"fib(5)": 5}, "action": "fib(5) = fib(4)+fib(3) = 3+2 = 5"},
      {"step": 8, "variables": {"fib(6)": 8}, "action": "fib(6) = fib(5)+fib(4) = 5+3 = 8。8を表示"}
    ],
    "traceAnalogy": "家系図のようなものです。6代目のウサギの数を知るには、5代目と4代目の数を足します。5代目を知るには4代目と3代目を足す...と遡り、0代目=0匹、1代目=1匹から順に計算して、6代目=8匹と求まります。",
    "overallExplanation": "フィボナッチ数列の再帰的な計算をトレースする問題です。fib(n)=fib(n-1)+fib(n-2)で、基底条件はn≦1のときnを返します。fib(6)を求めるには下位の値を順に積み上げます: fib(0)=0, fib(1)=1, fib(2)=1, fib(3)=2, fib(4)=3, fib(5)=5, fib(6)=8。再帰の展開を木構造としてイメージすると理解しやすくなります。"
  },
  {
    "questionId": "q-trace-033",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "選択ソートのトレース",
    "level": 5,
    "question": "次の擬似言語プログラムを実行したとき、2パス目（i=2）が完了した時点での配列Aの内容として正しいものはどれか。",
    "pseudoCode": "○整数型の配列: A ← {4, 2, 7, 1, 5}\n○整数型: i, j, minIdx, temp\n○整数型: n ← 5\ni を 1 から n-1 まで 1 ずつ増やしながら繰り返す\n  minIdx ← i\n  j を i+1 から n まで 1 ずつ増やしながら繰り返す\n    もし A[j] < A[minIdx] ならば\n      minIdx ← j\n    を実行する\n  を繰り返す\n  temp ← A[i]\n  A[i] ← A[minIdx]\n  A[minIdx] ← temp\nを繰り返す",
    "choices": [
      {
        "text": "{1, 2, 7, 4, 5}",
        "isCorrect": true,
        "whyCorrect": "1パス目(i=1): 最小値1の位置は4。A[1]とA[4]を交換→{1,2,7,4,5}。2パス目(i=2): 位置2以降の最小値は2(位置2)。A[2]とA[2]を交換(変化なし)→{1,2,7,4,5}。",
        "analogy": "トランプを左から小さい順に並べる方法です。まず残り全部から一番小さいカードを探して左端に置き、次に残りから一番小さいカードを探して左から2番目に置きます。",
        "deepDive": "選択ソートは、未整列部分から最小値を選んで先頭と交換するアルゴリズムです。各パスで1つの要素が確定位置に入ります。バブルソートと比較して交換回数は少ないですが、比較回数は同じO(n^2)です。"
      },
      {
        "text": "{1, 2, 4, 7, 5}",
        "isCorrect": false,
        "whyWrong": "これは3パス目(i=3)まで完了した場合の結果です。問題は2パス目完了時点を聞いています。2パス目では位置2の値(2)が既に最小なので交換は発生しません。",
        "analogy": "2日目までの進捗を聞かれているのに、3日目の結果まで答えてしまったようなものです。"
      },
      {
        "text": "{1, 4, 2, 7, 5}",
        "isCorrect": false,
        "whyWrong": "1パス目で{1,2,7,4,5}となった後、2パス目でA[2]=2は位置2〜5の最小値なので交換は不要です。2と4を交換する必要はありません。",
        "analogy": "既に正しい位置にいる人を無理に動かす必要はありません。"
      },
      {
        "text": "{2, 4, 7, 1, 5}",
        "isCorrect": false,
        "whyWrong": "これは1パス目で最小値1ではなく2をA[1]と交換した場合の結果です。選択ソートでは全範囲の最小値を探すため、A[4]=1が選ばれます。",
        "analogy": "一番安い商品を探しているのに、最初に見つけた安い商品で満足してしまい、もっと安い商品を見逃したようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"A": "{4,2,7,1,5}", "n": 5}, "action": "配列Aを初期化"},
      {"step": 2, "variables": {"i": 1, "minIdx": 1}, "action": "1パス目開始。minIdx=1(A[1]=4)"},
      {"step": 3, "variables": {"i": 1, "minIdx": 2, "j": 2}, "action": "j=2: A[2]=2 < A[1]=4 → minIdx=2"},
      {"step": 4, "variables": {"i": 1, "minIdx": 2, "j": 3}, "action": "j=3: A[3]=7 < A[2]=2 → 偽。minIdx=2のまま"},
      {"step": 5, "variables": {"i": 1, "minIdx": 4, "j": 4}, "action": "j=4: A[4]=1 < A[2]=2 → minIdx=4"},
      {"step": 6, "variables": {"i": 1, "minIdx": 4, "j": 5}, "action": "j=5: A[5]=5 < A[4]=1 → 偽。minIdx=4のまま"},
      {"step": 7, "variables": {"A": "{1,2,7,4,5}"}, "action": "A[1]とA[4]を交換: {4,2,7,1,5}→{1,2,7,4,5}"},
      {"step": 8, "variables": {"i": 2, "minIdx": 2}, "action": "2パス目開始。minIdx=2(A[2]=2)"},
      {"step": 9, "variables": {"i": 2, "minIdx": 2, "j": "3→5"}, "action": "j=3,4,5: A[3]=7,A[4]=4,A[5]=5 いずれもA[2]=2より大。minIdx=2のまま"},
      {"step": 10, "variables": {"A": "{1,2,7,4,5}"}, "action": "A[2]とA[2]を交換(同一位置なので変化なし)。2パス目完了"}
    ],
    "traceAnalogy": "クラスの身長順の整列です。1回目は全員の中から一番背の低い子を見つけて先頭に配置。2回目は残りの中から一番背の低い子を見つけて2番目に配置。2回目が終わった時点では、先頭2人だけが確定しています。",
    "overallExplanation": "選択ソートの途中経過を問う問題です。各パスで未整列部分から最小値のインデックスを探し、先頭要素と交換します。1パス目でA[4]=1が最小としてA[1]と交換され{1,2,7,4,5}に、2パス目ではA[2]=2が既に最小なので変化なしです。ソートの途中状態を正確に追跡する能力が問われます。"
  },
  {
    "questionId": "q-trace-034",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "スタック操作（push/pop）",
    "level": 5,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: stack ← {}\n○整数型: top ← 0\n\n○手続き: push(整数型: val)\n  top ← top + 1\n  stack[top] ← val\n\n○整数型の関数: pop()\n  ○整数型: val ← stack[top]\n  top ← top - 1\n  return val\n\npush(10)\npush(20)\npush(30)\n○整数型: a ← pop()\npush(40)\n○整数型: b ← pop()\n○整数型: c ← pop()\n表示(a + b + c)",
    "choices": [
      {
        "text": "90",
        "isCorrect": true,
        "whyCorrect": "push(10),push(20),push(30)でスタック=[10,20,30]。pop()で30取出(a=30)、スタック=[10,20]。push(40)でスタック=[10,20,40]。pop()で40取出(b=40)。pop()で20取出(c=20)。a+b+c=30+40+20=90。",
        "analogy": "お皿を積み重ねる作業です。10番,20番,30番の皿を順に積み、一番上の30番を取り出し(a=30)、40番を積み、一番上の40番を取り出し(b=40)、次に20番を取り出します(c=20)。合計90です。",
        "deepDive": "スタックはLIFO(Last In, First Out：後入れ先出し)のデータ構造です。push操作でtopを増やしてデータを追加し、pop操作でtop位置のデータを取り出してtopを減らします。配列とtopポインタで実装するのが基本的な方法です。"
      },
      {
        "text": "60",
        "isCorrect": false,
        "whyWrong": "これは10+20+30=60で、最初にpushした3つの値を単純に合計した場合です。実際にはpopで取り出されるのは順序が異なり、途中でpush(40)もされるため、a=30, b=40, c=20になります。",
        "analogy": "お皿は上から取るのに、下から取れると思い込んでいるようなものです。スタックは後入れ先出しです。"
      },
      {
        "text": "100",
        "isCorrect": false,
        "whyWrong": "これは10+20+30+40=100で、pushしたすべての値を合計した場合です。popで取り出されるのは3回分（a,b,c）だけで、取り出される値は30,40,20です。",
        "analogy": "4枚のお皿を積んだのに3枚しか取り出していません。取り出したお皿だけを計算しましょう。"
      },
      {
        "text": "70",
        "isCorrect": false,
        "whyWrong": "これは10+20+40=70などの組み合わせです。最初のpop()ではスタックの一番上(30)が取り出され、push(40)後のpop()では40が取り出されます。LIFO順序を正しく追跡してください。",
        "analogy": "積み重ねたお皿の一番上ではなく途中のお皿を取ろうとしているようなものです。常に一番上から取ります。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"stack": "{}", "top": 0}, "action": "スタックとtopを初期化"},
      {"step": 2, "variables": {"stack": "{10}", "top": 1}, "action": "push(10): top=1, stack[1]=10"},
      {"step": 3, "variables": {"stack": "{10,20}", "top": 2}, "action": "push(20): top=2, stack[2]=20"},
      {"step": 4, "variables": {"stack": "{10,20,30}", "top": 3}, "action": "push(30): top=3, stack[3]=30"},
      {"step": 5, "variables": {"stack": "{10,20}", "top": 2, "a": 30}, "action": "pop(): a=stack[3]=30, top=2"},
      {"step": 6, "variables": {"stack": "{10,20,40}", "top": 3}, "action": "push(40): top=3, stack[3]=40"},
      {"step": 7, "variables": {"stack": "{10,20}", "top": 2, "b": 40}, "action": "pop(): b=stack[3]=40, top=2"},
      {"step": 8, "variables": {"stack": "{10}", "top": 1, "c": 20}, "action": "pop(): c=stack[2]=20, top=1"},
      {"step": 9, "variables": {"a": 30, "b": 40, "c": 20}, "action": "a+b+c = 30+40+20 = 90 を表示"}
    ],
    "traceAnalogy": "エレベーターに人が乗り降りする場面です。10さん、20さん、30さんが順に乗り（奥から詰めて）、ドアに一番近い30さんが降り(a=30)、40さんが乗り、40さんが降り(b=40)、20さんが降ります(c=20)。3人の番号の合計は90です。",
    "overallExplanation": "スタックのpush/pop操作をトレースする問題です。スタックはLIFO構造なので、最後にpushされた要素が最初にpopされます。pushとpopが交互に発生するため、各操作時点でのスタックの状態を正確に追跡することが重要です。a=30(最初のpop), b=40(push後のpop), c=20(残りのpop)で、合計90です。"
  },
  {
    "questionId": "q-trace-035",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "番兵法の線形探索",
    "level": 5,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: A ← {3, 7, 1, 9, 5, 0}\n○整数型: key ← 9\n○整数型: n ← 5\n○整数型: i\nA[n + 1] ← key\ni ← 1\ni ≦ n + 1 の間繰り返す\n  もし A[i] = key ならば\n    繰り返しを抜ける\n  を実行する\n  i ← i + 1\nを繰り返す\nもし i ≦ n ならば\n  表示(i)\nそうでなければ\n  表示(-1)\nを実行する",
    "choices": [
      {
        "text": "4",
        "isCorrect": true,
        "whyCorrect": "配列末尾(A[6])に番兵としてkey=9を置きます。i=1(A[1]=3≠9), i=2(A[2]=7≠9), i=3(A[3]=1≠9), i=4(A[4]=9=key)で一致。i=4≦5なので4を表示します。",
        "analogy": "迷子の犬を探すとき、道の終わりにそっくりな犬の看板（番兵）を立てておきます。歩いて探していき、本物の犬を見つければその場所を報告し、看板まで来てしまったら「見つからなかった」と報告します。",
        "deepDive": "番兵法は線形探索の改良版です。配列末尾にkeyを番兵として配置することで、ループ内の条件判定を「A[i]=keyか」の1つに減らせます（通常の線形探索では「i≦nか」の判定も必要）。見つかったのが番兵かどうかをループ後に判定します。"
      },
      {
        "text": "6",
        "isCorrect": false,
        "whyWrong": "6は番兵の位置(A[6])です。key=9はA[4]に存在するため、番兵に到達する前にA[4]で見つかります。番兵は「見つからなかった場合の保険」であり、データ内に値があれば先にそちらで一致します。",
        "analogy": "本棚で探している本が4番目にあるのに、最後の場所（番兵）まで探し続けてしまったようなものです。"
      },
      {
        "text": "-1",
        "isCorrect": false,
        "whyWrong": "-1は値が見つからなかった場合の出力です。key=9はA[4]に存在するため、i=4≦5が真となり、4が表示されます。",
        "analogy": "実際には本棚に探していた本があるのに、「見つからなかった」と報告してしまったようなものです。"
      },
      {
        "text": "9",
        "isCorrect": false,
        "whyWrong": "9はkey（探索対象の値）そのものです。表示するのは値が見つかった位置(i)であって、値そのものではありません。A[4]=9なので、位置は4です。",
        "analogy": "「何ページに書いてある？」と聞かれて「内容はこれです」と答えるようなものです。位置（ページ番号）を答えましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"A": "{3,7,1,9,5,0}", "key": 9, "n": 5}, "action": "初期化。元のA[6]=0"},
      {"step": 2, "variables": {"A": "{3,7,1,9,5,9}"}, "action": "A[6] ← key(=9) で番兵を設置"},
      {"step": 3, "variables": {"i": 1}, "action": "i=1: A[1]=3 ≠ 9 → 次へ"},
      {"step": 4, "variables": {"i": 2}, "action": "i=2: A[2]=7 ≠ 9 → 次へ"},
      {"step": 5, "variables": {"i": 3}, "action": "i=3: A[3]=1 ≠ 9 → 次へ"},
      {"step": 6, "variables": {"i": 4}, "action": "i=4: A[4]=9 = 9 → 一致！繰り返しを抜ける"},
      {"step": 7, "variables": {"i": 4}, "action": "i=4 ≦ n=5 → 真。データ内で見つかった"},
      {"step": 8, "variables": {"i": 4}, "action": "i の値 4 を表示"}
    ],
    "traceAnalogy": "かくれんぼで子どもを探す場面です。庭の終わりにダミー人形（番兵）を置いておきます。庭を端から探していき、4番目の茂みで本物の子どもを発見。「4番目で見つけた！」と報告します。ダミー人形まで行ってしまったら「見つからなかった」と報告するルールです。",
    "overallExplanation": "番兵法（Sentinel法）による線形探索のトレース問題です。配列の末尾(A[n+1])に探索キーを番兵として設置することで、ループ内では値の一致判定のみ行います。ループ後にi≦nかを確認し、データ内で見つかったか番兵で止まったかを判定します。key=9はA[4]にあるため、表示値は4です。"
  },
  {
    "questionId": "q-trace-036",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "挿入ソート",
    "level": 5,
    "question": "次の擬似言語プログラムを実行したとき、3パス目（i=4）完了後の配列Aの内容として正しいものはどれか。",
    "pseudoCode": "○整数型の配列: A ← {5, 3, 8, 1, 6}\n○整数型: i, j, temp\ni を 2 から 5 まで 1 ずつ増やしながら繰り返す\n  temp ← A[i]\n  j ← i - 1\n  j ≧ 1 かつ A[j] > temp の間繰り返す\n    A[j + 1] ← A[j]\n    j ← j - 1\n  を繰り返す\n  A[j + 1] ← temp\nを繰り返す",
    "choices": [
      {
        "text": "{1, 3, 5, 8, 6}",
        "isCorrect": true,
        "whyCorrect": "1パス(i=2): temp=3, {3,5,8,1,6}。2パス(i=3): temp=8, {3,5,8,1,6}(変化なし)。3パス(i=4): temp=1, 8→右,5→右,3→右で{1,3,5,8,6}。",
        "analogy": "トランプの手札を整理するイメージです。新しいカードを1枚ずつ受け取り、手札の正しい位置に差し込みます。1のカードは一番左まで移動させる必要があります。",
        "deepDive": "挿入ソートは、i番目の要素を整列済み部分(1〜i-1)の正しい位置に挿入するアルゴリズムです。内側ループで要素を右にずらしながら挿入位置を探します。ほぼ整列済みのデータに対して効率的で、最善計算量はO(n)です。"
      },
      {
        "text": "{1, 3, 5, 6, 8}",
        "isCorrect": false,
        "whyWrong": "これは全パス完了後（ソート完了）の状態です。問題は3パス目（i=4）完了時を聞いています。i=5のパスはまだ実行されていません。",
        "analogy": "4時限目までの授業を聞かれているのに、5時限目まで含めて答えてしまったようなものです。"
      },
      {
        "text": "{3, 5, 1, 8, 6}",
        "isCorrect": false,
        "whyWrong": "これは2パス目(i=3)完了時の途中状態に近いですが、正確な状態は{3,5,8,1,6}です。8は既に正しい位置にあるため移動しません。",
        "analogy": "手札の整理で、既に正しい位置にあるカードまで動かそうとする必要はありません。"
      },
      {
        "text": "{1, 5, 3, 8, 6}",
        "isCorrect": false,
        "whyWrong": "3パス目でtemp=1を挿入する際、1より大きい要素(8,5,3)はすべて右にずれます。1は先頭に挿入されるので、{1,3,5,8,6}が正しい結果です。",
        "analogy": "小さいカードを差し込むとき、他のカードを正しい順序でずらす必要があります。途中でずらすのを止めてはいけません。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"A": "{5,3,8,1,6}"}, "action": "配列Aを初期化"},
      {"step": 2, "variables": {"i": 2, "temp": 3}, "action": "1パス目: temp=A[2]=3。j=1: A[1]=5>3→A[2]←5"},
      {"step": 3, "variables": {"A": "{3,5,8,1,6}"}, "action": "j=0で停止。A[1]←3。結果: {3,5,8,1,6}"},
      {"step": 4, "variables": {"i": 3, "temp": 8}, "action": "2パス目: temp=A[3]=8。j=2: A[2]=5>8→偽。移動なし"},
      {"step": 5, "variables": {"A": "{3,5,8,1,6}"}, "action": "A[3]←8(変化なし)。結果: {3,5,8,1,6}"},
      {"step": 6, "variables": {"i": 4, "temp": 1}, "action": "3パス目: temp=A[4]=1。j=3: A[3]=8>1→A[4]←8"},
      {"step": 7, "variables": {"A": "{3,5,_,8,6}"}, "action": "j=2: A[2]=5>1→A[3]←5。j=1: A[1]=3>1→A[2]←3"},
      {"step": 8, "variables": {"A": "{1,3,5,8,6}"}, "action": "j=0で停止。A[1]←1。結果: {1,3,5,8,6}"}
    ],
    "traceAnalogy": "本棚に本を番号順に並べる作業です。3パス目では1番の本を正しい位置に入れます。8番、5番、3番の本をそれぞれ1つ右にずらし、空いた一番左のスペースに1番の本を差し込みます。結果、左から1,3,5,8,6と並び、最後の6番はまだ整理されていません。",
    "overallExplanation": "挿入ソートの途中経過をトレースする問題です。i=4(3パス目)ではtemp=A[4]=1を取り出し、整列済み部分{3,5,8}の正しい位置を探します。1は全要素より小さいため、3,5,8をすべて右にずらして先頭に挿入します。結果は{1,3,5,8,6}で、最後の6はまだ未整列です。"
  },
  {
    "questionId": "q-trace-037",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "文字列パターンマッチ",
    "level": 5,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○文字列型: text ← \"ABCABD\"\n○文字列型: pattern ← \"ABD\"\n○整数型: tLen ← 6\n○整数型: pLen ← 3\n○整数型: i, j\n○整数型: result ← -1\ni を 1 から tLen - pLen + 1 まで 1 ずつ増やしながら繰り返す\n  j ← 1\n  j ≦ pLen の間繰り返す\n    もし 部分文字列(text, i+j-1, 1) ≠ 部分文字列(pattern, j, 1) ならば\n      繰り返しを抜ける\n    を実行する\n    j ← j + 1\n  を繰り返す\n  もし j > pLen ならば\n    result ← i\n    繰り返しを抜ける\n  を実行する\nを繰り返す\n表示(result)",
    "choices": [
      {
        "text": "4",
        "isCorrect": true,
        "whyCorrect": "i=1: text[1..3]='ABC' vs 'ABD' → j=3で'C'≠'D'不一致。i=2: text[2..4]='BCA' vs 'ABD' → j=1で'B'≠'A'不一致。i=3: text[3..5]='CAB' vs 'ABD' → j=1で'C'≠'A'不一致。i=4: text[4..6]='ABD' vs 'ABD' → 全一致。result=4。",
        "analogy": "本の中から特定の単語を探すとき、1文字目から窓を右にずらしながら照合します。「ABCABD」の中で「ABD」が見つかるのは4文字目からです。",
        "deepDive": "これは力まかせ法（ブルートフォース法）によるパターンマッチングです。テキストの各位置からパターンと1文字ずつ比較し、不一致があれば次の位置から再開します。最悪計算量はO(n×m)です。KMP法やBM法はこれを改善したアルゴリズムです。"
      },
      {
        "text": "1",
        "isCorrect": false,
        "whyWrong": "i=1のとき、text[1..3]='ABC'とpattern='ABD'を比較すると、3文字目でC≠Dとなり不一致です。'AB'までは一致しますが、完全一致ではないためresultは更新されません。",
        "analogy": "名前の最初の2文字が同じでも、フルネームが一致しなければ同一人物とは言えません。"
      },
      {
        "text": "-1",
        "isCorrect": false,
        "whyWrong": "-1はパターンが見つからなかった場合の出力です。'ABD'は text の4文字目から一致するので、result=4が表示されます。",
        "analogy": "本の中に探している単語が実際にあるのに、「見つからなかった」と報告するのは間違いです。最後まで探しましょう。"
      },
      {
        "text": "3",
        "isCorrect": false,
        "whyWrong": "i=3のとき、text[3..5]='CAB'とpattern='ABD'を比較すると、1文字目でC≠Aとなり不一致です。パターンが一致するのはi=4からです。",
        "analogy": "住所を1つ隣の家と間違えるようなものです。正確な位置はもう1つ先(4番目)です。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"text": "ABCABD", "pattern": "ABD", "result": -1}, "action": "初期化。検索範囲はi=1〜4"},
      {"step": 2, "variables": {"i": 1, "j": 1}, "action": "i=1: text[1]='A'=pattern[1]='A' → 一致。j=2"},
      {"step": 3, "variables": {"i": 1, "j": 2}, "action": "i=1: text[2]='B'=pattern[2]='B' → 一致。j=3"},
      {"step": 4, "variables": {"i": 1, "j": 3}, "action": "i=1: text[3]='C'≠pattern[3]='D' → 不一致。内側ループ抜ける"},
      {"step": 5, "variables": {"i": 1, "j": 3}, "action": "j=3、pLen=3なのでj>pLenは偽。次のiへ"},
      {"step": 6, "variables": {"i": 2, "j": 1}, "action": "i=2: text[2]='B'≠pattern[1]='A' → 不一致"},
      {"step": 7, "variables": {"i": 3, "j": 1}, "action": "i=3: text[3]='C'≠pattern[1]='A' → 不一致"},
      {"step": 8, "variables": {"i": 4, "j": 1}, "action": "i=4: text[4]='A'=pattern[1]='A' → 一致。j=2"},
      {"step": 9, "variables": {"i": 4, "j": 2}, "action": "i=4: text[5]='B'=pattern[2]='B' → 一致。j=3"},
      {"step": 10, "variables": {"i": 4, "j": 3}, "action": "i=4: text[6]='D'=pattern[3]='D' → 一致。j=4"},
      {"step": 11, "variables": {"i": 4, "j": 4, "result": 4}, "action": "j=4 > pLen=3 → パターン完全一致。result=4。4を表示"}
    ],
    "traceAnalogy": "虫眼鏡で文書を読む作業です。3文字分の窓を持った虫眼鏡を左から右へ1文字ずつずらしていき、窓に映る文字列が「ABD」と完全一致する位置を探します。1番目の窓では「ABC」(惜しい！)、4番目の窓で「ABD」が見つかります。",
    "overallExplanation": "力まかせ法（ナイーブ法）による文字列パターンマッチのトレース問題です。テキスト'ABCABD'の中からパターン'ABD'を探します。外側ループでテキスト上の開始位置を移動し、内側ループでパターンと1文字ずつ比較します。i=1では3文字目で不一致、i=2,3では1文字目で不一致、i=4で完全一致し、result=4が表示されます。"
  },
  {
    "questionId": "q-trace-038",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "二分探索",
    "level": 5,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: A ← {2, 5, 8, 12, 16, 23, 38, 42}\n○整数型: key ← 23\n○整数型: low ← 1\n○整数型: high ← 8\n○整数型: mid\n○整数型: result ← -1\nlow ≦ high の間繰り返す\n  mid ← (low + high) ÷ 2\n  もし A[mid] = key ならば\n    result ← mid\n    繰り返しを抜ける\n  そうでなくもし A[mid] < key ならば\n    low ← mid + 1\n  そうでなければ\n    high ← mid - 1\n  を実行する\nを繰り返す\n表示(result)",
    "choices": [
      {
        "text": "6",
        "isCorrect": true,
        "whyCorrect": "1回目: mid=(1+8)÷2=4, A[4]=12<23 → low=5。2回目: mid=(5+8)÷2=6, A[6]=23=key → result=6。key=23はA[6]にあるので、2回の比較で見つかります。",
        "analogy": "辞書を引くときの要領です。まず真ん中あたりを開き(12)、探す語(23)が後半にあると分かったら後半の真ん中(23)を見ます。たった2回で目的のページが見つかります。",
        "deepDive": "二分探索は整列済み配列を対象に、探索範囲を毎回半分に絞り込むアルゴリズムです。時間計算量はO(log n)で、8要素なら最大3回の比較で見つかります。線形探索のO(n)と比べて大幅に効率的ですが、配列が整列済みであることが前提条件です。"
      },
      {
        "text": "23",
        "isCorrect": false,
        "whyWrong": "23はkey（探索する値）そのものです。このプログラムが表示するのは result（keyが見つかった位置）であって、keyの値ではありません。A[6]=23なので位置は6です。",
        "analogy": "「この本は何ページにある？」と聞かれて「本の内容はこれです」と答えるようなものです。ページ番号（位置）を答えましょう。"
      },
      {
        "text": "-1",
        "isCorrect": false,
        "whyWrong": "-1は値が見つからなかった場合の出力です。key=23はA[6]に存在するため、2回目の比較で見つかりresult=6が設定されます。",
        "analogy": "辞書に載っている言葉なのに「見つかりませんでした」と報告してしまったようなものです。"
      },
      {
        "text": "4",
        "isCorrect": false,
        "whyWrong": "4は1回目のmidの値で、A[4]=12の位置です。12≠23なので、ここでは見つかりません。探索はlow=5に更新されて続行し、次のmid=6で見つかります。",
        "analogy": "辞書で最初に開いたページが目的の語でなかったのに、そこで探索をやめてしまったようなものです。範囲を絞って次のページを見ましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"A": "{2,5,8,12,16,23,38,42}", "key": 23, "low": 1, "high": 8, "result": -1}, "action": "初期化"},
      {"step": 2, "variables": {"low": 1, "high": 8, "mid": 4}, "action": "1回目: mid=(1+8)÷2=4。A[4]=12"},
      {"step": 3, "variables": {"low": 1, "high": 8, "mid": 4}, "action": "A[4]=12 ≠ 23。12 < 23 → low=5 に更新"},
      {"step": 4, "variables": {"low": 5, "high": 8, "mid": 6}, "action": "2回目: mid=(5+8)÷2=6。A[6]=23"},
      {"step": 5, "variables": {"low": 5, "high": 8, "mid": 6, "result": 6}, "action": "A[6]=23 = key。result=6。繰り返しを抜ける"},
      {"step": 6, "variables": {"result": 6}, "action": "result の値 6 を表示"}
    ],
    "traceAnalogy": "1000ページの辞書で「す」のページを探す作業です。まず500ページ目を開くと「く」（まだ前半）。次に750ページ目を開くと「す」が見つかった！このように真ん中を調べて範囲を半分に絞ることを繰り返すので、分厚い辞書でもあっという間に見つかります。",
    "overallExplanation": "二分探索のトレース問題です。整列済み配列{2,5,8,12,16,23,38,42}からkey=23を探します。1回目でmid=4(A[4]=12)を調べ、12<23なのでlow=5に更新。2回目でmid=6(A[6]=23)を調べ、一致したのでresult=6。二分探索は探索範囲を毎回半分にするため、8要素でもわずか2回の比較で見つかります。"
  }
]
