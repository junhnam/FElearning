[
  {
    "questionId": "q-algo-001",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "線形探索の基本",
    "level": 1,
    "question": "次の擬似言語プログラムは、配列 data の中から値 key を探す線形探索の処理である。プログラムを実行したとき、変数 found に格納される値として正しいものはどれか。\n\ndata = {3, 7, 1, 9, 5}、key = 9 とする。",
    "pseudoCode": "○整数型の配列: data = {3, 7, 1, 9, 5}\n○整数型: key ← 9\n○整数型: i\n○論理型: found ← false\n\ni を 0 から 4 まで 1 ずつ増やしながら繰り返す\n  もし data[i] = key ならば\n    found ← true\n  を実行する\nを繰り返す\n\n表示(found)",
    "choices": [
      {
        "id": "a",
        "text": "true",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "配列 data の先頭から順に key（= 9）と比較します。data[0]=3, data[1]=7, data[2]=1 は一致しませんが、data[3]=9 で一致するため found が true になります。",
          "analogy": "本棚の左端から順番に1冊ずつ探していくと、4冊目で目的の本が見つかるイメージです。見つかった時点で「あった！」というフラグが立ちます。",
          "deepDive": "線形探索（リニアサーチ）は最も単純な探索アルゴリズムです。先頭から末尾まで順番に比較するため、最悪の場合は全要素を調べる必要があり、計算量は O(n) です。"
        }
      },
      {
        "id": "b",
        "text": "false",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "data[3] に 9 が存在するため、ループ内の条件 data[i] = key が成立し、found は true に更新されます。false のままではありません。",
          "analogy": "本棚に目的の本がちゃんとあるのに「なかった」と答えるのは間違いです。4冊目をちゃんと確認すれば見つかります。"
        }
      },
      {
        "id": "c",
        "text": "9",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "found は論理型（true/false）の変数です。key の値 9 が格納されるのではなく、見つかったかどうかの真偽値が格納されます。",
          "analogy": "「その本はあった？」と聞かれたら「はい（true）」か「いいえ（false）」で答えます。本のタイトル（9）で答えるわけではありません。"
        }
      },
      {
        "id": "d",
        "text": "3",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "found には見つかった位置（インデックス 3）ではなく、論理型の true/false が格納されます。見つかったかどうかだけを記録する変数です。",
          "analogy": "「その本はあった？」に対して「4番目の棚にあった（インデックス3）」と答えるのは、質問の趣旨と違います。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"i": 0, "data[0]": 3, "key": 9, "found": "false"}, "action": "data[0](=3) ≠ key(=9) → found は変化なし"},
      {"step": 2, "variables": {"i": 1, "data[1]": 7, "key": 9, "found": "false"}, "action": "data[1](=7) ≠ key(=9) → found は変化なし"},
      {"step": 3, "variables": {"i": 2, "data[2]": 1, "key": 9, "found": "false"}, "action": "data[2](=1) ≠ key(=9) → found は変化なし"},
      {"step": 4, "variables": {"i": 3, "data[3]": 9, "key": 9, "found": "true"}, "action": "data[3](=9) = key(=9) → found を true に更新"},
      {"step": 5, "variables": {"i": 4, "data[4]": 5, "key": 9, "found": "true"}, "action": "data[4](=5) ≠ key(=9) → found は true のまま"}
    ],
    "traceAnalogy": "本棚の左端から1冊ずつ「この本かな？」と確認していく作業です。3→違う、7→違う、1→違う、9→見つかった！ 5→もう見つけたけど一応最後まで見る。最終的に「見つかりましたよ（true）」と報告します。",
    "overallExplanation": {
      "summary": "線形探索は配列の先頭から末尾まで順番に目的の値を探す、最もシンプルな探索アルゴリズムです。",
      "keyPoint": "配列を先頭から順に走査し、一致したらフラグを立てる。このプログラムでは見つかっても最後まで走査を続ける点に注意。",
      "relatedTopics": ["二分探索", "番兵法", "探索の計算量"],
      "studyTip": "線形探索は「順番に全部見る」だけなので理解しやすいですが、データが大量にあると遅くなります。それを改善するのが二分探索です。"
    },
    "tags": ["線形探索", "配列", "基本"]
  },
  {
    "questionId": "q-algo-002",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "配列の最大値探索",
    "level": 1,
    "question": "次の擬似言語プログラムは、配列 data から最大値を求める処理である。プログラム実行後、変数 max に格納される値はどれか。\n\ndata = {4, 8, 2, 10, 6} とする。",
    "pseudoCode": "○整数型の配列: data = {4, 8, 2, 10, 6}\n○整数型: max ← data[0]\n○整数型: i\n\ni を 1 から 4 まで 1 ずつ増やしながら繰り返す\n  もし data[i] > max ならば\n    max ← data[i]\n  を実行する\nを繰り返す\n\n表示(max)",
    "choices": [
      {
        "id": "a",
        "text": "10",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "max を data[0]=4 で初期化し、配列を順に見ていきます。data[1]=8>4 で max=8、data[2]=2<8 で変化なし、data[3]=10>8 で max=10、data[4]=6<10 で変化なし。最終的に max=10 です。",
          "analogy": "クラスで一番背の高い人を探すとき、最初の人の身長を基準にして、もっと高い人がいたら基準を更新していく方法です。最後に残った基準が最大値です。",
          "deepDive": "最大値探索は線形探索の応用です。暫定的な最大値を保持し、それより大きい値が見つかるたびに更新します。全要素を1回ずつ見るので計算量は O(n) です。"
        }
      },
      {
        "id": "b",
        "text": "8",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "8 は data[1] の値で、途中で max に格納されますが、data[3]=10 の方が大きいため、さらに更新されます。最終的な max は 10 です。",
          "analogy": "背比べで一時的にチャンピオンだった人も、もっと背の高い人が出てきたら交代です。"
        }
      },
      {
        "id": "c",
        "text": "6",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "6 は配列の最後の要素ですが、最大値ではありません。最後の要素が自動的に答えになるわけではなく、全体を比較した結果が答えです。",
          "analogy": "列の最後の人が一番背が高いとは限りません。全員と比べる必要があります。"
        }
      },
      {
        "id": "d",
        "text": "4",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "4 は max の初期値（data[0]）ですが、ループ内で 8 や 10 に更新されます。初期値がそのまま答えになるのは、先頭要素が最大値の場合だけです。",
          "analogy": "最初に出会った人の身長をメモしても、他の人と比べて更新しなければ正しい最大値は得られません。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"max": 4}, "action": "max を data[0]=4 で初期化"},
      {"step": 2, "variables": {"i": 1, "data[1]": 8, "max": 8}, "action": "data[1]=8 > max=4 → max を 8 に更新"},
      {"step": 3, "variables": {"i": 2, "data[2]": 2, "max": 8}, "action": "data[2]=2 < max=8 → max は変化なし"},
      {"step": 4, "variables": {"i": 3, "data[3]": 10, "max": 10}, "action": "data[3]=10 > max=8 → max を 10 に更新"},
      {"step": 5, "variables": {"i": 4, "data[4]": 6, "max": 10}, "action": "data[4]=6 < max=10 → max は変化なし"}
    ],
    "traceAnalogy": "背の高さ比べをしています。最初の人（4cm）を暫定チャンピオンにして、次の人（8cm）の方が高いのでチャンピオン交代。3人目（2cm）は低いのでスルー。4人目（10cm）が一番高いのでチャンピオン交代。5人目（6cm）は低いのでスルー。最終チャンピオンは10cmの人です。",
    "overallExplanation": {
      "summary": "配列の最大値探索は、先頭の要素を暫定最大値として、順に比較しながら更新していくアルゴリズムです。",
      "keyPoint": "暫定最大値を保持し、より大きな値が見つかるたびに更新する。先頭要素で初期化するのがポイント。",
      "relatedTopics": ["最小値探索", "線形探索", "ソートアルゴリズム"],
      "studyTip": "最大値探索は「暫定チャンピオン方式」と覚えましょう。最小値探索は不等号の向きを逆にするだけです。"
    },
    "tags": ["最大値探索", "配列", "基本"]
  },
  {
    "questionId": "q-algo-003",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "配列の要素カウント",
    "level": 1,
    "question": "次の擬似言語プログラムは、配列 data の中で値が 5 以上の要素の個数を数える処理である。プログラム実行後、変数 count に格納される値はどれか。\n\ndata = {3, 7, 1, 9, 5, 2, 8} とする。",
    "pseudoCode": "○整数型の配列: data = {3, 7, 1, 9, 5, 2, 8}\n○整数型: count ← 0\n○整数型: i\n\ni を 0 から 6 まで 1 ずつ増やしながら繰り返す\n  もし data[i] >= 5 ならば\n    count ← count + 1\n  を実行する\nを繰り返す\n\n表示(count)",
    "choices": [
      {
        "id": "a",
        "text": "4",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "5以上の要素は data[1]=7、data[3]=9、data[4]=5、data[6]=8 の4個です。count は 0→1→2→3→4 と増加し、最終的に 4 になります。",
          "analogy": "テストで合格点（5点以上）を取った人を数えるようなものです。7点、9点、5点、8点の4人が合格です。",
          "deepDive": "条件に合致する要素のカウントは、探索と集計を組み合わせた基本パターンです。条件を変えれば最小値以上、特定範囲内など様々な集計が可能です。"
        }
      },
      {
        "id": "b",
        "text": "3",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "5以上ではなく「5より大きい」で数えると 7, 9, 8 の3個になりますが、問題の条件は >= 5（5以上）なので、5 自体も含まれます。",
          "analogy": "合格点が「5点以上」なら、ちょうど5点の人も合格です。「5点より上」とは違います。"
        }
      },
      {
        "id": "c",
        "text": "5",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "5以上の要素は4個です。5は閾値であり、カウント結果ではありません。配列の中身と条件を1つずつ確認しましょう。",
          "analogy": "合格点の「5点」という基準と、合格者の「人数」は別のものです。"
        }
      },
      {
        "id": "d",
        "text": "7",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "7 は配列の要素数（全体の個数）です。条件に合致する要素だけを数えるので、全要素数とは異なります。",
          "analogy": "クラス全員の人数と、テストに合格した人数は違います。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"i": 0, "data[0]": 3, "count": 0}, "action": "3 < 5 → count は変化なし"},
      {"step": 2, "variables": {"i": 1, "data[1]": 7, "count": 1}, "action": "7 >= 5 → count を 0+1=1 に更新"},
      {"step": 3, "variables": {"i": 2, "data[2]": 1, "count": 1}, "action": "1 < 5 → count は変化なし"},
      {"step": 4, "variables": {"i": 3, "data[3]": 9, "count": 2}, "action": "9 >= 5 → count を 1+1=2 に更新"},
      {"step": 5, "variables": {"i": 4, "data[4]": 5, "count": 3}, "action": "5 >= 5 → count を 2+1=3 に更新"},
      {"step": 6, "variables": {"i": 5, "data[5]": 2, "count": 3}, "action": "2 < 5 → count は変化なし"},
      {"step": 7, "variables": {"i": 6, "data[6]": 8, "count": 4}, "action": "8 >= 5 → count を 3+1=4 に更新"}
    ],
    "traceAnalogy": "テストの答案を1枚ずつ確認して、合格点（5点以上）かどうかチェックしています。3点→不合格、7点→合格（1人目）、1点→不合格、9点→合格（2人目）、5点→ギリギリ合格（3人目）、2点→不合格、8点→合格（4人目）。合格者は全部で4人です。",
    "overallExplanation": {
      "summary": "配列の要素を順に走査し、条件に合致する要素の個数をカウントする基本的なパターンです。",
      "keyPoint": "カウンタ変数を0で初期化し、条件を満たすたびに1加算する。>=（以上）と>（より大きい）の違いに注意。",
      "relatedTopics": ["線形探索", "条件分岐", "集計処理"],
      "studyTip": ">= と > の違いは頻出です。「以上」は境界値を含み、「より大きい」は含みません。"
    },
    "tags": ["カウント", "条件分岐", "配列", "基本"]
  },
  {
    "questionId": "q-algo-004",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "バブルソートの1パス目",
    "level": 1,
    "question": "次の擬似言語プログラムは、バブルソートの1パス目（最初の1回のループ）を実行する処理である。配列 data = {5, 3, 8, 1} に対して1パス目を実行した後の配列の状態はどれか。",
    "pseudoCode": "○整数型の配列: data = {5, 3, 8, 1}\n○整数型: temp\n○整数型: j\n\n// 1パス目：隣接要素を比較して交換\nj を 0 から 2 まで 1 ずつ増やしながら繰り返す\n  もし data[j] > data[j+1] ならば\n    temp ← data[j]\n    data[j] ← data[j+1]\n    data[j+1] ← temp\n  を実行する\nを繰り返す",
    "choices": [
      {
        "id": "a",
        "text": "{3, 5, 1, 8}",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "1パス目で隣接要素を左から比較・交換します。5>3→交換で{3,5,8,1}、5<8→交換なし、8>1→交換で{3,5,1,8}。最大値8が末尾に移動します。",
          "analogy": "泡（バブル）が水面に浮かび上がるように、大きい値が右端に移動していきます。1パス目で一番大きい8が右端に到達します。",
          "deepDive": "バブルソートの1パスでは、最大値が必ず配列の末尾に移動します。これは隣接する2要素を比較して大きい方を右に送る操作を繰り返すためです。"
        }
      },
      {
        "id": "b",
        "text": "{1, 3, 5, 8}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは完全にソートされた状態です。バブルソートの1パスだけでは完全にソートされません。1パスで確定するのは末尾の最大値のみです。",
          "analogy": "1回泡を上げただけでは、全部きれいに並びません。何回も繰り返す必要があります。"
        }
      },
      {
        "id": "c",
        "text": "{3, 5, 8, 1}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは j=0 の交換（5と3）だけを行った状態です。j=1 では交換なし、j=2 では 8>1 なので交換が発生し {3,5,1,8} になります。",
          "analogy": "途中でやめてしまった状態です。1パス分すべての比較を最後まで行う必要があります。"
        }
      },
      {
        "id": "d",
        "text": "{3, 1, 5, 8}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "交換の順序を正しくトレースしていません。j=0で5と3を交換、j=1で5と8は交換なし、j=2で8と1を交換です。5と1の交換はこのパスでは起きません。",
          "analogy": "隣同士の比較を1つずつ順番に行うので、飛ばして比較することはありません。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"j": 0, "data": "{5, 3, 8, 1}"}, "action": "data[0]=5 > data[1]=3 → 交換 → {3, 5, 8, 1}"},
      {"step": 2, "variables": {"j": 1, "data": "{3, 5, 8, 1}"}, "action": "data[1]=5 < data[2]=8 → 交換なし"},
      {"step": 3, "variables": {"j": 2, "data": "{3, 5, 1, 8}"}, "action": "data[2]=8 > data[3]=1 → 交換 → {3, 5, 1, 8}"}
    ],
    "traceAnalogy": "隣に立っている人同士で背比べをして、左の人の方が背が高ければ位置を交換します。1回目：5と3→5の方が高いので交換。2回目：5と8→8の方が高いのでそのまま。3回目：8と1→8の方が高いので交換。結果、一番背の高い8が右端に移動しました。",
    "overallExplanation": {
      "summary": "バブルソートの1パス目では、隣接する要素を左から順に比較・交換し、最大値を配列の末尾に移動させます。",
      "keyPoint": "1パスで最大値が末尾に確定する。隣接要素の比較・交換を左端から右端まで順に行う。",
      "relatedTopics": ["バブルソート完全実装", "選択ソート", "交換操作"],
      "studyTip": "バブルソートは「泡が浮き上がる」イメージ。1パスごとに未ソート部分の最大値が右端に移動します。"
    },
    "tags": ["バブルソート", "1パス", "交換", "基本"]
  },
  {
    "questionId": "q-algo-005",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "選択ソートの概念理解",
    "level": 1,
    "question": "選択ソート（昇順）の動作として正しいものはどれか。配列 data = {4, 2, 7, 1, 5} の最初の1ステップ目の結果を答えよ。",
    "pseudoCode": "○整数型の配列: data = {4, 2, 7, 1, 5}\n○整数型: minIdx, temp\n○整数型: i, j\n\n// 最初の1ステップ（i=0）\nminIdx ← 0\nj を 1 から 4 まで 1 ずつ増やしながら繰り返す\n  もし data[j] < data[minIdx] ならば\n    minIdx ← j\n  を実行する\nを繰り返す\n\n// data[0] と data[minIdx] を交換\ntemp ← data[0]\ndata[0] ← data[minIdx]\ndata[minIdx] ← temp",
    "choices": [
      {
        "id": "a",
        "text": "{1, 2, 7, 4, 5}",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "配列全体から最小値を探します。data[0]=4, data[1]=2, data[3]=1 が最小。minIdx=3。data[0]とdata[3]を交換して {1, 2, 7, 4, 5} になります。",
          "analogy": "トランプの手札から一番小さいカードを見つけて、一番左に持ってくる方法です。1が最小なので左端に移動します。",
          "deepDive": "選択ソートは「未ソート部分から最小値を選んで、ソート済み部分の末尾に追加する」を繰り返します。1ステップで1つの要素の位置が確定します。"
        }
      },
      {
        "id": "b",
        "text": "{2, 4, 7, 1, 5}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは最小値ではなく、最初に見つかった自分より小さい値（data[1]=2）と交換した結果です。選択ソートは全体から最小値を探してから交換します。",
          "analogy": "トランプで最初に見つけた小さいカードではなく、全部見て一番小さいカードを選ぶのが選択ソートです。"
        }
      },
      {
        "id": "c",
        "text": "{2, 4, 1, 7, 5}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはバブルソートのような隣接交換の結果に見えます。選択ソートは最小値の位置を特定してから、1回だけ交換を行います。",
          "analogy": "選択ソートは「全部見てから選ぶ」方式で、隣同士を順番に交換する方式（バブルソート）とは違います。"
        }
      },
      {
        "id": "d",
        "text": "{1, 4, 7, 2, 5}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "最小値 1 は正しく左端に来ていますが、元の data[0]=4 は data[3]（最小値があった位置）に入るべきです。交換なので元の位置関係が崩れています。",
          "analogy": "カードを交換するとき、1を左端に持ってきたら、元の左端のカード（4）は1があった場所に入ります。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"minIdx": 0}, "action": "minIdx を 0 で初期化（暫定最小値 = data[0]=4）"},
      {"step": 2, "variables": {"j": 1, "data[1]": 2, "minIdx": 1}, "action": "data[1]=2 < data[0]=4 → minIdx を 1 に更新"},
      {"step": 3, "variables": {"j": 2, "data[2]": 7, "minIdx": 1}, "action": "data[2]=7 > data[1]=2 → minIdx は変化なし"},
      {"step": 4, "variables": {"j": 3, "data[3]": 1, "minIdx": 3}, "action": "data[3]=1 < data[1]=2 → minIdx を 3 に更新"},
      {"step": 5, "variables": {"j": 4, "data[4]": 5, "minIdx": 3}, "action": "data[4]=5 > data[3]=1 → minIdx は変化なし"},
      {"step": 6, "variables": {"data": "{1, 2, 7, 4, 5}"}, "action": "data[0] と data[3] を交換"}
    ],
    "traceAnalogy": "教室で一番小さい子を探しています。最初の子（4）を基準にして、2番目の子（2）はもっと小さい→候補更新。3番目の子（7）は大きい→スルー。4番目の子（1）はさらに小さい→候補更新。5番目の子（5）は大きい→スルー。一番小さい子（1）を先頭に連れてきて、元の先頭の子（4）と場所を交換します。",
    "overallExplanation": {
      "summary": "選択ソートは、未ソート部分から最小値を見つけて先頭と交換する操作を繰り返すアルゴリズムです。",
      "keyPoint": "最小値のインデックスを記録してから交換する。毎回1つの要素の最終位置が確定する。",
      "relatedTopics": ["バブルソート", "挿入ソート", "最小値探索"],
      "studyTip": "選択ソートは「一番小さいのを探して前に持ってくる」の繰り返し。トランプの手札を小さい順に並べるイメージです。"
    },
    "tags": ["選択ソート", "最小値探索", "交換", "基本"]
  },
  {
    "questionId": "q-algo-006",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "データの並び替え基礎",
    "level": 1,
    "question": "次の擬似言語プログラムは、配列の隣接する2要素を比較して、昇順になるように交換する処理である。配列 data = {6, 2} に対して実行したとき、交換は行われるか。また、交換後の配列はどうなるか。",
    "pseudoCode": "○整数型の配列: data = {6, 2}\n○整数型: temp\n\nもし data[0] > data[1] ならば\n  temp ← data[0]\n  data[0] ← data[1]\n  data[1] ← temp\n  表示(\"交換した\")\nそうでなければ\n  表示(\"交換しない\")\nを実行する\n\n表示(data[0], data[1])",
    "choices": [
      {
        "id": "a",
        "text": "交換が行われ、{2, 6} になる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "data[0]=6 > data[1]=2 なので条件が成立し、交換が実行されます。temp=6, data[0]=2, data[1]=6 となり、結果は {2, 6} です。",
          "analogy": "2人の身長を比べて、背の高い人（6）が左にいたら右の人（2）と位置を入れ替えます。小さい人が左、大きい人が右になります。",
          "deepDive": "交換処理には一時変数（temp）が必要です。temp を使わずに直接代入すると、一方の値が上書きされて失われます。これは「コップの水の入れ替え」と同じ原理です。"
        }
      },
      {
        "id": "b",
        "text": "交換が行われ、{6, 2} のままになる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "交換は行われますが、結果は {2, 6} です。交換したのに元と同じでは交換の意味がありません。temp を使った3段階の代入を正しくトレースしましょう。",
          "analogy": "コップの水を入れ替えるとき、中身が変わらないことはありえません。"
        }
      },
      {
        "id": "c",
        "text": "交換は行われず、{6, 2} のままになる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "data[0]=6 > data[1]=2 なので条件 data[0] > data[1] は成立します。したがって交換が行われます。",
          "analogy": "左の人（6）の方が背が高いので、昇順にするために交換が必要です。"
        }
      },
      {
        "id": "d",
        "text": "交換は行われず、{2, 6} になる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "交換しないのに値が変わることはありません。条件が成立するので交換は実行され、その結果 {2, 6} になります。",
          "analogy": "何もしないのに勝手に並び替わることはありません。交換という操作があるからこそ変わります。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"data[0]": 6, "data[1]": 2}, "action": "data[0]=6 > data[1]=2 → 条件成立、交換処理に進む"},
      {"step": 2, "variables": {"temp": 6}, "action": "temp ← data[0] で temp に 6 を退避"},
      {"step": 3, "variables": {"data[0]": 2}, "action": "data[0] ← data[1] で data[0] に 2 を代入"},
      {"step": 4, "variables": {"data[1]": 6}, "action": "data[1] ← temp で data[1] に 6 を代入"},
      {"step": 5, "variables": {"data": "{2, 6}"}, "action": "交換完了。表示: 2, 6"}
    ],
    "traceAnalogy": "2つのコップにジュース（6）と水（2）が入っています。中身を入れ替えるために、まず空のコップ（temp）にジュースを移し、ジュースのコップに水を注ぎ、空いたコップにtempの中身を注ぎます。これで入れ替え完了です。",
    "overallExplanation": {
      "summary": "2つの要素を比較して必要に応じて交換する処理は、ソートアルゴリズムの最も基本的な構成要素です。",
      "keyPoint": "交換には一時変数（temp）が必要。直接代入では値が上書きされる。昇順なら data[0]>data[1] のとき交換する。",
      "relatedTopics": ["バブルソート", "選択ソート", "一時変数"],
      "studyTip": "交換処理（swap）はすべてのソートアルゴリズムで使われる基本操作です。3行の代入の順番を覚えましょう。"
    },
    "tags": ["交換処理", "比較", "swap", "基本"]
  },
  {
    "questionId": "q-algo-007",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "バブルソートの完全実装とトレース",
    "level": 2,
    "question": "次の擬似言語プログラムは、バブルソート（昇順）の完全な実装である。配列 data = {5, 2, 4, 1} に対して実行したとき、外側ループの2パス目（i=1）終了後の配列の状態はどれか。",
    "pseudoCode": "○整数型の配列: data = {5, 2, 4, 1}\n○整数型: temp\n○整数型: i, j\n○整数型: n ← 4\n\ni を 0 から n-2 まで 1 ずつ増やしながら繰り返す\n  j を 0 から n-2-i まで 1 ずつ増やしながら繰り返す\n    もし data[j] > data[j+1] ならば\n      temp ← data[j]\n      data[j] ← data[j+1]\n      data[j+1] ← temp\n    を実行する\n  を繰り返す\nを繰り返す",
    "choices": [
      {
        "id": "a",
        "text": "{2, 1, 4, 5}",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "1パス目(i=0): j=0~2で比較。{5,2,4,1}→{2,5,4,1}→{2,4,5,1}→{2,4,1,5}。2パス目(i=1): j=0~1で比較。{2,4,1,5}→そのまま→{2,1,4,5}。",
          "analogy": "泡が2回浮き上がった状態です。1回目で一番大きい5が右端に、2回目で2番目に大きい4がその左に確定しました。",
          "deepDive": "バブルソートの外側ループの i 回目が終わると、末尾から i+1 個の要素がソート済みになります。そのため内側ループの範囲が毎回1つ短くなります（n-2-i）。"
        }
      },
      {
        "id": "b",
        "text": "{1, 2, 4, 5}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは完全にソートされた最終結果です。2パス目終了時点ではまだ完全にはソートされていません。3パス目（i=2）で完了します。",
          "analogy": "まだ泡が2回しか浮かんでいないのに、全部きれいに並んだと判断するのは早すぎます。"
        }
      },
      {
        "id": "c",
        "text": "{2, 4, 1, 5}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは1パス目終了後の状態です。2パス目（i=1）でさらに比較・交換が行われ、{2,1,4,5} になります。",
          "analogy": "1回しか泡を上げていない状態で止まっています。2回目もちゃんと実行しましょう。"
        }
      },
      {
        "id": "d",
        "text": "{1, 2, 5, 4}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "2パス目の比較範囲は j=0~1（n-2-i = 4-2-1 = 1）です。正しくトレースすると {2,4,1,5} から {2,1,4,5} になります。",
          "analogy": "比較する範囲を間違えると結果もずれます。毎パスの比較範囲を確認しましょう。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"i": 0, "j": 0, "data": "{5, 2, 4, 1}"}, "action": "5>2 → 交換 → {2, 5, 4, 1}"},
      {"step": 2, "variables": {"i": 0, "j": 1, "data": "{2, 5, 4, 1}"}, "action": "5>4 → 交換 → {2, 4, 5, 1}"},
      {"step": 3, "variables": {"i": 0, "j": 2, "data": "{2, 4, 5, 1}"}, "action": "5>1 → 交換 → {2, 4, 1, 5}  ★1パス目終了、5が確定"},
      {"step": 4, "variables": {"i": 1, "j": 0, "data": "{2, 4, 1, 5}"}, "action": "2<4 → 交換なし"},
      {"step": 5, "variables": {"i": 1, "j": 1, "data": "{2, 4, 1, 5}"}, "action": "4>1 → 交換 → {2, 1, 4, 5}  ★2パス目終了、4が確定"}
    ],
    "traceAnalogy": "運動会の背の順並びです。1回目の整列で一番背の高い子（5）が右端に移動。2回目の整列で2番目に背の高い子（4）がその隣に移動。右側から順に位置が確定していきます。",
    "overallExplanation": {
      "summary": "バブルソートは隣接要素の比較・交換を繰り返し、各パスで未ソート部分の最大値を末尾に移動させるアルゴリズムです。",
      "keyPoint": "外側ループ i 回終了で末尾 i+1 個が確定。内側ループの範囲は n-2-i まで。計算量は O(n^2)。",
      "relatedTopics": ["選択ソート", "挿入ソート", "ソートの計算量"],
      "studyTip": "各パスで確定する要素の位置と、内側ループの範囲の変化を意識してトレースしましょう。"
    },
    "tags": ["バブルソート", "完全実装", "トレース"]
  },
  {
    "questionId": "q-algo-008",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "選択ソートの完全実装",
    "level": 2,
    "question": "次の擬似言語プログラムは、選択ソート（昇順）の完全な実装である。配列 data = {3, 1, 4, 2} に対して実行したとき、外側ループの2回目（i=1）終了後の配列の状態はどれか。",
    "pseudoCode": "○整数型の配列: data = {3, 1, 4, 2}\n○整数型: minIdx, temp\n○整数型: i, j\n○整数型: n ← 4\n\ni を 0 から n-2 まで 1 ずつ増やしながら繰り返す\n  minIdx ← i\n  j を i+1 から n-1 まで 1 ずつ増やしながら繰り返す\n    もし data[j] < data[minIdx] ならば\n      minIdx ← j\n    を実行する\n  を繰り返す\n  もし minIdx ≠ i ならば\n    temp ← data[i]\n    data[i] ← data[minIdx]\n    data[minIdx] ← temp\n  を実行する\nを繰り返す",
    "choices": [
      {
        "id": "a",
        "text": "{1, 2, 4, 3}",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "i=0: 未ソート部分{3,1,4,2}から最小値1(idx=1)を見つけ、data[0]と交換→{1,3,4,2}。i=1: 未ソート部分{3,4,2}から最小値2(idx=3)を見つけ、data[1]と交換→{1,2,4,3}。",
          "analogy": "トランプの手札から一番小さいカードを左に移す操作を2回行った状態です。1回目で1を左端に、2回目で2をその隣に配置しました。",
          "deepDive": "選択ソートでは i 回目のループ終了後、data[0]~data[i] がソート済みになります。バブルソートが右端から確定するのに対し、選択ソートは左端から確定します。"
        }
      },
      {
        "id": "b",
        "text": "{1, 2, 3, 4}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "完全にソートされた最終結果です。i=1 終了時点ではまだ data[2] 以降は未ソートで、{1,2,4,3} の状態です。",
          "analogy": "まだ2枚しか正しい位置に置いていないのに、全部並んだことにするのは早いです。"
        }
      },
      {
        "id": "c",
        "text": "{1, 3, 4, 2}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは i=0 終了後の状態です。i=1 では未ソート部分 {3,4,2} から最小値 2 を見つけて data[1]=3 と交換します。",
          "analogy": "1回目の操作だけで止まっています。2回目の操作も正しく実行しましょう。"
        }
      },
      {
        "id": "d",
        "text": "{1, 3, 2, 4}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "i=1 で最小値を探す範囲は data[1]~data[3]={3,4,2} です。最小値は 2(idx=3) であり、data[1]=3 と交換して {1,2,4,3} になります。",
          "analogy": "最小値を正確に特定できていません。{3,4,2}の中で一番小さいのは2です。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"i": 0, "minIdx": 0, "data": "{3, 1, 4, 2}"}, "action": "i=0: minIdx=0 から開始"},
      {"step": 2, "variables": {"j": 1, "minIdx": 1}, "action": "data[1]=1 < data[0]=3 → minIdx=1"},
      {"step": 3, "variables": {"j": 2, "minIdx": 1}, "action": "data[2]=4 > data[1]=1 → minIdx変化なし"},
      {"step": 4, "variables": {"j": 3, "minIdx": 1}, "action": "data[3]=2 > data[1]=1 → minIdx変化なし"},
      {"step": 5, "variables": {"data": "{1, 3, 4, 2}"}, "action": "data[0]とdata[1]を交換。i=0 終了"},
      {"step": 6, "variables": {"i": 1, "minIdx": 1}, "action": "i=1: minIdx=1 から開始"},
      {"step": 7, "variables": {"j": 2, "minIdx": 1}, "action": "data[2]=4 > data[1]=3 → minIdx変化なし"},
      {"step": 8, "variables": {"j": 3, "minIdx": 3}, "action": "data[3]=2 < data[1]=3 → minIdx=3"},
      {"step": 9, "variables": {"data": "{1, 2, 4, 3}"}, "action": "data[1]とdata[3]を交換。i=1 終了"}
    ],
    "traceAnalogy": "トランプの手札 {3,1,4,2} を小さい順に並べます。1回目：全部見て一番小さい1を左端に。2回目：残り{3,4,2}を見て一番小さい2を2番目に。左から2枚が確定しました。",
    "overallExplanation": {
      "summary": "選択ソートは未ソート部分から最小値を選び出し、ソート済み部分の末尾に配置する操作を繰り返します。",
      "keyPoint": "左から順に確定していく。毎回、残りの要素全体から最小値を探すため、比較回数はデータに依存せず常に O(n^2)。",
      "relatedTopics": ["バブルソート", "挿入ソート", "計算量"],
      "studyTip": "選択ソートは交換回数が少ない（各ステップで最大1回）のが特徴です。バブルソートとの違いを意識しましょう。"
    },
    "tags": ["選択ソート", "完全実装", "トレース"]
  },
  {
    "questionId": "q-algo-009",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "挿入ソートの基本",
    "level": 2,
    "question": "次の擬似言語プログラムは、挿入ソートの1ステップ（i=2）を示している。配列 data の状態が {2, 5, 3, 8, 1} のとき、i=2 のステップ終了後の配列はどれか。",
    "pseudoCode": "○整数型の配列: data = {2, 5, 3, 8, 1}\n○整数型: key, j\n○整数型: i ← 2\n\n// i=2 のステップ\nkey ← data[i]  // key = 3\nj ← i - 1      // j = 1\n\nj >= 0 かつ data[j] > key の間繰り返す\n  data[j+1] ← data[j]\n  j ← j - 1\nを繰り返す\n\ndata[j+1] ← key",
    "choices": [
      {
        "id": "a",
        "text": "{2, 3, 5, 8, 1}",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "key=3, j=1。data[1]=5>3なのでdata[2]=5にシフト、j=0。data[0]=2<3なのでループ終了。data[j+1]=data[1]=3を挿入。結果: {2,3,5,8,1}。",
          "analogy": "トランプの手札で、3のカードを正しい位置に差し込む操作です。5を右にずらして、2の右側に3を挿入します。",
          "deepDive": "挿入ソートは「ソート済み部分に新しい要素を正しい位置に挿入する」という操作です。シフト操作は交換と異なり、要素を1つずつ右にずらして空席を作ります。"
        }
      },
      {
        "id": "b",
        "text": "{2, 3, 5, 1, 8}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "i=2 のステップでは data[2]=3 を挿入するだけで、data[3] 以降は変化しません。8 と 1 の位置は変わりません。",
          "analogy": "今回動かすのは3のカードだけです。右側のカードはまだ触りません。"
        }
      },
      {
        "id": "c",
        "text": "{2, 5, 3, 8, 1}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "元の配列のままで変化なしという答えですが、data[1]=5>key=3 なのでシフトが発生し、3 は data[1] の位置に挿入されます。",
          "analogy": "3は5より小さいので、5の左に入る必要があります。そのまま放置はできません。"
        }
      },
      {
        "id": "d",
        "text": "{3, 2, 5, 8, 1}",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "3 を先頭に入れるのは誤りです。j=0 のとき data[0]=2<3 なのでループが終了し、data[j+1]=data[1] に 3 が挿入されます。2 の前ではなく、2 の後ろです。",
          "analogy": "3は2より大きいので、2の左側ではなく右側に入ります。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"key": 3, "j": 1, "data": "{2, 5, 3, 8, 1}"}, "action": "key ← data[2]=3、j ← 1"},
      {"step": 2, "variables": {"j": 1, "data[1]": 5}, "action": "j=1>=0 かつ data[1]=5>3 → data[2]←5 → {2, 5, 5, 8, 1}"},
      {"step": 3, "variables": {"j": 0, "data[0]": 2}, "action": "j=0>=0 かつ data[0]=2>3? → No（2<3）→ ループ終了"},
      {"step": 4, "variables": {"data": "{2, 3, 5, 8, 1}"}, "action": "data[j+1]=data[1] ← key=3 → {2, 3, 5, 8, 1}"}
    ],
    "traceAnalogy": "手持ちのトランプ {2, 5} にカード3を挿入します。右端の5は3より大きいので右にずらします。次の2は3より小さいのでストップ。2の右隣に3を差し込んで {2, 3, 5} の完成です。",
    "overallExplanation": {
      "summary": "挿入ソートは、未ソート部分の先頭要素をソート済み部分の正しい位置に挿入する操作を繰り返すアルゴリズムです。",
      "keyPoint": "key を退避してから、key より大きい要素を右にシフトし、空いた場所に key を挿入する。",
      "relatedTopics": ["バブルソート", "選択ソート", "シェルソート"],
      "studyTip": "挿入ソートは「トランプの手札を整理する方法」そのものです。新しいカードを引いたら、正しい位置に差し込みます。"
    },
    "tags": ["挿入ソート", "基本", "シフト操作"]
  },
  {
    "questionId": "q-algo-010",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "二分探索の基本概念",
    "level": 2,
    "question": "次の擬似言語プログラムは、昇順にソート済みの配列 data から値 key を二分探索で探す処理である。data = {1, 3, 5, 7, 9, 11, 13}、key = 7 のとき、key が見つかるまでに比較する回数は何回か。",
    "pseudoCode": "○整数型の配列: data = {1, 3, 5, 7, 9, 11, 13}\n○整数型: key ← 7\n○整数型: low ← 0, high ← 6, mid\n○整数型: count ← 0\n\nlow <= high の間繰り返す\n  mid ← (low + high) ÷ 2  // 小数点以下切り捨て\n  count ← count + 1\n  もし data[mid] = key ならば\n    表示(\"見つかった: インデックス\", mid)\n    表示(\"比較回数:\", count)\n    return\n  そうでなくもし data[mid] < key ならば\n    low ← mid + 1\n  そうでなければ\n    high ← mid - 1\n  を実行する\nを繰り返す",
    "choices": [
      {
        "id": "a",
        "text": "1回",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "mid = (0+6)÷2 = 3。data[3]=7 = key=7 で、1回目の比較で即座に見つかります。key がちょうど配列の中央に位置しているためです。",
          "analogy": "辞書で真ん中のページを開いたら、いきなり探していた単語があった、というラッキーなケースです。",
          "deepDive": "二分探索のベストケースは O(1) で、探す値が最初の中央値と一致する場合です。最悪ケースは O(log n) で、要素数7なら最大3回（log2(7)≒2.8→3回）です。"
        }
      },
      {
        "id": "b",
        "text": "2回",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "最初の mid=(0+6)÷2=3 で data[3]=7=key なので、1回目の比較で見つかります。2回目の比較は不要です。",
          "analogy": "辞書を開いて1ページ目で見つかったのに、もう1ページめくる必要はありません。"
        }
      },
      {
        "id": "c",
        "text": "3回",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "3回は二分探索の最悪ケース（端の方にある値を探す場合）の比較回数です。7 は配列の中央にあるので1回で見つかります。",
          "analogy": "辞書の最初や最後の方の単語を探すなら3回かかりますが、真ん中なら1回です。"
        }
      },
      {
        "id": "d",
        "text": "4回",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "要素数7の配列に対する二分探索は最大でも3回で終了します。4回は理論上ありえません。",
          "analogy": "7ページの辞書を半分ずつにしていけば、3回で必ずどのページにも到達できます。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"low": 0, "high": 6, "mid": 3, "data[mid]": 7, "count": 1}, "action": "mid=(0+6)÷2=3、data[3]=7=key → 見つかった！"}
    ],
    "traceAnalogy": "辞書で「な行」の言葉を探すとき、まず辞書の真ん中を開きます。ちょうど「な行」のページだったので、1回で目的の場所に到着しました。",
    "overallExplanation": {
      "summary": "二分探索はソート済み配列の中央値と比較して探索範囲を半分に絞り込む効率的な探索アルゴリズムです。",
      "keyPoint": "探索範囲の中央の値と比較し、目的値が大きければ右半分、小さければ左半分に絞り込む。前提条件はデータがソート済みであること。",
      "relatedTopics": ["線形探索", "二分探索木", "計算量"],
      "studyTip": "二分探索は「しりとりの数当てゲーム」と同じ原理。「もっと大きい」「もっと小さい」のヒントで範囲を半分にしていきます。"
    },
    "tags": ["二分探索", "基本概念", "比較回数"]
  },
  {
    "questionId": "q-algo-011",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "番兵法を使った探索",
    "level": 2,
    "question": "次の擬似言語プログラムは、番兵法を使った線形探索である。配列 data = {4, 7, 2, 9, _} （最後の要素は番兵用）で key = 2 を探すとき、ループ終了後の i の値はどれか。",
    "pseudoCode": "○整数型の配列: data = {4, 7, 2, 9, 0}  // data[4]は番兵用\n○整数型: key ← 2\n○整数型: n ← 4  // 実データの個数\n○整数型: i ← 0\n\n// 番兵を設置\ndata[n] ← key\n\n// 番兵法による探索\ndata[i] ≠ key の間繰り返す\n  i ← i + 1\nを繰り返す\n\nもし i < n ならば\n  表示(\"見つかった: インデックス\", i)\nそうでなければ\n  表示(\"見つからなかった\")\nを実行する",
    "choices": [
      {
        "id": "a",
        "text": "2",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "data[4]にkey=2を番兵として設置。i=0: data[0]=4≠2→i=1。i=1: data[1]=7≠2→i=2。i=2: data[2]=2=2→ループ終了。i=2で、i<n(=4)なので「見つかった」と表示。",
          "analogy": "廊下の突き当たりに先生（番兵）を立たせておきます。生徒を探しながら歩いていくと、2番目の部屋で目的の生徒を見つけました。突き当たりの先生のところまで行く必要はありませんでした。",
          "deepDive": "番兵法は通常の線形探索で必要な「配列の範囲チェック（i < n）」をループ条件から省略できる手法です。番兵が必ずループを止めるため、ループ条件が1つになり高速化できます。"
        }
      },
      {
        "id": "b",
        "text": "4",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "i=4 になるのは、実データ内に key が存在しない場合（番兵で止まった場合）です。data[2]=2=key なので i=2 で止まります。",
          "analogy": "目的の生徒が廊下にいるのに、気づかずに突き当たりまで歩いてしまうのは探し方が雑です。"
        }
      },
      {
        "id": "c",
        "text": "3",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "data[2]=2=key の時点でループが終了するので、i=3 にはなりません。i=2 が正解です。",
          "analogy": "見つけた部屋を通り過ぎてしまっています。見つけたらその場で立ち止まります。"
        }
      },
      {
        "id": "d",
        "text": "0",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "data[0]=4≠key(=2) なので、i=0 ではループが終了しません。i は 1, 2 と進み、data[2]=2=key で止まります。",
          "analogy": "最初の部屋（4）は探している人（2）ではないので、先に進む必要があります。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"data": "{4, 7, 2, 9, 2}", "i": 0}, "action": "番兵設置: data[4]←2"},
      {"step": 2, "variables": {"i": 0}, "action": "data[0]=4 ≠ 2 → i を 1 に増加"},
      {"step": 3, "variables": {"i": 1}, "action": "data[1]=7 ≠ 2 → i を 2 に増加"},
      {"step": 4, "variables": {"i": 2}, "action": "data[2]=2 = 2 → ループ終了"},
      {"step": 5, "variables": {"i": 2}, "action": "i=2 < n=4 → 見つかった！インデックス2"}
    ],
    "traceAnalogy": "長い廊下に部屋が並んでいます。突き当たりに先生（番兵=2）を立たせておきます。部屋を1つずつ覗いて「2番の生徒はいるかな？」と確認。3つ目の部屋で見つかりました。先生のところまで行かなくても安心です。",
    "overallExplanation": {
      "summary": "番兵法は配列の末尾に探索値を設置し、ループ条件を簡略化する探索の高速化テクニックです。",
      "keyPoint": "番兵を末尾に置くことでループ内の境界チェックが不要になる。ループ後に i < n で実データ内で見つかったか番兵で止まったかを判定する。",
      "relatedTopics": ["線形探索", "二分探索", "探索の計算量"],
      "studyTip": "番兵法のポイントは「必ずどこかで止まることが保証される」こと。これにより毎回の範囲チェックを省略できます。"
    },
    "tags": ["番兵法", "線形探索", "高速化"]
  },
  {
    "questionId": "q-algo-012",
    "examType": "科目B",
    "category": "アルゴリズム",
    "subcategory": "アルゴリズム（ソート・探索）",
    "topic": "ソートの安定性",
    "level": 2,
    "question": "次のデータをソートする場合を考える。レコード {(A,3), (B,1), (C,3), (D,2)} を第2要素（数値）の昇順でソートする。安定なソートを使用した場合の結果はどれか。\n\n※ (A,3) は「名前=A、値=3」を意味する。",
    "pseudoCode": "// 安定ソートの概念説明用擬似コード\n// 入力: records = {(A,3), (B,1), (C,3), (D,2)}\n// ソートキー: 第2要素（数値）\n\n○レコード型の配列: records = {(A,3), (B,1), (C,3), (D,2)}\n\n// 安定ソート: 同じキー値のレコードは\n// 元の順序が保持される\n安定ソート(records, キー=第2要素, 昇順)\n\n表示(records)",
    "choices": [
      {
        "id": "a",
        "text": "(B,1), (D,2), (A,3), (C,3)",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "安定ソートでは、同じキー値を持つ要素の相対的な順序が保持されます。A(値3)とC(値3)は元の順序でAが先なので、ソート後もAがCより先に来ます。",
          "analogy": "身長順に並んでもらうとき、同じ身長の人は元の出席番号順を維持するのが「安定」な並び替えです。AさんとCさんは同じ身長3なので、元の順序（A→C）を保ちます。",
          "deepDive": "安定なソートアルゴリズムの例: バブルソート、挿入ソート、マージソート。不安定なソートの例: 選択ソート、クイックソート、ヒープソート。安定性が重要なのは、複数キーでのソートなどの場面です。"
        }
      },
      {
        "id": "b",
        "text": "(B,1), (D,2), (C,3), (A,3)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは不安定なソートの結果の一例です。A(値3)とC(値3)の順序が元（A→C）から逆転（C→A）しており、安定ソートの条件を満たしません。",
          "analogy": "同じ身長の人の順序が入れ替わってしまうのは「不安定」な並び替えです。"
        }
      },
      {
        "id": "c",
        "text": "(D,2), (B,1), (A,3), (C,3)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "昇順にソートすると値が小さい順（1→2→3）に並ぶべきです。(D,2)が(B,1)より先に来ているのは正しくありません。",
          "analogy": "身長順（低い→高い）に並ぶはずなのに、2番目に低い人が先頭に来ています。"
        }
      },
      {
        "id": "d",
        "text": "(A,3), (B,1), (C,3), (D,2)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは元のデータそのままで、ソートされていません。昇順にソートすると値 1→2→3 の順に並ぶ必要があります。",
          "analogy": "まだ並び替えを始めてすらいない状態です。"
        }
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"records": "{(A,3), (B,1), (C,3), (D,2)}"}, "action": "元のデータ。A(3)はC(3)より前にある"},
      {"step": 2, "variables": {"records": "{(B,1), (D,2), (A,3), (C,3)}"}, "action": "安定ソート結果。同じ値3のA,Cは元の順序を維持"}
    ],
    "traceAnalogy": "生徒を身長順に並べ替えるとき、同じ身長の生徒は出席番号順を維持するのが安定ソートです。Aさん(3)とCさん(3)は同じ身長なので、元々の順序（Aが先）をそのまま維持します。",
    "overallExplanation": {
      "summary": "安定ソートとは、同じキー値を持つ要素の相対的な順序がソート前後で保持されるソートアルゴリズムのことです。",
      "keyPoint": "安定：バブルソート、挿入ソート、マージソート。不安定：選択ソート、クイックソート、ヒープソート。",
      "relatedTopics": ["バブルソート", "挿入ソート", "マージソート", "クイックソート"],
      "studyTip": "安定ソートは「同じ値の元の順序を守る」と覚えましょう。複数の条件でソートするとき重要になります。"
    },
    "tags": ["安定ソート", "ソートの性質", "概念理解"]
  }]
