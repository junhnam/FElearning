[
  {
    "questionId": "q-trace-039",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "クイックソートのパーティション",
    "level": 6,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: A ← {5, 3, 8, 1, 4, 7, 2, 6}\n○整数型: pivot, left, right, temp\npivot ← A[0]\nleft ← 1\nright ← 7\nleft ≦ right の間繰り返す\n  left ≦ right かつ A[left] ≦ pivot の間繰り返す\n    left ← left + 1\n  を繰り返す\n  left ≦ right かつ A[right] > pivot の間繰り返す\n    right ← right - 1\n  を繰り返す\n  もし left < right ならば\n    temp ← A[left]\n    A[left] ← A[right]\n    A[right] ← temp\n  を実行する\nを繰り返す\ntemp ← A[0]\nA[0] ← A[right]\nA[right] ← temp\n表示(right)",
    "choices": [
      {
        "text": "4",
        "isCorrect": true,
        "whyCorrect": "ピボット値5に対して、左からピボット以上の要素、右からピボット以下の要素を探して交換を繰り返します。最終的にrightが4の位置で停止し、ピボットとA[4]を交換します。配列は{2, 3, 4, 1, 5, 7, 8, 6}となり、ピボットのインデックス4が表示されます。",
        "analogy": "教室で「身長160cm」を基準に並び替えるとき、左端の基準の子と右側の低い子を交換していき、最終的に基準の子が正しい位置（左から5番目＝インデックス4）に収まるのと同じです。",
        "deepDive": "パーティション操作はクイックソートの核心部分です。ピボットより小さい要素を左側に、大きい要素を右側に振り分け、ピボットの最終位置を返します。この操作の計算量はO(n)です。"
      },
      {
        "text": "3",
        "isCorrect": false,
        "whyWrong": "rightの移動を途中で止めてしまうとこの値になりますが、実際にはrightは値1の位置（インデックス3）を通過した後、A[right]>pivotの条件でさらに移動が止まるのはインデックス4です。leftとrightの交差判定を正確にトレースする必要があります。",
        "analogy": "並び替えの仕切り位置を1つ手前で間違えたようなものです。基準値より小さい要素がまだ右側に残っている状態です。"
      },
      {
        "text": "5",
        "isCorrect": false,
        "whyWrong": "ピボット値の5と混同している可能性があります。表示されるのはピボットの最終的な配列上の位置（インデックス）であり、ピボットの値そのものではありません。",
        "analogy": "選手の背番号（値5）と、整列後の順位（4番目の位置）を混同しているようなものです。聞かれているのは「何番目の位置か」です。"
      },
      {
        "text": "2",
        "isCorrect": false,
        "whyWrong": "最初のleftの停止位置（A[2]=8がpivotより大きい）をそのまま答えにしてしまった場合の値です。パーティションでは交換処理を繰り返した後のrightの最終位置が答えになります。",
        "analogy": "仕分け作業の最初の1回だけ見て「ここが分割点」と判断してしまい、残りの作業を見落としたようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"A": "{5,3,8,1,4,7,2,6}", "pivot": 5, "left": 1, "right": 7}, "action": "配列と変数を初期化。ピボットはA[0]=5"},
      {"step": 2, "variables": {"left": 2, "right": 7}, "action": "内側左ループ: A[1]=3≦5→left=2, A[2]=8>5→停止。left=2"},
      {"step": 3, "variables": {"left": 2, "right": 6}, "action": "内側右ループ: A[7]=6>5→right=6, A[6]=2≦5→停止。right=6"},
      {"step": 4, "variables": {"A": "{5,3,2,1,4,7,8,6}", "left": 2, "right": 6}, "action": "left(2)<right(6)なのでA[2]とA[6]を交換。{5,3,2,1,4,7,8,6}"},
      {"step": 5, "variables": {"left": 5, "right": 6}, "action": "内側左ループ: A[3]=1≦5→left=3, A[4]=4≦5→left=4, A[5]=7>5→停止。left=5"},
      {"step": 6, "variables": {"left": 5, "right": 4}, "action": "内側右ループ: A[6]=8>5→right=5, A[5]=7>5→right=4, A[4]=4≦5→停止。right=4"},
      {"step": 7, "variables": {"left": 5, "right": 4}, "action": "left(5)≧right(4)なので交換しない。外側ループもleft>rightで終了"},
      {"step": 8, "variables": {"A": "{4,3,2,1,5,7,8,6}", "right": 4}, "action": "A[0]とA[right]=A[4]を交換。{4,3,2,1,5,7,8,6}。rightの値4を表示"}
    ],
    "traceAnalogy": "本棚の整理で「5巻」を基準にして、左側には5巻より前の巻を、右側には5巻より後の巻を集めます。左から6巻以降を探し、右から4巻以前を探して見つかったら交換します。全部仕分け終わったら、基準の5巻を正しい位置に置きます。その位置が答えです。",
    "overallExplanation": "クイックソートのパーティション操作をトレースする問題です。ピボット値5を基準に、配列を「5以下」と「5より大きい」に分割します。leftとrightの2つのポインタが交差するまで要素を交換し、最後にピボットをrightの位置に移動させます。rightの最終値4がピボットの正しい位置となり、これが表示されます。"
  },
  {
    "questionId": "q-trace-040",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "再帰的二分探索",
    "level": 6,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: A ← {2, 5, 8, 12, 16, 23, 38, 45, 56, 72}\n○整数型: result\n\n○関数 二分探索(A[], low, high, target) → 整数型\n  もし low > high ならば\n    返却値 ← -1\n  を実行する\n  ○整数型: mid\n  mid ← (low + high) ÷ 2\n  もし A[mid] = target ならば\n    返却値 ← mid\n  そうでなくもし A[mid] > target ならば\n    返却値 ← 二分探索(A, low, mid - 1, target)\n  そうでなければ\n    返却値 ← 二分探索(A, mid + 1, high, target)\n  を実行する\n\nresult ← 二分探索(A, 0, 9, 23)\n表示(result)",
    "choices": [
      {
        "text": "5",
        "isCorrect": true,
        "whyCorrect": "二分探索で23を探します。1回目: mid=4, A[4]=16<23→右半分へ。2回目: mid=7, A[7]=45>23→左半分へ。3回目: mid=5, A[5]=23=23→発見。インデックス5を返します。",
        "analogy": "辞書で「さ行」の言葉を探すとき、まず真ん中を開いて「た行」→前半へ、次に真ん中を開いて「し行」→後半へ、と絞り込んでいくのと同じです。3回目で目的のページが見つかります。",
        "deepDive": "再帰的二分探索は、探索範囲を半分ずつ絞り込みます。計算量はO(log n)で、要素数10の配列なら最大4回の比較で見つかります。再帰の深さがスタックに積まれるため、非常に大きな配列では再帰の深さ制限に注意が必要です。"
      },
      {
        "text": "4",
        "isCorrect": false,
        "whyWrong": "これは1回目の探索でmid=4を計算した値です。A[4]=16≠23なので、ここでは見つからず探索が続きます。midの計算結果と最終的な発見位置を混同しています。",
        "analogy": "辞書を最初に開いたページが答えではなく、さらに絞り込んだ先に目的のページがあるのと同じです。"
      },
      {
        "text": "7",
        "isCorrect": false,
        "whyWrong": "これは2回目の探索でmid=7を計算した値です。A[7]=45>23なので左半分に進みます。探索途中のmid値を最終結果と間違えています。",
        "analogy": "辞書で目的より後ろのページを開いたので前に戻る途中で、まだ正しいページに到達していない状態です。"
      },
      {
        "text": "23",
        "isCorrect": false,
        "whyWrong": "23は探索対象の値そのものです。この関数が返すのは値23が格納されている配列のインデックス（位置）であり、値そのものではありません。",
        "analogy": "図書館で本を探すとき、本のタイトル（23）ではなく、本がある棚の番号（5）を聞かれているようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"low": 0, "high": 9, "target": 23}, "action": "二分探索(A, 0, 9, 23) を呼び出し"},
      {"step": 2, "variables": {"low": 0, "high": 9, "mid": 4}, "action": "mid = (0+9)÷2 = 4。A[4]=16 < 23 なので右半分へ再帰"},
      {"step": 3, "variables": {"low": 5, "high": 9, "mid": 7}, "action": "二分探索(A, 5, 9, 23)。mid = (5+9)÷2 = 7。A[7]=45 > 23 なので左半分へ再帰"},
      {"step": 4, "variables": {"low": 5, "high": 6, "mid": 5}, "action": "二分探索(A, 5, 6, 23)。mid = (5+6)÷2 = 5。A[5]=23 = 23 で発見"},
      {"step": 5, "variables": {"result": 5}, "action": "mid=5 を返却。呼び出し元に順次戻り、result=5"},
      {"step": 6, "variables": {"result": 5}, "action": "result の値 5 を表示"}
    ],
    "traceAnalogy": "10冊の本が番号順に並んだ本棚で23番の本を探します。まず真ん中（5冊目=16番）を見ると小さいので右半分へ。次に右半分の真ん中（8冊目=45番）を見ると大きいので左半分へ。最後に6冊目を見ると23番で発見。「6冊目の位置（インデックス5）」が答えです。",
    "overallExplanation": "再帰的二分探索のトレース問題です。整列済み配列から値23を探索します。再帰呼び出しのたびに探索範囲が半分になり、3回の呼び出しで目的の要素を発見します。返却値はインデックス5であり、再帰の巻き戻しで呼び出し元に順次伝搬されます。"
  },
  {
    "questionId": "q-trace-041",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "連結リスト操作（ノード追加）",
    "level": 6,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: data ← {0, 10, 30, 0, 0}\n○整数型の配列: next ← {1, 2, -1, -1, -1}\n○整数型: head ← 0\n○整数型: newNode ← 3\ndata[newNode] ← 20\n\n/* 挿入位置を探す */\n○整数型: prev ← -1\n○整数型: curr ← head\ncurr ≠ -1 かつ data[curr] < data[newNode] の間繰り返す\n  prev ← curr\n  curr ← next[curr]\nを繰り返す\n\n/* ノードを挿入 */\nnext[newNode] ← curr\nもし prev = -1 ならば\n  head ← newNode\nそうでなければ\n  next[prev] ← newNode\nを実行する\n\n/* リストを先頭からたどって3番目のノードの値を表示 */\n○整数型: p ← head\n○整数型: count ← 1\ncount < 3 の間繰り返す\n  p ← next[p]\n  count ← count + 1\nを繰り返す\n表示(data[p])",
    "choices": [
      {
        "text": "20",
        "isCorrect": true,
        "whyCorrect": "初期リストは0→10→30。値20のノードを挿入位置を探して追加すると、10の後ろ・30の前に入り、0→10→20→30となります。先頭から3番目のノードの値は20です。",
        "analogy": "番号順に並んだ行列に新しい人（20番）が割り込むとき、10番の人の後ろ、30番の人の前に入ります。先頭から3人目を聞かれると20番の人です。",
        "deepDive": "配列を使った連結リストの実装では、data配列が値を、next配列が次のノードのインデックスを保持します。ソート済みリストへの挿入はO(n)ですが、挿入操作自体はポインタの付け替えのみでO(1)です。"
      },
      {
        "text": "30",
        "isCorrect": false,
        "whyWrong": "挿入前のリストで3番目のノード（0→10→30）の値30です。しかし20のノードが10と30の間に挿入されるため、挿入後の3番目は20になります。",
        "analogy": "新しい人が行列に入る前の3番目と、入った後の3番目は違う人になります。挿入後の状態で数える必要があります。"
      },
      {
        "text": "10",
        "isCorrect": false,
        "whyWrong": "リストの2番目のノードの値です。先頭から3番目を正しく数えると、0→10→20→30の3番目は20です。countの初期値やループ条件を確認しましょう。",
        "analogy": "行列の2人目と3人目を数え間違えたようなものです。1人目から順に数えて3人目を探す必要があります。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "リストの先頭ノードの値です。headからたどり始めて3回目に到達するノードではなく、開始位置のノードの値を答えてしまっています。",
        "analogy": "行列の1人目を見て「これが3人目だ」と言っているようなものです。先頭から2つ先に進む必要があります。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"data": "{0,10,30,0,0}", "next": "{1,2,-1,-1,-1}", "head": 0}, "action": "初期状態。リスト: data[0]=0→data[1]=10→data[2]=30"},
      {"step": 2, "variables": {"newNode": 3, "data[3]": 20}, "action": "新ノードのインデックス3にdata値20を設定"},
      {"step": 3, "variables": {"prev": -1, "curr": 0}, "action": "探索開始。data[0]=0 < 20 → 続行"},
      {"step": 4, "variables": {"prev": 0, "curr": 1}, "action": "prev=0, curr=next[0]=1。data[1]=10 < 20 → 続行"},
      {"step": 5, "variables": {"prev": 1, "curr": 2}, "action": "prev=1, curr=next[1]=2。data[2]=30 ≧ 20 → ループ終了"},
      {"step": 6, "variables": {"next[3]": 2, "next[1]": 3}, "action": "next[3]=2（新ノードの次は30のノード）。prev≠-1なのでnext[1]=3（10の次を新ノードに）"},
      {"step": 7, "variables": {"p": 0, "count": 1}, "action": "リスト走査開始。0→10→20→30の順"},
      {"step": 8, "variables": {"p": 1, "count": 2}, "action": "p=next[0]=1, count=2"},
      {"step": 9, "variables": {"p": 3, "count": 3}, "action": "p=next[1]=3, count=3。ループ終了。data[3]=20を表示"}
    ],
    "traceAnalogy": "荷物の受け渡しリレーのようなものです。最初は「Aさん→Bさん→Dさん」の順でしたが、新しいCさん（値20）がBさんとDさんの間に入ります。Bさんは次の人をCさんに変え、Cさんの次はDさんにします。先頭から3人目はCさん（20）です。",
    "overallExplanation": "配列で実装した連結リストに、ソート順を維持したまま新ノードを挿入する問題です。挿入位置はprevとcurrの2つのポインタで探索し、data[curr]≧data[newNode]となった時点でprevとcurrの間に挿入します。挿入後のリストを先頭から3番目までたどると値20が得られます。"
  },
  {
    "questionId": "q-trace-042",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "リングバッファキュー",
    "level": 6,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: buf ← {0, 0, 0, 0, 0}  /* サイズ5 */\n○整数型: front ← 0, rear ← 0, size ← 0\n○整数型: maxSize ← 5\n○整数型: val\n\n○手続き enqueue(x)\n  buf[rear] ← x\n  rear ← (rear + 1) mod maxSize\n  size ← size + 1\n\n○関数 dequeue() → 整数型\n  val ← buf[front]\n  front ← (front + 1) mod maxSize\n  size ← size - 1\n  返却値 ← val\n\nenqueue(10) を実行\nenqueue(20) を実行\nenqueue(30) を実行\ndequeue() を実行  /* 結果は使わない */\ndequeue() を実行  /* 結果は使わない */\nenqueue(40) を実行\nenqueue(50) を実行\nenqueue(60) を実行\n表示(buf[front])",
    "choices": [
      {
        "text": "30",
        "isCorrect": true,
        "whyCorrect": "enqueue(10,20,30)でbuf={10,20,30,0,0}, front=0, rear=3。dequeue2回でfront=2。enqueue(40,50,60)でbuf={60,20,30,40,50}, rear=1。front=2なのでbuf[2]=30が表示されます。",
        "analogy": "回転寿司のレーンのように、皿が一周して戻ってきます。2皿取った後の先頭位置にある皿は、最初に流した3皿目（30）です。",
        "deepDive": "リングバッファは配列の末尾と先頭が循環的につながったデータ構造です。mod演算によりインデックスが配列サイズを超えると先頭に戻ります。固定サイズのメモリで効率的なキュー操作が可能で、OSのバッファ管理などで広く使われます。"
      },
      {
        "text": "40",
        "isCorrect": false,
        "whyWrong": "dequeue後にfrontがrearの位置まで進んだと誤解した場合の値です。frontはdequeue1回ごとに1つずつしか進みません。2回のdequeueでfront=2となり、buf[2]=30が正しい値です。",
        "analogy": "回転寿司で2皿取った後、次に来る新しい皿ではなく、まだレーン上に残っている古い皿から順に取るのがキューの原則です。"
      },
      {
        "text": "60",
        "isCorrect": false,
        "whyWrong": "rearの直前の位置（最後にenqueueした値）を参照した場合の値です。キューはFIFO（先入れ先出し）なので、frontが指す位置が次に取り出される要素です。rearではなくfrontを参照する必要があります。",
        "analogy": "行列の最後尾の人ではなく、先頭の人が次にサービスを受けるのがキューの原則です。"
      },
      {
        "text": "10",
        "isCorrect": false,
        "whyWrong": "frontが初期値0のままだと誤解した場合の値です。dequeueを2回実行しているため、frontは0→1→2と進みます。buf[0]=10ではなくbuf[2]=30が正解です。",
        "analogy": "行列で2人がサービスを受けて去った後も、先頭が変わらないと思っているようなものです。先頭は2人分前に進みます。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"buf": "{0,0,0,0,0}", "front": 0, "rear": 0, "size": 0}, "action": "初期状態"},
      {"step": 2, "variables": {"buf": "{10,0,0,0,0}", "rear": 1, "size": 1}, "action": "enqueue(10): buf[0]=10, rear=(0+1)%5=1"},
      {"step": 3, "variables": {"buf": "{10,20,0,0,0}", "rear": 2, "size": 2}, "action": "enqueue(20): buf[1]=20, rear=(1+1)%5=2"},
      {"step": 4, "variables": {"buf": "{10,20,30,0,0}", "rear": 3, "size": 3}, "action": "enqueue(30): buf[2]=30, rear=(2+1)%5=3"},
      {"step": 5, "variables": {"front": 1, "size": 2}, "action": "dequeue(): val=buf[0]=10を取り出し, front=(0+1)%5=1"},
      {"step": 6, "variables": {"front": 2, "size": 1}, "action": "dequeue(): val=buf[1]=20を取り出し, front=(1+1)%5=2"},
      {"step": 7, "variables": {"buf": "{10,20,30,40,0}", "rear": 4, "size": 2}, "action": "enqueue(40): buf[3]=40, rear=(3+1)%5=4"},
      {"step": 8, "variables": {"buf": "{10,20,30,40,50}", "rear": 0, "size": 3}, "action": "enqueue(50): buf[4]=50, rear=(4+1)%5=0 ← 折り返し"},
      {"step": 9, "variables": {"buf": "{60,20,30,40,50}", "rear": 1, "size": 4}, "action": "enqueue(60): buf[0]=60, rear=(0+1)%5=1"},
      {"step": 10, "variables": {"front": 2}, "action": "buf[front]=buf[2]=30を表示"}
    ],
    "traceAnalogy": "5席しかない回転寿司カウンターを想像してください。皿を3つ流し（10,20,30）、2つ取り（10,20を除去）、さらに3つ流します（40,50,60）。60はレーンの最初に戻って置かれます。今、先頭で待っている皿は30です。",
    "overallExplanation": "リングバッファによるキュー実装のトレース問題です。mod演算によりインデックスが循環し、rear=0の位置に60が上書きされます。frontは2回のdequeueでインデックス2に進んでおり、buf[2]=30が表示されます。リングバッファではfrontとrearが独立に循環する点がポイントです。"
  },
  {
    "questionId": "q-trace-043",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "ハッシュ探索",
    "level": 6,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: table ← {-1, -1, -1, -1, -1, -1, -1}  /* サイズ7、-1は空 */\n○整数型: tableSize ← 7\n○整数型の配列: keys ← {15, 22, 8, 29, 36}\n○整数型: i, h, count\n\n/* データの格納 */\ni を 0 から 4 まで 1 ずつ増やしながら繰り返す\n  h ← keys[i] mod tableSize\n  table[h] ≠ -1 の間繰り返す\n    h ← (h + 1) mod tableSize\n  を繰り返す\n  table[h] ← keys[i]\nを繰り返す\n\n/* 値29を探索 */\nh ← 29 mod tableSize\ncount ← 0\ntable[h] ≠ 29 の間繰り返す\n  h ← (h + 1) mod tableSize\n  count ← count + 1\nを繰り返す\n表示(count)",
    "choices": [
      {
        "text": "3",
        "isCorrect": true,
        "whyCorrect": "格納: 15→h=1, 22→h=1→衝突→h=2, 8→h=1→衝突→h=2→衝突→h=3, 29→h=1→衝突→h=2→衝突→h=3→衝突→h=4, 36→h=1→衝突→h=5。探索: 29 mod 7=1, table[1]=15≠29→ループ内でh=2,count=1。table[2]=22≠29→h=3,count=2。table[3]=8≠29→h=4,count=3。table[4]=29=29でループ終了。count=3が表示されます。",
        "analogy": "ロッカーに荷物を預けるとき、指定番号のロッカーが使用中なら隣のロッカーを順に試します。後で荷物を取りに来るとき、指定番号から順に確認して何回ずれたかを数えます。3回ずれて発見します。",
        "deepDive": "開番地法（オープンアドレス法・線形探査法）は、ハッシュ衝突時に次の空きスロットを順に探す方式です。探索時も同じ手順でたどります。衝突が多いとクラスタリングが発生し、性能が低下します。"
      },
      {
        "text": "1",
        "isCorrect": false,
        "whyWrong": "29のハッシュ値h=1の隣h=2だけを確認して見つかると早合点した場合の値です。実際にはh=1に15、h=2に22、h=3に8が格納されており、29はh=4に格納されています。3回のずれが必要です。",
        "analogy": "ロッカーの隣1つだけ見て「ない」と諦めるのではなく、見つかるまで順番に確認する必要があります。"
      },
      {
        "text": "4",
        "isCorrect": false,
        "whyWrong": "29が格納されたインデックス4を答えとした場合の値です。問われているのは格納位置ではなく、探索時にずれた回数（count）です。インデックス1から開始して3回ずれてインデックス4で発見します。",
        "analogy": "ロッカーの番号（4番）と、何回ずらしたか（3回）は別の情報です。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "衝突なしで直接見つかったと誤解した場合の値です。29 mod 7 = 1 ですが、table[1]には15が格納されているため衝突が発生し、3回ずれる必要があります。",
        "analogy": "自分のロッカー番号に行ったら別の人の荷物が入っていた場合、隣を探す必要があります。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"table": "{-1,-1,-1,-1,-1,-1,-1}"}, "action": "テーブル初期化（全て空）"},
      {"step": 2, "variables": {"table": "{-1,15,-1,-1,-1,-1,-1}"}, "action": "15 mod 7=1 → table[1]=15"},
      {"step": 3, "variables": {"table": "{-1,15,22,-1,-1,-1,-1}"}, "action": "22 mod 7=1 → 衝突 → h=2 → table[2]=22"},
      {"step": 4, "variables": {"table": "{-1,15,22,8,-1,-1,-1}"}, "action": "8 mod 7=1 → 衝突 → h=2衝突 → h=3 → table[3]=8"},
      {"step": 5, "variables": {"table": "{-1,15,22,8,29,-1,-1}"}, "action": "29 mod 7=1 → 衝突 → h=2衝突 → h=3衝突 → h=4 → table[4]=29"},
      {"step": 6, "variables": {"table": "{-1,15,22,8,29,36,-1}"}, "action": "36 mod 7=1 → 衝突 → h=2,3,4衝突 → h=5 → table[5]=36"},
      {"step": 7, "variables": {"h": 1, "count": 0}, "action": "探索開始: 29 mod 7=1。table[1]=15≠29"},
      {"step": 8, "variables": {"h": 2, "count": 1}, "action": "h=2, count=1。table[2]=22≠29"},
      {"step": 9, "variables": {"h": 3, "count": 2}, "action": "h=3, count=2。table[3]=8≠29"},
      {"step": 10, "variables": {"h": 4, "count": 3}, "action": "h=4, count=3。table[4]=29=29でループ終了。count=3を表示"}
    ],
    "traceAnalogy": "7つのロッカーに5人分の荷物を預けます。全員の指定番号が1番なので、順次隣のロッカーにずれていきます。29番の荷物を取りに来て1番ロッカーから順に確認すると、1番(15)→2番(22)→3番(8)→4番(29)と3回ずれて発見します。",
    "overallExplanation": "ハッシュ法の開番地法（線形探査法）によるデータ格納と探索のトレース問題です。全てのキーが mod 7 = 1 となるため連続して衝突が起こり、インデックス1から順に格納されます。29の探索ではh=1から開始し、table[1]=15, table[2]=22, table[3]=8と3回ずれてh=4で発見されます。countの最終値3が表示されます。"
  },
  {
    "questionId": "q-trace-044",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "マージ操作（2つの整列済み配列を統合）",
    "level": 6,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: A ← {3, 7, 11, 15}\n○整数型の配列: B ← {2, 5, 9, 13, 18}\n○整数型の配列: C ← {0, 0, 0, 0, 0, 0, 0, 0, 0}\n○整数型: i ← 0, j ← 0, k ← 0\n○整数型: lenA ← 4, lenB ← 5\n\ni < lenA かつ j < lenB の間繰り返す\n  もし A[i] ≦ B[j] ならば\n    C[k] ← A[i]\n    i ← i + 1\n  そうでなければ\n    C[k] ← B[j]\n    j ← j + 1\n  を実行する\n  k ← k + 1\nを繰り返す\ni < lenA の間繰り返す\n  C[k] ← A[i]\n  i ← i + 1\n  k ← k + 1\nを繰り返す\nj < lenB の間繰り返す\n  C[k] ← B[j]\n  j ← j + 1\n  k ← k + 1\nを繰り返す\n表示(C[4])",
    "choices": [
      {
        "text": "9",
        "isCorrect": true,
        "whyCorrect": "AとBを小さい順に統合すると C={2,3,5,7,9,11,13,15,18} となります。C[4]=9が表示されます。",
        "analogy": "2列の番号札を持った人を1列に合流させるとき、常に小さい番号の人を先に通します。合流後の列の5人目（インデックス4）は9番です。",
        "deepDive": "マージ操作はマージソートの核心部分で、2つの整列済み配列を1つの整列済み配列に統合します。計算量はO(n+m)で、両配列を1回ずつ走査するだけで完了する効率的なアルゴリズムです。"
      },
      {
        "text": "11",
        "isCorrect": false,
        "whyWrong": "A配列のインデックス2の値です。C配列ではなくA配列のインデックスで参照してしまった場合にこの値になります。マージ結果のC配列で確認する必要があります。",
        "analogy": "合流前の片方の列だけ見ているようなものです。合流後の列で5番目を数える必要があります。"
      },
      {
        "text": "7",
        "isCorrect": false,
        "whyWrong": "C[3]=7なので、インデックスを1つ間違えた場合の値です。C[4]は5番目の要素で、値は9です。配列のインデックスは0から始まることを確認しましょう。",
        "analogy": "行列の4人目と5人目を数え間違えたようなものです。先頭を0番目として数えます。"
      },
      {
        "text": "13",
        "isCorrect": false,
        "whyWrong": "B配列のインデックス3の値です。マージ結果のC配列のインデックス4ではなく、元のB配列のインデックス4を参照してしまった可能性があります。",
        "analogy": "合流元のB列の5番目ではなく、合流後の全体の列の5番目を確認する必要があります。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"i": 0, "j": 0, "k": 0}, "action": "初期状態。A={3,7,11,15}, B={2,5,9,13,18}"},
      {"step": 2, "variables": {"C[0]": 2, "j": 1, "k": 1}, "action": "A[0]=3 > B[0]=2 → C[0]=2, j=1"},
      {"step": 3, "variables": {"C[1]": 3, "i": 1, "k": 2}, "action": "A[0]=3 ≦ B[1]=5 → C[1]=3, i=1"},
      {"step": 4, "variables": {"C[2]": 5, "j": 2, "k": 3}, "action": "A[1]=7 > B[1]=5 → C[2]=5, j=2"},
      {"step": 5, "variables": {"C[3]": 7, "i": 2, "k": 4}, "action": "A[1]=7 ≦ B[2]=9 → C[3]=7, i=2"},
      {"step": 6, "variables": {"C[4]": 9, "j": 3, "k": 5}, "action": "A[2]=11 > B[2]=9 → C[4]=9, j=3"},
      {"step": 7, "variables": {"C[5]": 11, "i": 3, "k": 6}, "action": "A[2]=11 ≦ B[3]=13 → C[5]=11, i=3"},
      {"step": 8, "variables": {"C[6]": 13, "j": 4, "k": 7}, "action": "A[3]=15 > B[3]=13 → C[6]=13, j=4"},
      {"step": 9, "variables": {"C[7]": 15, "i": 4, "k": 8}, "action": "A[3]=15 ≦ B[4]=18 → C[7]=15, i=4。i=lenAでメインループ終了"},
      {"step": 10, "variables": {"C[8]": 18, "j": 5, "k": 9}, "action": "Bの残り: C[8]=18。C={2,3,5,7,9,11,13,15,18}。C[4]=9を表示"}
    ],
    "traceAnalogy": "2つのレジに並んだお客さんを1つのレジに合流させます。常に番号の小さい方のお客さんを先に通します。合流後の列は{2,3,5,7,9,11,13,15,18}で、先頭から5番目（インデックス4）のお客さんの番号は9です。",
    "overallExplanation": "2つの整列済み配列をマージする操作のトレース問題です。iとjの2つのポインタで両配列の先頭から比較し、小さい方をC配列に入れていきます。片方の配列を走査し終わったら、もう片方の残りをそのままコピーします。結果配列C={2,3,5,7,9,11,13,15,18}のインデックス4の値9が表示されます。"
  },
  {
    "questionId": "q-trace-045",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "深さ優先探索（スタック使用）",
    "level": 6,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。ただし、隣接リストadj[v]は頂点vに隣接する頂点の配列（昇順）である。",
    "pseudoCode": "○整数型の配列の配列: adj ← {{1,2}, {0,3,4}, {0,5}, {1}, {1,5}, {2,4}}\n○論理型の配列: visited ← {偽, 偽, 偽, 偽, 偽, 偽}\n○整数型の配列: stack ← {}  /* 空のスタック */\n○整数型: v, count, w\n○整数型: i\n\nstackに0を追加する\ncount ← 0\nstackが空でない間繰り返す\n  v ← stackから末尾の要素を取り出す\n  もし visited[v] = 偽 ならば\n    visited[v] ← 真\n    count ← count + 1\n    i を (adj[v]の要素数 - 1) から 0 まで 1 ずつ減らしながら繰り返す\n      w ← adj[v][i]\n      もし visited[w] = 偽 ならば\n        stackにwを追加する\n      を実行する\n    を繰り返す\n  を実行する\nを繰り返す\n表示(count)",
    "choices": [
      {
        "text": "6",
        "isCorrect": true,
        "whyCorrect": "深さ優先探索で全頂点（0〜5）を訪問します。訪問順は0→1→3→4→5→2で、合計6頂点を訪問するためcount=6が表示されます。",
        "analogy": "迷路を探検するとき、分かれ道では常に一方の道を奥まで進み、行き止まりになったら戻って別の道を試します。全ての部屋（6部屋）を訪問した回数が答えです。",
        "deepDive": "深さ優先探索（DFS）はスタックを使って実装できます。隣接頂点を逆順にスタックに積むことで、昇順で取り出されます。全頂点を1回ずつ訪問するため、連結グラフの頂点数がcountの最終値になります。"
      },
      {
        "text": "5",
        "isCorrect": false,
        "whyWrong": "頂点を0から5まで数えると6個ですが、最後の1頂点の訪問を見落とした場合にこの値になります。連結グラフでは全ての頂点が訪問されます。",
        "analogy": "6部屋ある建物で5部屋しか確認せず「もう全部見た」と思い込んでしまったようなものです。"
      },
      {
        "text": "8",
        "isCorrect": false,
        "whyWrong": "同じ頂点を複数回カウントした場合の値です。visited配列により、既に訪問済みの頂点ではcountは加算されません。各頂点は最大1回しかカウントされません。",
        "analogy": "同じ部屋を2回訪問しても、訪問済みのチェックマークがあるので1回としか数えないのと同じです。"
      },
      {
        "text": "4",
        "isCorrect": false,
        "whyWrong": "スタックに既に入っている頂点を追加しないと誤解し、一部の頂点が未訪問のままになった場合の値です。実際にはスタックへの追加は重複可能で、取り出し時にvisitedで判定します。",
        "analogy": "迷路で一部の通路を通ったと勘違いして、実際には未探索の部屋が残っているのに探索を終えてしまった状態です。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"stack": "[0]", "count": 0}, "action": "頂点0をスタックに追加"},
      {"step": 2, "variables": {"v": 0, "visited[0]": "真", "count": 1, "stack": "[2,1]"}, "action": "0を取出し訪問。adj[0]={1,2}を逆順(2,1)でスタックに追加"},
      {"step": 3, "variables": {"v": 1, "visited[1]": "真", "count": 2, "stack": "[2,4,3]"}, "action": "1を取出し訪問。adj[1]={0,3,4}→0は訪問済み。逆順(4,3)を追加"},
      {"step": 4, "variables": {"v": 3, "visited[3]": "真", "count": 3, "stack": "[2,4]"}, "action": "3を取出し訪問。adj[3]={1}→1は訪問済み。追加なし"},
      {"step": 5, "variables": {"v": 4, "visited[4]": "真", "count": 4, "stack": "[2,5]"}, "action": "4を取出し訪問。adj[4]={1,5}→1は訪問済み。5を追加"},
      {"step": 6, "variables": {"v": 5, "visited[5]": "真", "count": 5, "stack": "[2,2]"}, "action": "5を取出し訪問。adj[5]={2,4}→4は訪問済み。2を追加"},
      {"step": 7, "variables": {"v": 2, "visited[2]": "真", "count": 6, "stack": "[2]"}, "action": "2を取出し訪問。adj[2]={0,5}→両方訪問済み。追加なし"},
      {"step": 8, "variables": {"v": 2, "stack": "[]"}, "action": "2を取出すが訪問済みなのでスキップ。スタック空でループ終了"},
      {"step": 9, "variables": {"count": 6}, "action": "count=6を表示"}
    ],
    "traceAnalogy": "6つの島をフェリーで巡る旅行です。予定表（スタック）に行き先を書き込み、一番上の島から順に訪問します。既に行った島は飛ばし、新しい島に着いたら隣の未訪問の島を予定表に追加します。全ての島を回り終えると訪問数は6です。",
    "overallExplanation": "スタックを使った深さ優先探索（DFS）のトレース問題です。頂点0から探索を開始し、隣接頂点を逆順にスタックに積むことで昇順に処理されます。visited配列で重複訪問を防ぎ、連結グラフの全6頂点を1回ずつ訪問します。countの最終値6が表示されます。"
  },
  {
    "questionId": "q-trace-046",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "再帰的マージソート",
    "level": 7,
    "question": "次の擬似言語プログラムにおいて、mergeSort(A, 0, 5) を実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: A ← {38, 27, 43, 3, 9, 82}\n○整数型: callCount ← 0\n\n○手続き mergeSort(A[], left, right)\n  もし left < right ならば\n    ○整数型: mid ← (left + right) ÷ 2\n    mergeSort(A, left, mid)\n    mergeSort(A, mid + 1, right)\n    callCount ← callCount + 1\n    /* merge処理: A[left..mid] と A[mid+1..right] を統合 */\n    ○整数型の配列: temp ← {}\n    ○整数型: i ← left, j ← mid + 1\n    i ≦ mid かつ j ≦ right の間繰り返す\n      もし A[i] ≦ A[j] ならば\n        tempにA[i]を追加する\n        i ← i + 1\n      そうでなければ\n        tempにA[j]を追加する\n        j ← j + 1\n      を実行する\n    を繰り返す\n    i ≦ mid の間繰り返す\n      tempにA[i]を追加する\n      i ← i + 1\n    を繰り返す\n    j ≦ right の間繰り返す\n      tempにA[j]を追加する\n      j ← j + 1\n    を繰り返す\n    i を left から right まで 1 ずつ増やしながら繰り返す\n      A[i] ← temp[i - left]\n    を繰り返す\n  を実行する\n\nmergeSort(A, 0, 5)\n表示(callCount)",
    "choices": [
      {
        "text": "5",
        "isCorrect": true,
        "whyCorrect": "マージソートの再帰で、left<rightを満たす呼び出しでのみcallCountが加算されます。分割は(0,5)→(0,2),(3,5)→(0,1),(2,2),(3,4),(5,5)→(0,0),(1,1),(3,3),(4,4)。left<rightの場合のマージ回数は、(0,1)で1回、(0,2)で1回、(3,4)で1回、(3,5)で1回、(0,5)で1回の計5回です。",
        "analogy": "トランプの山を半分ずつに分けて、1枚ずつになったら順番に合わせていく作業です。合わせる作業（マージ）を行った回数を数えると5回です。",
        "deepDive": "要素数nのマージソートでは、マージ操作の回数はn-1回です（各マージで少なくとも1つの部分問題が解決されるため）。6要素では5回のマージが行われます。再帰の木構造を理解することが重要です。"
      },
      {
        "text": "6",
        "isCorrect": false,
        "whyWrong": "要素数と同じ6を答えにしてしまった場合の値です。マージ操作は要素数-1回行われます。left=rightの場合（要素が1つ）はmergeが実行されないため、callCountは加算されません。",
        "analogy": "6枚のトランプを分けてから合わせる作業では、合わせる回数は5回です。6回ではありません。"
      },
      {
        "text": "11",
        "isCorrect": false,
        "whyWrong": "再帰呼び出しの総回数（mergeSort関数が呼ばれた回数）を数えてしまった場合の値です。callCountはマージ処理が実行された回数のみカウントしており、left≧rightで早期returnされた呼び出しは含みません。",
        "analogy": "分ける作業と合わせる作業の両方を数えてしまい、実際には「合わせる作業」だけを数えるべきでした。"
      },
      {
        "text": "3",
        "isCorrect": false,
        "whyWrong": "再帰の深さ（レベル数）を答えにしてしまった場合の値です。再帰は3段階の深さですが、各段階で複数のマージが行われるため、マージの総回数は5回です。",
        "analogy": "ビルの階数（3階建て）と、全フロアの部屋数（5部屋）を混同しているようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"呼び出し": "mergeSort(A,0,5)", "mid": 2}, "action": "mid=2。左半分(0,2)と右半分(3,5)に分割"},
      {"step": 2, "variables": {"呼び出し": "mergeSort(A,0,2)", "mid": 1}, "action": "mid=1。左半分(0,1)と右半分(2,2)に分割"},
      {"step": 3, "variables": {"呼び出し": "mergeSort(A,0,1)", "mid": 0}, "action": "mid=0。左(0,0)と右(1,1)に分割→両方left=rightで即戻り"},
      {"step": 4, "variables": {"callCount": 1, "A": "{27,38,43,3,9,82}"}, "action": "merge(0,1): {38,27}→{27,38}。callCount=1"},
      {"step": 5, "variables": {"callCount": 2, "A": "{27,38,43,3,9,82}"}, "action": "merge(0,2): {27,38}と{43}→{27,38,43}。callCount=2"},
      {"step": 6, "variables": {"呼び出し": "mergeSort(A,3,5)", "mid": 4}, "action": "mid=4。左半分(3,4)と右半分(5,5)に分割"},
      {"step": 7, "variables": {"callCount": 3, "A": "{27,38,43,3,9,82}"}, "action": "merge(3,4): {3,9}（既に整列）。callCount=3"},
      {"step": 8, "variables": {"callCount": 4, "A": "{27,38,43,3,9,82}"}, "action": "merge(3,5): {3,9}と{82}→{3,9,82}。callCount=4"},
      {"step": 9, "variables": {"callCount": 5, "A": "{3,9,27,38,43,82}"}, "action": "merge(0,5): {27,38,43}と{3,9,82}→{3,9,27,38,43,82}。callCount=5"},
      {"step": 10, "variables": {"callCount": 5}, "action": "callCount=5を表示"}
    ],
    "traceAnalogy": "6人の子供を身長順に並べるために、まず3人ずつのグループに分け、さらに2人と1人に分けます。最小単位になったら順番に整列しながら合流させます。合流作業は全部で5回行われます：2人グループ内で2回、3人グループで2回、最後の全体合流で1回です。",
    "overallExplanation": "再帰的マージソートのマージ回数をトレースする問題です。6要素の配列を再帰的に分割し、底からマージしていきます。要素が1つの場合はマージ不要なので、実際にマージが行われるのはleft<rightの場合のみです。再帰木の内部ノード数が5つなので、callCount=5が表示されます。"
  },
  {
    "questionId": "q-trace-047",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "簡易ダイクストラ法",
    "level": 7,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。4つの頂点(0〜3)を持つグラフで、頂点0から頂点3への最短距離を求める。",
    "pseudoCode": "○整数型の二次元配列: cost ← {{0,4,2,999}, {4,0,1,5}, {2,1,0,8}, {999,5,8,0}}\n○整数型の配列: dist ← {0, 999, 999, 999}\n○論理型の配列: fixed ← {偽, 偽, 偽, 偽}\n○整数型: n ← 4\n○整数型: i, u, v, minDist\n\ni を 0 から n-1 まで 1 ずつ増やしながら繰り返す\n  /* 未確定頂点の中で最小距離の頂点を選ぶ */\n  minDist ← 999\n  u ← -1\n  v を 0 から n-1 まで 1 ずつ増やしながら繰り返す\n    もし fixed[v] = 偽 かつ dist[v] < minDist ならば\n      minDist ← dist[v]\n      u ← v\n    を実行する\n  を繰り返す\n  もし u = -1 ならば\n    繰り返しを抜ける\n  を実行する\n  fixed[u] ← 真\n  v を 0 から n-1 まで 1 ずつ増やしながら繰り返す\n    もし fixed[v] = 偽 かつ dist[u] + cost[u][v] < dist[v] ならば\n      dist[v] ← dist[u] + cost[u][v]\n    を実行する\n  を繰り返す\nを繰り返す\n表示(dist[3])",
    "choices": [
      {
        "text": "8",
        "isCorrect": true,
        "whyCorrect": "頂点0から出発。1回目: u=0確定, dist更新→dist={0,4,2,999}。2回目: u=2確定(dist=2), dist更新→dist={0,3,2,10}。3回目: u=1確定(dist=3), dist更新→dist={0,3,2,8}。4回目: u=3確定(dist=8)。最短距離は0→2→1→3の経路で8です。",
        "analogy": "4つの町を結ぶ道路で、町0から町3への最安ルートを探します。直行は999円、町2経由で町1に行き（2+1=3円）、町1から町3へ（3+5=8円）が最安ルートです。",
        "deepDive": "ダイクストラ法は非負重みグラフの単一始点最短経路問題を解くアルゴリズムです。毎回最小距離の未確定頂点を選び、その頂点を経由して他の頂点への距離を更新します。計算量はO(V^2)ですが、優先度キューを使えばO((V+E)log V)に改善できます。"
      },
      {
        "text": "10",
        "isCorrect": false,
        "whyWrong": "頂点0→2→3の直接経路（2+8=10）の値です。しかし頂点0→2→1→3（2+1+5=8）の方が短いため、dist[3]は3回目の更新で10→8に更新されます。全ての頂点を経由する可能性を検討する必要があります。",
        "analogy": "最初に見つけた道が必ずしも最安ルートではなく、遠回りに見える経路がかえって安いことがあります。"
      },
      {
        "text": "9",
        "isCorrect": false,
        "whyWrong": "頂点0→1→3（4+5=9）の経路の値です。頂点2を経由すると頂点1への距離が3（4ではなく2+1=3）となり、そこから頂点3への距離は3+5=8となります。dist[1]の更新を見落としています。",
        "analogy": "直行便が一番安いとは限らず、乗り換え便の方が安くなることがあります。頂点2を経由することで頂点1への距離が短縮されます。"
      },
      {
        "text": "5",
        "isCorrect": false,
        "whyWrong": "cost[1][3]=5（頂点1から頂点3への直接コスト）をそのまま答えにしてしまった場合の値です。ダイクストラ法では頂点0からの累積距離で計算する必要があります。",
        "analogy": "途中の区間運賃だけを見て「合計運賃」と勘違いしたようなものです。出発地からの合計を求める必要があります。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"dist": "{0,999,999,999}", "fixed": "{偽,偽,偽,偽}"}, "action": "初期状態。頂点0の距離は0"},
      {"step": 2, "variables": {"u": 0, "fixed[0]": "真"}, "action": "i=0: 最小距離の未確定頂点 u=0 を選択し確定"},
      {"step": 3, "variables": {"dist": "{0,4,2,999}"}, "action": "u=0から更新: dist[1]=0+4=4, dist[2]=0+2=2, dist[3]=0+999=999(更新なし)"},
      {"step": 4, "variables": {"u": 2, "fixed[2]": "真"}, "action": "i=1: 最小距離の未確定頂点 u=2(dist=2) を選択し確定"},
      {"step": 5, "variables": {"dist": "{0,3,2,10}"}, "action": "u=2から更新: dist[1]=min(4, 2+1)=3, dist[3]=min(999, 2+8)=10"},
      {"step": 6, "variables": {"u": 1, "fixed[1]": "真"}, "action": "i=2: 最小距離の未確定頂点 u=1(dist=3) を選択し確定"},
      {"step": 7, "variables": {"dist": "{0,3,2,8}"}, "action": "u=1から更新: dist[3]=min(10, 3+5)=8"},
      {"step": 8, "variables": {"u": 3, "fixed[3]": "真"}, "action": "i=3: u=3(dist=8) を確定。全頂点確定"},
      {"step": 9, "variables": {"dist[3]": 8}, "action": "dist[3]=8を表示。最短経路は0→2→1→3"}
    ],
    "traceAnalogy": "4つの駅をつなぐ鉄道路線で、駅0から駅3への最安運賃を求めます。最初に駅0から直接行ける駅の運賃を調べ、一番安い駅2(2円)を確定します。駅2から他の駅への運賃を再計算すると、駅1が3円(2+1)に値下がりします。駅1を確定して駅3への運賃を再計算すると8円(3+5)となり、これが最安です。",
    "overallExplanation": "ダイクストラ法による最短経路探索のトレース問題です。頂点0→2（距離2）→1（距離3）→3（距離8）の経路が最短となります。ポイントは、頂点2を経由することで頂点1への距離が4から3に短縮され、結果として頂点3への距離も9から8に改善される点です。"
  },
  {
    "questionId": "q-trace-048",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "二分探索木への挿入",
    "level": 7,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。配列で二分探索木を表現し、left[i]とright[i]はノードiの左右の子のインデックスを示す（-1は子がないことを意味する）。",
    "pseudoCode": "○整数型の配列: key ← {20, 10, 30, 5, 15, 0, 0, 0}\n○整数型の配列: left ← {1, 3, -1, -1, -1, -1, -1, -1}\n○整数型の配列: right ← {2, 4, -1, -1, -1, -1, -1, -1}\n○整数型: root ← 0, nextFree ← 5\n○整数型の配列: insertKeys ← {25, 12, 35}\n○整数型: i, curr, newVal, depth\n\ni を 0 から 2 まで 1 ずつ増やしながら繰り返す\n  newVal ← insertKeys[i]\n  curr ← root\n  depth ← 0\n  真の間繰り返す\n    もし newVal < key[curr] ならば\n      もし left[curr] = -1 ならば\n        left[curr] ← nextFree\n        key[nextFree] ← newVal\n        left[nextFree] ← -1\n        right[nextFree] ← -1\n        nextFree ← nextFree + 1\n        繰り返しを抜ける\n      そうでなければ\n        curr ← left[curr]\n      を実行する\n    そうでなければ\n      もし right[curr] = -1 ならば\n        right[curr] ← nextFree\n        key[nextFree] ← newVal\n        left[nextFree] ← -1\n        right[nextFree] ← -1\n        nextFree ← nextFree + 1\n        繰り返しを抜ける\n      そうでなければ\n        curr ← right[curr]\n      を実行する\n    を実行する\n    depth ← depth + 1\n  を繰り返す\nを繰り返す\n\n/* 値25のノードの深さを求める */\ncurr ← root\ndepth ← 0\ncurr ≠ -1 の間繰り返す\n  もし key[curr] = 25 ならば\n    繰り返しを抜ける\n  そうでなくもし 25 < key[curr] ならば\n    curr ← left[curr]\n  そうでなければ\n    curr ← right[curr]\n  を実行する\n  depth ← depth + 1\nを繰り返す\n表示(depth)",
    "choices": [
      {
        "text": "2",
        "isCorrect": true,
        "whyCorrect": "初期の木は根20、左10、右30、左左5、左右15。25を挿入: 20→右→30→左に挿入（30の左子）。深さ2。12を挿入: 20→左→10→右→15→左に挿入。35を挿入: 20→右→30→右に挿入。25の探索: root(20)→right(30)→left(25)で深さ2。",
        "analogy": "家系図で「25さん」を探すとき、根の「20さん」から右の子「30さん」へ進み、その左の子「25さん」にたどり着きます。2世代下なので深さは2です。",
        "deepDive": "二分探索木では、挿入・探索ともに根から葉に向かって進みます。各ノードの左部分木には小さい値が、右部分木には大きい値が格納されます。平衡木の場合、探索の計算量はO(log n)です。"
      },
      {
        "text": "3",
        "isCorrect": false,
        "whyWrong": "25の挿入過程での比較回数と深さを混同した場合の値です。25は根(20)→右子(30)→左子として挿入されるため、深さは2です。挿入時にルートから2回下に移動するので深さは2となります。",
        "analogy": "家系図の世代数を数えるとき、根を0世代目として数えるか1世代目として数えるかで混乱しているようなものです。根は深さ0です。"
      },
      {
        "text": "1",
        "isCorrect": false,
        "whyWrong": "25が根(20)の直接の子だと誤解した場合の値です。根の右の子は30で既に存在するため、25は30の左の子として挿入されます。深さは2です。",
        "analogy": "家系図で25さんは20さんの直接の子ではなく、30さんの子として配置されます。"
      },
      {
        "text": "4",
        "isCorrect": false,
        "whyWrong": "挿入処理中のdepth変数の最終値（最後に挿入した35のdepth）と混同した可能性があります。後半の探索処理は25を対象としており、その深さは2です。",
        "analogy": "最後に作業した結果と、特定の人物を探す結果は別のものです。問われているのは25の位置です。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"key": "{20,10,30,5,15,-,-,-}", "left": "{1,3,-1,-1,-1,-,-,-}", "right": "{2,4,-1,-1,-1,-,-,-}"}, "action": "初期状態。二分探索木: 20(根), 左10(左5,右15), 右30"},
      {"step": 2, "variables": {"newVal": 25, "curr": "0→2"}, "action": "25挿入: 25>20→右(30)。25<30かつleft[2]=-1"},
      {"step": 3, "variables": {"left[2]": 5, "key[5]": 25, "nextFree": 6}, "action": "30の左子として25を挿入（インデックス5）"},
      {"step": 4, "variables": {"newVal": 12, "curr": "0→1→4"}, "action": "12挿入: 12<20→左(10)。12>10→右(15)。12<15かつleft[4]=-1"},
      {"step": 5, "variables": {"left[4]": 6, "key[6]": 12, "nextFree": 7}, "action": "15の左子として12を挿入（インデックス6）"},
      {"step": 6, "variables": {"newVal": 35, "curr": "0→2"}, "action": "35挿入: 35>20→右(30)。35>30かつright[2]=-1"},
      {"step": 7, "variables": {"right[2]": 7, "key[7]": 35, "nextFree": 8}, "action": "30の右子として35を挿入（インデックス7）"},
      {"step": 8, "variables": {"curr": 0, "depth": 0}, "action": "25の探索開始: key[0]=20≠25, 25>20→右へ"},
      {"step": 9, "variables": {"curr": 2, "depth": 1}, "action": "key[2]=30≠25, 25<30→左へ"},
      {"step": 10, "variables": {"curr": 5, "depth": 2}, "action": "key[5]=25=25で発見。depth=2を表示"}
    ],
    "traceAnalogy": "図書館の分類棚に本を入れる作業です。棚は「この番号より小さければ左、大きければ右」のルールで分岐します。本「25」は、根の棚「20」→右の棚「30」→左の棚（空き）に配置されます。この本を探すときは同じ道をたどり、2回分岐するので深さ2です。",
    "overallExplanation": "配列で表現した二分探索木に3つの値を挿入し、その後特定の値を探索して深さを求める問題です。25は根(20)の右子(30)の左子として挿入され、深さ2の位置にあります。二分探索木の挿入・探索では、常に「小さければ左、大きければ右」のルールに従って木を下っていきます。"
  },
  {
    "questionId": "q-trace-049",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "幅優先探索（キュー使用）",
    "level": 7,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。ただし、隣接リストadj[v]は頂点vに隣接する頂点の配列（昇順）である。",
    "pseudoCode": "○整数型の配列の配列: adj ← {{1,3}, {0,2,4}, {1,5}, {0,4}, {1,3,5}, {2,4}}\n○整数型の配列: dist ← {-1, -1, -1, -1, -1, -1}\n○整数型の配列: queue ← {}  /* 空のキュー */\n○整数型: v, w\n○整数型: i\n\ndist[0] ← 0\nqueueに0を追加する\nqueueが空でない間繰り返す\n  v ← queueの先頭要素を取り出す\n  i を 0 から (adj[v]の要素数 - 1) まで 1 ずつ増やしながら繰り返す\n    w ← adj[v][i]\n    もし dist[w] = -1 ならば\n      dist[w] ← dist[v] + 1\n      queueにwを追加する\n    を実行する\n  を繰り返す\nを繰り返す\n表示(dist[5])",
    "choices": [
      {
        "text": "3",
        "isCorrect": true,
        "whyCorrect": "BFSで頂点0から各頂点への最短距離を求めます。dist[0]=0。0の隣接{1,3}: dist[1]=1, dist[3]=1。1の隣接{0,2,4}: dist[2]=2, dist[4]=2。3の隣接{0,4}: 全て訪問済み。2の隣接{1,5}: dist[5]=3。頂点5への最短距離は3です。",
        "analogy": "友達の友達ネットワークで、自分（0）から5番の人に「伝言ゲーム」をするとき、最短で3回のリレーが必要です。0→1→2→5という経路です。",
        "deepDive": "幅優先探索（BFS）は、始点からの最短距離（辺の本数）を求めるのに最適なアルゴリズムです。キューにより「近い頂点から順に」処理するため、各頂点に最初に到達した時の距離が最短距離になります。計算量はO(V+E)です。"
      },
      {
        "text": "2",
        "isCorrect": false,
        "whyWrong": "頂点4と頂点5が隣接しているため、頂点0→3→4→5（距離3）より短い経路があると誤解した場合です。頂点0から頂点5への最短経路はどの経路でも3辺必要です。",
        "analogy": "地図上で近くに見えても、道路がつながっていなければ遠回りが必要です。頂点0と頂点5は直接つながっておらず、最低3回の移動が必要です。"
      },
      {
        "text": "4",
        "isCorrect": false,
        "whyWrong": "BFSではなくDFSのように深く探索した場合の経路長です。BFSはキューを使うため、常に近い頂点から順に処理し、最短距離が保証されます。",
        "analogy": "一本道を奥まで進むのではなく、同じ距離の場所を全て確認してから次の距離に進むのがBFSの特徴です。"
      },
      {
        "text": "1",
        "isCorrect": false,
        "whyWrong": "頂点0と頂点5が直接隣接していると誤解した場合の値です。adj[0]={1,3}なので、頂点0から直接行けるのは頂点1と頂点3のみです。",
        "analogy": "隣の家にしか直接行けないのに、3軒先の家に一歩で行けると思い込んでしまったようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"dist": "{0,-1,-1,-1,-1,-1}", "queue": "[0]"}, "action": "開始。dist[0]=0, キューに0を追加"},
      {"step": 2, "variables": {"v": 0, "dist": "{0,1,-1,1,-1,-1}", "queue": "[1,3]"}, "action": "v=0を処理。隣接{1,3}: dist[1]=1, dist[3]=1"},
      {"step": 3, "variables": {"v": 1, "dist": "{0,1,2,1,2,-1}", "queue": "[3,2,4]"}, "action": "v=1を処理。隣接{0,2,4}: 0は訪問済み。dist[2]=2, dist[4]=2"},
      {"step": 4, "variables": {"v": 3, "queue": "[2,4]"}, "action": "v=3を処理。隣接{0,4}: 両方訪問済み。追加なし"},
      {"step": 5, "variables": {"v": 2, "dist": "{0,1,2,1,2,3}", "queue": "[4,5]"}, "action": "v=2を処理。隣接{1,5}: 1は訪問済み。dist[5]=3"},
      {"step": 6, "variables": {"v": 4, "queue": "[5]"}, "action": "v=4を処理。隣接{1,3,5}: 全て訪問済み。追加なし"},
      {"step": 7, "variables": {"v": 5, "queue": "[]"}, "action": "v=5を処理。隣接{2,4}: 全て訪問済み。キュー空で終了"},
      {"step": 8, "variables": {"dist[5]": 3}, "action": "dist[5]=3を表示"}
    ],
    "traceAnalogy": "池に石を投げると波紋が同心円状に広がるように、BFSは始点から同じ距離の頂点を同時に処理します。1波目で頂点1,3（距離1）、2波目で頂点2,4（距離2）、3波目で頂点5（距離3）に到達します。",
    "overallExplanation": "幅優先探索（BFS）による最短距離計算のトレース問題です。キューを使って頂点0から近い順に探索し、各頂点への最短距離を記録します。頂点5には0→1→2→5または0→3→4→5の経路で到達でき、いずれも距離3です。dist[5]=3が表示されます。"
  },
  {
    "questionId": "q-trace-050",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "簡易ナップサック問題（動的計画法）",
    "level": 7,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。容量7のナップサックに重さと価値がある品物を詰める0-1ナップサック問題である。",
    "pseudoCode": "○整数型の配列: weight ← {2, 3, 4, 5}\n○整数型の配列: value ← {3, 4, 5, 7}\n○整数型: n ← 4, capacity ← 7\n○整数型の二次元配列: dp  /* (n+1) × (capacity+1) のゼロ初期化 */\n○整数型: i, w\n\ni を 1 から n まで 1 ずつ増やしながら繰り返す\n  w を 0 から capacity まで 1 ずつ増やしながら繰り返す\n    もし weight[i-1] > w ならば\n      dp[i][w] ← dp[i-1][w]\n    そうでなければ\n      もし dp[i-1][w] > dp[i-1][w - weight[i-1]] + value[i-1] ならば\n        dp[i][w] ← dp[i-1][w]\n      そうでなければ\n        dp[i][w] ← dp[i-1][w - weight[i-1]] + value[i-1]\n      を実行する\n    を実行する\n  を繰り返す\nを繰り返す\n表示(dp[n][capacity])",
    "choices": [
      {
        "text": "10",
        "isCorrect": true,
        "whyCorrect": "品物1(重2,値3)と品物3(重5,値7)を選ぶと重さ7,価値10が最大です。dp表を埋めていくと、dp[4][7]=10となります。品物2と3(重7,値9)や品物1と2(重5,値7)より大きな価値が得られます。",
        "analogy": "旅行カバンに荷物を詰めるとき、重さ制限内で満足度が最大になる組み合わせを探します。軽くて価値の高い組み合わせ（重さ2+5=7、価値3+7=10）が最適です。",
        "deepDive": "0-1ナップサック問題は動的計画法の代表的な問題です。dp[i][w]は「i番目までの品物から選んで、容量wに収まる最大価値」を表します。各品物について「入れる」「入れない」の2択を最適に選ぶことで、全体の最大価値が求まります。"
      },
      {
        "text": "9",
        "isCorrect": false,
        "whyWrong": "品物2(重3,値4)と品物3(重4,値5)を選んだ場合の価値（4+5=9）です。しかし品物0(重2,値3)と品物3(重5,値7)の組み合わせ（価値10）の方が大きいため、最適解ではありません。",
        "analogy": "カバンに入る組み合わせは複数ありますが、一番満足度が高い組み合わせを見つけるのが動的計画法の役割です。"
      },
      {
        "text": "12",
        "isCorrect": false,
        "whyWrong": "品物0,1,2(重2+3+4=9)の価値合計（3+4+5=12）ですが、合計重量9はcapacity=7を超えています。ナップサックの容量制限を守る必要があります。",
        "analogy": "カバンの重さ制限を無視して何でも詰め込んでしまったようなものです。制限内で最大化する必要があります。"
      },
      {
        "text": "7",
        "isCorrect": false,
        "whyWrong": "品物3(重5,値7)だけを選んだ場合、または品物0+1(重5,値7)の場合の価値です。容量に余裕があるため、さらに品物を追加できます。品物0+3(重7,値10)の方が最適です。",
        "analogy": "まだカバンに空きがあるのに、1つの荷物だけで満足してしまったようなものです。空いたスペースに追加の荷物を入れられます。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"dp": "全て0"}, "action": "dp表を(5×8)のゼロで初期化"},
      {"step": 2, "variables": {"dp[1][0..7]": "{0,0,3,3,3,3,3,3}"}, "action": "i=1(品物0: 重2,値3): w≧2でdp[1][w]=3"},
      {"step": 3, "variables": {"dp[2][0..7]": "{0,0,3,4,4,7,7,7}"}, "action": "i=2(品物1: 重3,値4): w=3で4, w=5で3+4=7"},
      {"step": 4, "variables": {"dp[3][0..7]": "{0,0,3,4,5,7,8,9}"}, "action": "i=3(品物2: 重4,値5): w=4で5, w=6で3+5=8, w=7で4+5=9"},
      {"step": 5, "variables": {"dp[4][0..7]": "{0,0,3,4,5,7,8,10}"}, "action": "i=4(品物3: 重5,値7): w=5でmax(7,7)=7, w=7でmax(9, dp[3][2]+7)=max(9,3+7)=10"},
      {"step": 6, "variables": {"dp[4][7]": 10}, "action": "dp[4][7]=10を表示。最適解: 品物0(重2,値3)+品物3(重5,値7)=価値10"}
    ],
    "traceAnalogy": "旅行の持ち物を選ぶとき、品物を1つずつ検討しながら「この品物を入れた場合」と「入れない場合」の満足度を比較表に記録していきます。最終的に表の右下の値が、重さ制限内での最大満足度です。",
    "overallExplanation": "0-1ナップサック問題を動的計画法で解くトレース問題です。dp[i][w]は「品物iまでを考慮し、容量wでの最大価値」を表します。各品物について「入れない（dp[i-1][w]）」と「入れる（dp[i-1][w-weight]+value）」の大きい方を選びます。最終的にdp[4][7]=10が最適解で、品物0(重2,値3)と品物3(重5,値7)の組み合わせが選ばれます。"
  },
  {
    "questionId": "q-trace-051",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "ヒープへの要素追加",
    "level": 7,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。最小ヒープ（親の値が子より小さい）に要素を追加する。",
    "pseudoCode": "○整数型の配列: heap ← {3, 10, 5, 15, 20, 8, 12}\n○整数型: heapSize ← 7\n○整数型: newVal ← 4\n○整数型: i, parent, temp, swapCount\n\n/* 新要素を末尾に追加 */\nheap[heapSize] ← newVal\ni ← heapSize\nheapSize ← heapSize + 1\nswapCount ← 0\n\n/* 上方向に修正（アップヒープ） */\ni > 0 の間繰り返す\n  parent ← (i - 1) ÷ 2\n  もし heap[parent] > heap[i] ならば\n    temp ← heap[parent]\n    heap[parent] ← heap[i]\n    heap[i] ← temp\n    swapCount ← swapCount + 1\n    i ← parent\n  そうでなければ\n    繰り返しを抜ける\n  を実行する\nを繰り返す\n表示(swapCount)",
    "choices": [
      {
        "text": "2",
        "isCorrect": true,
        "whyCorrect": "新要素4をインデックス7に追加。parent=(7-1)/2=3, heap[3]=15>4→交換(swapCount=1)。i=3, parent=(3-1)/2=1, heap[1]=10>4→交換(swapCount=2)。i=1, parent=(1-1)/2=0, heap[0]=3<4→停止。swapCount=2を表示。",
        "analogy": "トーナメント表で新人選手が参加し、上の選手より強ければ順位を入れ替えます。4番は15番と10番に勝ちますが、3番には負けるため、2回の入れ替えで正しい位置に落ち着きます。",
        "deepDive": "ヒープへの要素追加はO(log n)で行えます。末尾に追加して親と比較しながら上に移動する操作（アップヒープ/バブルアップ）を行います。最小ヒープでは親≦子の関係が常に成り立つよう維持します。"
      },
      {
        "text": "1",
        "isCorrect": false,
        "whyWrong": "1回目の交換（heap[3]=15と4の交換）で停止したと誤解した場合の値です。交換後もi=3の親(heap[1]=10)と比較する必要があり、10>4なのでもう1回交換が行われます。",
        "analogy": "トーナメントの1回戦で勝ったのに、2回戦を忘れてしまったようなものです。上位の対戦相手との比較も必要です。"
      },
      {
        "text": "3",
        "isCorrect": false,
        "whyWrong": "根（heap[0]=3）まで交換が続くと誤解した場合の値です。heap[0]=3は4より小さいため、根との交換は行われません。親が子より小さい時点でアップヒープは停止します。",
        "analogy": "トーナメントでチャンピオン（3番）より弱い（4番）ので、準優勝の位置で止まります。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "新要素が最大値で交換不要だった場合の値ですが、4は既存のヒープ内に自分より大きい要素（15, 10など）が複数あるため、交換が必要です。",
        "analogy": "新人選手が最も弱いわけではないので、位置の調整が必要です。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"heap": "{3,10,5,15,20,8,12}", "heapSize": 7}, "action": "初期の最小ヒープ。根3、子10と5、孫15,20,8,12"},
      {"step": 2, "variables": {"heap": "{3,10,5,15,20,8,12,4}", "i": 7, "heapSize": 8}, "action": "新要素4をインデックス7（末尾）に追加"},
      {"step": 3, "variables": {"parent": 3, "heap[3]": 15, "heap[7]": 4}, "action": "parent=(7-1)/2=3。heap[3]=15 > heap[7]=4 → 交換"},
      {"step": 4, "variables": {"heap": "{3,10,5,4,20,8,12,15}", "swapCount": 1, "i": 3}, "action": "交換完了。swapCount=1。i=3に移動"},
      {"step": 5, "variables": {"parent": 1, "heap[1]": 10, "heap[3]": 4}, "action": "parent=(3-1)/2=1。heap[1]=10 > heap[3]=4 → 交換"},
      {"step": 6, "variables": {"heap": "{3,4,5,10,20,8,12,15}", "swapCount": 2, "i": 1}, "action": "交換完了。swapCount=2。i=1に移動"},
      {"step": 7, "variables": {"parent": 0, "heap[0]": 3, "heap[1]": 4}, "action": "parent=(1-1)/2=0。heap[0]=3 ≦ heap[1]=4 → 交換不要。ループ終了"},
      {"step": 8, "variables": {"swapCount": 2}, "action": "swapCount=2を表示。最終ヒープ: {3,4,5,10,20,8,12,15}"}
    ],
    "traceAnalogy": "会社の組織図に新入社員（能力値4）が入社しました。最初は一番下（インデックス7）に配属されます。直属の上司（能力値15）より有能なので昇進→次の上司（能力値10）よりも有能なのでさらに昇進→社長（能力値3）には及ばないので停止。2回の昇進で正しいポジションに収まります。",
    "overallExplanation": "最小ヒープへの要素追加（アップヒープ操作）のトレース問題です。値4を末尾に追加し、親ノードと比較しながら上方へ移動させます。15との交換、10との交換の計2回で、根の子の位置に落ち着きます。根の3は4より小さいため、そこで停止します。"
  },
  {
    "questionId": "q-trace-052",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "逆ポーランド記法の評価",
    "level": 7,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○文字列型の配列: tokens ← {\"5\", \"3\", \"4\", \"*\", \"+\", \"2\", \"-\", \"8\", \"*\"}\n○整数型の配列: stack ← {}  /* 空のスタック */\n○整数型: a, b, result\n○整数型: i\n\ni を 0 から (tokensの要素数 - 1) まで 1 ずつ増やしながら繰り返す\n  もし tokens[i] = \"+\" ならば\n    b ← stackから末尾の要素を取り出す\n    a ← stackから末尾の要素を取り出す\n    stackに (a + b) を追加する\n  そうでなくもし tokens[i] = \"-\" ならば\n    b ← stackから末尾の要素を取り出す\n    a ← stackから末尾の要素を取り出す\n    stackに (a - b) を追加する\n  そうでなくもし tokens[i] = \"*\" ならば\n    b ← stackから末尾の要素を取り出す\n    a ← stackから末尾の要素を取り出す\n    stackに (a * b) を追加する\n  そうでなければ\n    stackに tokens[i]を整数に変換して追加する\n  を実行する\nを繰り返す\nresult ← stackから末尾の要素を取り出す\n表示(result)",
    "choices": [
      {
        "text": "120",
        "isCorrect": true,
        "whyCorrect": "トークンを順に処理: 5→push, 3→push, 4→push, *→3*4=12をpush, +→5+12=17をpush, 2→push, -→17-2=15をpush, 8→push, *→15*8=120をpush。結果は120です。",
        "analogy": "工場のベルトコンベアで、数値が来たら箱に入れ、演算記号が来たら箱から2つ取り出して計算し結果を箱に戻す作業です。最後の箱から取り出した120が最終製品です。",
        "deepDive": "逆ポーランド記法（後置記法）はスタックを使って括弧なしで式の評価順序を表現できます。この式は中置記法で (5 + 3 * 4 - 2) * 8 に相当します。コンパイラの式評価やHP社の電卓で使われています。"
      },
      {
        "text": "15",
        "isCorrect": false,
        "whyWrong": "最後の「*8」の処理を忘れた場合の値です。tokens配列の末尾まで処理を続ける必要があり、17-2=15の後に15*8=120が計算されます。",
        "analogy": "レシピの最後のステップを飛ばして料理を完成とした場合のようなものです。全工程を終える必要があります。"
      },
      {
        "text": "136",
        "isCorrect": false,
        "whyWrong": "「-」の演算でaとbの取り出し順を逆にした場合（2-17=-15→-15*8=-120ではなく、5+12=17, 17-2=15が正しい）。あるいは別の計算ミスの結果です。演算子の場合、先にbを取り出し、次にaを取り出してa演算子bと計算します。",
        "analogy": "引き算や割り算では「どちらからどちらを引くか」の順序が重要です。スタックから取り出す順番に注意が必要です。"
      },
      {
        "text": "56",
        "isCorrect": false,
        "whyWrong": "「5 3 4 * + 2 -」の部分を(5+3)*4-2=30と誤計算し、30ではなく(5+3-2)*8=48...ではなく、乗算の優先順位を通常の中置記法と同様に適用した場合のミスです。逆ポーランド記法ではトークンの出現順に忠実にスタック操作を行います。",
        "analogy": "逆ポーランド記法では通常の演算優先順位は関係なく、トークンの並び順がそのまま計算順序になります。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"stack": "[5]"}, "action": "token=\"5\" → 5をpush"},
      {"step": 2, "variables": {"stack": "[5,3]"}, "action": "token=\"3\" → 3をpush"},
      {"step": 3, "variables": {"stack": "[5,3,4]"}, "action": "token=\"4\" → 4をpush"},
      {"step": 4, "variables": {"stack": "[5,12]", "a": 3, "b": 4}, "action": "token=\"*\" → b=4, a=3を取り出し、3*4=12をpush"},
      {"step": 5, "variables": {"stack": "[17]", "a": 5, "b": 12}, "action": "token=\"+\" → b=12, a=5を取り出し、5+12=17をpush"},
      {"step": 6, "variables": {"stack": "[17,2]"}, "action": "token=\"2\" → 2をpush"},
      {"step": 7, "variables": {"stack": "[15]", "a": 17, "b": 2}, "action": "token=\"-\" → b=2, a=17を取り出し、17-2=15をpush"},
      {"step": 8, "variables": {"stack": "[15,8]"}, "action": "token=\"8\" → 8をpush"},
      {"step": 9, "variables": {"stack": "[120]", "a": 15, "b": 8}, "action": "token=\"*\" → b=8, a=15を取り出し、15*8=120をpush"},
      {"step": 10, "variables": {"result": 120}, "action": "スタックから120を取り出し表示"}
    ],
    "traceAnalogy": "お皿を積み重ねるように数字を積んでいきます。演算記号が来たら上から2枚取って計算し、結果を新しいお皿として戻します。「5, 3, 4」と3枚積み→「*」で上2枚(3と4)を取って12を戻す→「+」で上2枚(5と12)を取って17を戻す→「2」を積む→「-」で17-2=15→「8」を積む→「*」で15×8=120。最後のお皿は120です。",
    "overallExplanation": "逆ポーランド記法（後置記法）の評価をスタックでトレースする問題です。数値はスタックにpushし、演算子が来たらスタックから2つpopして計算し結果をpushします。注意点は、減算・除算では取り出し順が重要で、後にpopした方がa（左オペランド）になることです。最終結果は(5+3*4-2)*8=120です。"
  }
]