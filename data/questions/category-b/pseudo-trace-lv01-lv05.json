[
  {
    "questionId": "q-trace-001",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "単純な代入と演算",
    "level": 1,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: a, b, c\na ← 5\nb ← 3\nc ← a + b * 2\n表示(c)",
    "choices": [
      {
        "text": "11",
        "isCorrect": true,
        "whyCorrect": "演算の優先順位により、まず b * 2 = 6 が計算され、次に a + 6 = 11 となります。掛け算は足し算より先に計算されます。",
        "analogy": "買い物で「りんご1個500円と、みかん3個×200円」を計算するとき、まず「みかん3個×200円=600円」を先に計算してから「500+600=1100円」と求めるのと同じです。",
        "deepDive": "プログラムでも数学と同様に、乗算(*)・除算(/)は加算(+)・減算(-)より優先されます。この優先順位を「演算子の優先順位」と呼びます。"
      },
      {
        "text": "16",
        "isCorrect": false,
        "whyWrong": "これは (a + b) * 2 = (5 + 3) * 2 = 16 と左から順に計算した場合の値です。掛け算は足し算より先に計算されるため、a + (b * 2) が正しい計算順序です。",
        "analogy": "レジで「500円+300円を先に足してから2倍する」のではなく、「300円×2を先に計算してから500円を足す」が正しい手順です。"
      },
      {
        "text": "13",
        "isCorrect": false,
        "whyWrong": "この値になる計算パターンはありません。a=5, b=3, c=a+b*2 の各値を正確にトレースすれば 11 が得られます。",
        "analogy": "レシピの分量を間違えると料理の味が変わるように、計算の数値を間違えると結果も変わります。一つ一つ確認しましょう。"
      },
      {
        "text": "8",
        "isCorrect": false,
        "whyWrong": "これは a + b = 5 + 3 = 8 で、* 2 の部分を計算に含めていない場合の値です。式全体 a + b * 2 を計算する必要があります。",
        "analogy": "レシピの手順を途中で止めてしまうと、完成品にならないのと同じです。式全体を最後まで計算しましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"a": "未定義", "b": "未定義", "c": "未定義"}, "action": "変数 a, b, c を宣言"},
      {"step": 2, "variables": {"a": 5, "b": "未定義", "c": "未定義"}, "action": "a に 5 を代入"},
      {"step": 3, "variables": {"a": 5, "b": 3, "c": "未定義"}, "action": "b に 3 を代入"},
      {"step": 4, "variables": {"a": 5, "b": 3, "c": 11}, "action": "c ← a + b * 2 = 5 + 3*2 = 5 + 6 = 11"},
      {"step": 5, "variables": {"a": 5, "b": 3, "c": 11}, "action": "c の値 11 を表示"}
    ],
    "traceAnalogy": "箱に数字を入れる作業です。箱aに5、箱bに3を入れ、箱cには「箱aの中身 + 箱bの中身×2」の計算結果を入れます。3×2=6を先に計算し、5+6=11を箱cに入れて、最後に箱cの中身を見せます。",
    "overallExplanation": "このプログラムは代入と四則演算の基本を問う問題です。演算子の優先順位（掛け算が足し算より先）を正しく理解することが重要です。c ← a + b * 2 では、まず b*2=6 が計算され、次に a+6=11 が計算されます。"
  },
  {
    "questionId": "q-trace-002",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "if文1つの判定",
    "level": 1,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: x\nx ← 7\nもし x > 5 ならば\n  x ← x + 10\nそうでなければ\n  x ← x - 10\nを実行する\n表示(x)",
    "choices": [
      {
        "text": "17",
        "isCorrect": true,
        "whyCorrect": "x=7 で条件 x>5 は 7>5 で真なので、x ← x+10 = 7+10 = 17 が実行されます。",
        "analogy": "身長が150cm以上ならジェットコースターに乗れるルールで、160cmの人が来たら「乗れる」と判定されるのと同じです。7は5より大きいので「ならば」側が実行されます。",
        "deepDive": "if文（もし〜ならば）は条件が真(true)のとき「ならば」の処理を、偽(false)のとき「そうでなければ」の処理を実行します。条件式の評価結果を正確に判定することが重要です。"
      },
      {
        "text": "-3",
        "isCorrect": false,
        "whyWrong": "これは x-10 = 7-10 = -3 で、「そうでなければ」側が実行された場合の値です。x=7 は 5 より大きいので、条件 x>5 は真となり「ならば」側が実行されます。",
        "analogy": "身長制限をクリアしているのに「乗れない」と判定してしまったようなものです。条件を正しく評価しましょう。"
      },
      {
        "text": "7",
        "isCorrect": false,
        "whyWrong": "これは条件分岐を実行せず、x の初期値がそのまま表示された場合の値です。条件分岐は必ず「ならば」か「そうでなければ」のどちらかが実行されます。",
        "analogy": "信号が青か赤かを確認せずに立ち止まったままのようなものです。必ずどちらかの道に進みます。"
      },
      {
        "text": "12",
        "isCorrect": false,
        "whyWrong": "この値になる計算パターンは元のプログラムにはありません。x+10=17 または x-10=-3 のいずれかです。",
        "analogy": "メニューにない料理を注文しようとしているようなものです。用意されている選択肢から正しいものを選びましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"x": "未定義"}, "action": "変数 x を宣言"},
      {"step": 2, "variables": {"x": 7}, "action": "x に 7 を代入"},
      {"step": 3, "variables": {"x": 7}, "action": "条件判定: x > 5 → 7 > 5 → 真"},
      {"step": 4, "variables": {"x": 17}, "action": "条件が真なので x ← x + 10 = 7 + 10 = 17 を実行"},
      {"step": 5, "variables": {"x": 17}, "action": "x の値 17 を表示"}
    ],
    "traceAnalogy": "自動販売機のようなものです。お金を入れて（x=7）、ボタンを押すと機械が判定します。「5円より多い？」→「はい、7円です」→「じゃあ10円おまけをあげて17円にしましょう」という流れです。",
    "overallExplanation": "if-else文（もし〜ならば〜そうでなければ）の基本的な条件分岐の問題です。条件式 x>5 の真偽を正しく判定し、対応する処理を追跡することがポイントです。"
  },
  {
    "questionId": "q-trace-003",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "単純なfor文（1からNの合計）",
    "level": 1,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: sum, i\nsum ← 0\ni を 1 から 4 まで 1 ずつ増やしながら繰り返す\n  sum ← sum + i\nを繰り返す\n表示(sum)",
    "choices": [
      {
        "text": "10",
        "isCorrect": true,
        "whyCorrect": "ループで i=1,2,3,4 の各値を sum に加算します。sum = 0+1+2+3+4 = 10 です。",
        "analogy": "貯金箱に1日目は1円、2日目は2円、3日目は3円、4日目は4円を入れると、合計は1+2+3+4=10円になります。",
        "deepDive": "1からNまでの合計は公式 N*(N+1)/2 でも求められます。4*(4+1)/2 = 10 です。この公式はガウスが少年時代に発見したと言われています。"
      },
      {
        "text": "15",
        "isCorrect": false,
        "whyWrong": "これは 1+2+3+4+5=15 で、i を 5 まで繰り返した場合の値です。このプログラムでは i は 4 まで（4を含む）です。",
        "analogy": "4日間の貯金計画なのに5日分を数えてしまったようなものです。「4まで」は4を含みますが5は含みません。"
      },
      {
        "text": "6",
        "isCorrect": false,
        "whyWrong": "これは 1+2+3=6 で、i を 3 まで繰り返した場合の値です。「4まで」なので i=4 のときも処理が実行されます。",
        "analogy": "4階建てのビルを3階までしか上らなかったようなものです。「4まで」は4階も含みます。"
      },
      {
        "text": "4",
        "isCorrect": false,
        "whyWrong": "これは最後の i の値です。sum は各回の i を累積的に加算するので、最後の i の値ではなく合計値が表示されます。",
        "analogy": "貯金箱の中身の合計額を聞かれているのに、最後に入れた金額だけを答えてしまったようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"sum": 0, "i": "未定義"}, "action": "sum を 0 で初期化"},
      {"step": 2, "variables": {"sum": 0, "i": 1}, "action": "i=1 でループ開始"},
      {"step": 3, "variables": {"sum": 1, "i": 1}, "action": "sum ← 0 + 1 = 1"},
      {"step": 4, "variables": {"sum": 1, "i": 2}, "action": "i=2 でループ継続"},
      {"step": 5, "variables": {"sum": 3, "i": 2}, "action": "sum ← 1 + 2 = 3"},
      {"step": 6, "variables": {"sum": 3, "i": 3}, "action": "i=3 でループ継続"},
      {"step": 7, "variables": {"sum": 6, "i": 3}, "action": "sum ← 3 + 3 = 6"},
      {"step": 8, "variables": {"sum": 6, "i": 4}, "action": "i=4 でループ継続"},
      {"step": 9, "variables": {"sum": 10, "i": 4}, "action": "sum ← 6 + 4 = 10"},
      {"step": 10, "variables": {"sum": 10, "i": 4}, "action": "ループ終了、sum の値 10 を表示"}
    ],
    "traceAnalogy": "毎日お小遣いをもらって貯金箱に入れていく作業です。1日目に1円、2日目に2円...と毎日もらう額が増えていき、4日目まで続けると貯金箱には合計10円入っています。",
    "overallExplanation": "for文（繰り返し）の基本的なトレース問題です。ループ変数 i が 1 から 4 まで変化し、各回で sum に i を加算します。累計の変化を正確に追跡することがポイントです。"
  },
  {
    "questionId": "q-trace-004",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "文字列連結",
    "level": 1,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○文字列型: s1, s2, result\ns1 ← \"Hello\"\ns2 ← \"World\"\nresult ← s1 + \"-\" + s2\n表示(result)",
    "choices": [
      {
        "text": "Hello-World",
        "isCorrect": true,
        "whyCorrect": "文字列の + 演算子は文字列を連結します。s1=\"Hello\" と \"-\" と s2=\"World\" を順につなげると \"Hello-World\" になります。",
        "analogy": "電車の連結のように、先頭車両「Hello」に中間車両「-」を繋ぎ、最後尾に「World」を繋げると「Hello-World」という編成になります。",
        "deepDive": "文字列の連結(concatenation)は多くのプログラミング言語で + 演算子を使います。数値の加算と文字列の連結は別の操作であり、型によって動作が異なります。"
      },
      {
        "text": "HelloWorld",
        "isCorrect": false,
        "whyWrong": "これは s1 + s2 だけを連結した場合の結果です。プログラムでは間にハイフン \"-\" も連結しているため、Hello-World が正しい結果です。",
        "analogy": "3両連結の電車なのに中間車両を忘れてしまったようなものです。\"-\" の部分も忘れずに連結しましょう。"
      },
      {
        "text": "Hello World",
        "isCorrect": false,
        "whyWrong": "これはハイフンの代わりにスペースで区切られています。プログラムでは \"-\"（ハイフン）を連結しており、スペースではありません。",
        "analogy": "接着剤の種類を間違えたようなものです。「-」という接着剤で繋いでいるのに「 」（スペース）で繋いだと勘違いしています。"
      },
      {
        "text": "エラーが発生する",
        "isCorrect": false,
        "whyWrong": "文字列同士の + 演算は連結を意味する有効な操作です。文字列型同士の連結でエラーは発生しません。",
        "analogy": "同じ種類のパズルピースはきちんとはまります。文字列同士の連結は問題なく実行できます。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"s1": "未定義", "s2": "未定義", "result": "未定義"}, "action": "変数 s1, s2, result を宣言"},
      {"step": 2, "variables": {"s1": "Hello", "s2": "未定義", "result": "未定義"}, "action": "s1 に \"Hello\" を代入"},
      {"step": 3, "variables": {"s1": "Hello", "s2": "World", "result": "未定義"}, "action": "s2 に \"World\" を代入"},
      {"step": 4, "variables": {"s1": "Hello", "s2": "World", "result": "Hello-World"}, "action": "result ← \"Hello\" + \"-\" + \"World\" = \"Hello-World\""},
      {"step": 5, "variables": {"s1": "Hello", "s2": "World", "result": "Hello-World"}, "action": "result の値 \"Hello-World\" を表示"}
    ],
    "traceAnalogy": "名札を作る作業です。姓のシール「Hello」と、区切りのシール「-」と、名のシール「World」を順番に台紙に貼ると「Hello-World」という名札ができあがります。",
    "overallExplanation": "文字列連結の基本問題です。+ 演算子が文字列に対して使われると、数値の加算ではなく文字列の連結が行われます。連結する順序と中間の文字列にも注意して追跡しましょう。"
  },
  {
    "questionId": "q-trace-005",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "変数の交換（swap）",
    "level": 1,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: a, b, temp\na ← 10\nb ← 20\ntemp ← a\na ← b\nb ← temp\n表示(a)\n表示(b)",
    "choices": [
      {
        "text": "20 と 10",
        "isCorrect": true,
        "whyCorrect": "temp を使って a と b の値を交換しています。temp=10(元のa), a=20(元のb), b=10(temp=元のa) となり、a=20, b=10 が表示されます。",
        "analogy": "コップAにオレンジジュース、コップBにりんごジュースが入っているとき、空のコップ(temp)にAの中身を移し、AにBの中身を入れ、BにtempのAの中身を入れれば、中身が入れ替わります。",
        "deepDive": "値の交換（スワップ）は一時変数(temp)を使うのが基本です。直接 a←b, b←a とすると、最初の代入で a の元の値が失われます。一時変数は「退避場所」の役割を果たします。"
      },
      {
        "text": "10 と 20",
        "isCorrect": false,
        "whyWrong": "これは交換前の値です。プログラムは temp を介して a と b の値を入れ替えているので、最終的に a=20, b=10 になります。",
        "analogy": "コップの中身を入れ替える作業を行ったのに、入れ替え前の状態を答えてしまったようなものです。"
      },
      {
        "text": "20 と 20",
        "isCorrect": false,
        "whyWrong": "これは temp を使わずに a←b としてから b←a とした場合の結果です。a←b で a が 20 になった後、b←a では a はすでに 20 なので b も 20 になります。temp のおかげで元の a の値が保存されています。",
        "analogy": "空のコップ(temp)を使わずに直接入れ替えようとすると、両方同じジュースになってしまいます。temp があるから正しく交換できるのです。"
      },
      {
        "text": "10 と 10",
        "isCorrect": false,
        "whyWrong": "この結果になる処理パターンはプログラム中にありません。各代入文を順に追跡すると a=20, b=10 が正しい結果です。",
        "analogy": "両方のコップに同じジュースを注いでしまったようなものです。プログラムの手順を1行ずつ正確に追いましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"a": 10, "b": 20, "temp": "未定義"}, "action": "a に 10、b に 20 を代入"},
      {"step": 2, "variables": {"a": 10, "b": 20, "temp": 10}, "action": "temp ← a: a の値 10 を temp に退避"},
      {"step": 3, "variables": {"a": 20, "b": 20, "temp": 10}, "action": "a ← b: b の値 20 を a に代入"},
      {"step": 4, "variables": {"a": 20, "b": 10, "temp": 10}, "action": "b ← temp: temp の値 10 を b に代入"},
      {"step": 5, "variables": {"a": 20, "b": 10, "temp": 10}, "action": "a の値 20 を表示、b の値 10 を表示"}
    ],
    "traceAnalogy": "引っ越し作業です。A部屋の家具をまず倉庫(temp)に移し、B部屋の家具をA部屋に運び、最後に倉庫の家具をB部屋に運びます。これで両部屋の家具が入れ替わります。",
    "overallExplanation": "変数の値を交換する基本的なスワップ処理の問題です。一時変数 temp を使って元の値を退避させることで、2つの変数の値を正しく交換できます。代入の順序を1行ずつ正確に追跡することが重要です。"
  },
  {
    "questionId": "q-trace-006",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "剰余演算",
    "level": 1,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: n, r\nn ← 17\nr ← n mod 5\n表示(r)",
    "choices": [
      {
        "text": "2",
        "isCorrect": true,
        "whyCorrect": "mod は剰余（余り）を求める演算子です。17 ÷ 5 = 3 余り 2 なので、17 mod 5 = 2 です。",
        "analogy": "17個のクッキーを5人で均等に分けると、1人3個ずつで15個配れて、2個余ります。この余りの2が答えです。",
        "deepDive": "剰余演算(mod)は偶数奇数の判定(n mod 2)、桁の取り出し(n mod 10で一の位)、周期的な処理(n mod 7で曜日計算)など、プログラミングで非常によく使われる演算です。"
      },
      {
        "text": "3",
        "isCorrect": false,
        "whyWrong": "3 は 17÷5 の商（割り算の答え）です。mod は余りを求める演算子であり、商ではありません。商を求めるのは div 演算子です。",
        "analogy": "クッキーを配るとき、「1人何個配れるか（商=3）」ではなく「何個余るか（余り=2）」を聞いています。"
      },
      {
        "text": "3.4",
        "isCorrect": false,
        "whyWrong": "3.4 は 17÷5 の通常の除算結果です。mod は整数の余りを求める演算であり、小数の結果は返しません。",
        "analogy": "「余りは何個？」と聞いているのに「1人あたり3.4個」と答えてしまったようなものです。mod は整数の余りだけを返します。"
      },
      {
        "text": "5",
        "isCorrect": false,
        "whyWrong": "5 は割る数そのものです。余りは必ず割る数より小さくなります。17 mod 5 の余りは 0〜4 の範囲です。",
        "analogy": "5人で分けたときの余りが5個ということは、もう1人に配れるはずです。余りは必ず割る数より少なくなります。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"n": "未定義", "r": "未定義"}, "action": "変数 n, r を宣言"},
      {"step": 2, "variables": {"n": 17, "r": "未定義"}, "action": "n に 17 を代入"},
      {"step": 3, "variables": {"n": 17, "r": 2}, "action": "r ← 17 mod 5 = 2（17÷5=3余り2）"},
      {"step": 4, "variables": {"n": 17, "r": 2}, "action": "r の値 2 を表示"}
    ],
    "traceAnalogy": "ピザを切り分ける場面です。17切れのピザを5人で均等に分けると、1人3切れずつ配って2切れ余ります。mod演算は「余った切れ数」を教えてくれます。",
    "overallExplanation": "剰余演算(mod)の基本問題です。mod は割り算の余りを求めます。17÷5 の商は3、余りは2です。mod と div（整数除算）の違いを理解することが重要です。"
  },
  {
    "questionId": "q-trace-007",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "絶対値の計算",
    "level": 1,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: x, result\nx ← -8\nもし x < 0 ならば\n  result ← x * (-1)\nそうでなければ\n  result ← x\nを実行する\n表示(result)",
    "choices": [
      {
        "text": "8",
        "isCorrect": true,
        "whyCorrect": "x=-8 は 0 より小さいので条件 x<0 は真です。result ← x*(-1) = -8*(-1) = 8 となります。これは絶対値の計算です。",
        "analogy": "温度計で「マイナス8度」と表示されているとき、「寒さの度合い」を知りたければマイナスを外して8度分の寒さと考えます。これが絶対値です。",
        "deepDive": "絶対値は数直線上での原点からの距離を表します。負の数に-1を掛けると正の数になり、正の数はそのままです。この条件分岐が絶対値関数の基本的な実装です。"
      },
      {
        "text": "-8",
        "isCorrect": false,
        "whyWrong": "x の初期値 -8 がそのまま表示されると考えた場合の答えです。x<0 が真なので result ← x*(-1) が実行され、-8*(-1)=8 になります。",
        "analogy": "マイナスの符号を取り除く作業をしたのに、取り除く前の値を答えてしまったようなものです。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "0 になる計算はこのプログラムにはありません。x*(-1) = -8*(-1) = 8 です。",
        "analogy": "何かを裏返したら消えてしまうことはありません。-8を裏返す（-1を掛ける）と8になります。"
      },
      {
        "text": "-16",
        "isCorrect": false,
        "whyWrong": "これは x*2 = -8*2 = -16 の計算結果です。プログラムでは x*(-1) を計算しており、-8に-1を掛けると8（正の数）になります。",
        "analogy": "-1を掛けるのは「符号を反転させる」操作であり、「2倍にする」操作ではありません。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"x": -8, "result": "未定義"}, "action": "x に -8 を代入"},
      {"step": 2, "variables": {"x": -8, "result": "未定義"}, "action": "条件判定: x < 0 → -8 < 0 → 真"},
      {"step": 3, "variables": {"x": -8, "result": 8}, "action": "条件が真なので result ← x * (-1) = -8 * (-1) = 8"},
      {"step": 4, "variables": {"x": -8, "result": 8}, "action": "result の値 8 を表示"}
    ],
    "traceAnalogy": "借金の金額を知りたい場面です。通帳に「-8万円」と書いてあるとき、「借金はいくら？」と聞かれたら「8万円」と答えます。マイナスを取り除いて大きさだけを見るのが絶対値です。",
    "overallExplanation": "このプログラムは絶対値を計算します。負の数に-1を掛けて正の数に変換し、正の数はそのまま返します。条件分岐の判定と、負の数の符号反転の計算を正確に行うことが重要です。"
  },
  {
    "questionId": "q-trace-008",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "最大値の選択",
    "level": 1,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: a, b, c, max\na ← 3\nb ← 9\nc ← 5\nmax ← a\nもし b > max ならば\n  max ← b\nを実行する\nもし c > max ならば\n  max ← c\nを実行する\n表示(max)",
    "choices": [
      {
        "text": "9",
        "isCorrect": true,
        "whyCorrect": "最初に max=a=3 とし、b=9>3(max) なので max=9 に更新。次に c=5 は 9(max) より大きくないので更新なし。最大値 9 が表示されます。",
        "analogy": "3人の身長比べです。最初にAさん(3cm)を暫定チャンピオンにし、Bさん(9cm)がもっと高いのでチャンピオン交代、Cさん(5cm)はBさんより低いので変更なし。チャンピオンはBさん(9cm)です。",
        "deepDive": "この方法は「逐次比較法」と呼ばれ、配列の最大値を求めるアルゴリズムの基本です。要素を1つずつ比較して暫定最大値を更新していきます。要素数が増えてもこの考え方は同じです。"
      },
      {
        "text": "5",
        "isCorrect": false,
        "whyWrong": "c=5 は最後に比較されますが、max=9 より小さいため max は更新されません。最後に比較した値が必ず最大値になるわけではありません。",
        "analogy": "最後に挑戦した人が必ずチャンピオンになるわけではありません。既にもっと強い人がいれば、チャンピオンは変わりません。"
      },
      {
        "text": "3",
        "isCorrect": false,
        "whyWrong": "3 は max の初期値（a の値）です。b=9>3 の比較で max は 9 に更新されるので、最終結果は 3 ではなく 9 です。",
        "analogy": "最初のチャレンジャーが暫定チャンピオンですが、より強い人が現れたらチャンピオンは交代します。"
      },
      {
        "text": "17",
        "isCorrect": false,
        "whyWrong": "17 は a+b+c=3+9+5 の合計値です。このプログラムは合計ではなく最大値を求めています。",
        "analogy": "「一番背が高い人は？」と聞かれているのに、「全員の身長の合計は？」と答えてしまったようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"a": 3, "b": 9, "c": 5, "max": "未定義"}, "action": "a=3, b=9, c=5 を代入"},
      {"step": 2, "variables": {"a": 3, "b": 9, "c": 5, "max": 3}, "action": "max ← a = 3（暫定最大値）"},
      {"step": 3, "variables": {"a": 3, "b": 9, "c": 5, "max": 3}, "action": "条件判定: b > max → 9 > 3 → 真"},
      {"step": 4, "variables": {"a": 3, "b": 9, "c": 5, "max": 9}, "action": "max ← b = 9 に更新"},
      {"step": 5, "variables": {"a": 3, "b": 9, "c": 5, "max": 9}, "action": "条件判定: c > max → 5 > 9 → 偽"},
      {"step": 6, "variables": {"a": 3, "b": 9, "c": 5, "max": 9}, "action": "条件が偽なので max は更新されない"},
      {"step": 7, "variables": {"a": 3, "b": 9, "c": 5, "max": 9}, "action": "max の値 9 を表示"}
    ],
    "traceAnalogy": "クラスで一番テストの点数が高い人を探す作業です。出席番号順に1人ずつ点数を確認し、これまでの最高点より高ければ記録を更新します。全員確認が終わった時点の記録が最高点です。",
    "overallExplanation": "3つの値から最大値を求めるプログラムです。暫定最大値を設定し、他の値と順に比較して大きければ更新するという逐次比較のアルゴリズムです。各条件判定の真偽を正確に追跡しましょう。"
  },
  {
    "questionId": "q-trace-009",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "ネストしたif文の追跡",
    "level": 2,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: score, result\nscore ← 72\nもし score ≧ 60 ならば\n  もし score ≧ 80 ならば\n    result ← 3\n  そうでなければ\n    result ← 2\n  を実行する\nそうでなければ\n  result ← 1\nを実行する\n表示(result)",
    "choices": [
      {
        "text": "2",
        "isCorrect": true,
        "whyCorrect": "score=72 は 60以上なので外側の条件は真。次に 80以上かを判定すると 72<80 で偽なので、result=2 になります。",
        "analogy": "テストの成績判定です。60点以上で合格圏内に入り、さらに80点以上なら優秀(3)、そうでなければ良好(2)です。72点は合格圏だが優秀には届かないので「良好(2)」です。",
        "deepDive": "ネストしたif文は外側の条件から順に評価されます。外側が真の場合にのみ内側の条件が評価されます。この構造は範囲による分類処理でよく使われます。"
      },
      {
        "text": "3",
        "isCorrect": false,
        "whyWrong": "result=3 になるには score≧80 が必要です。score=72 は 80 未満なので内側の条件は偽となり、「そうでなければ」の result=2 が実行されます。",
        "analogy": "72点で「優秀」と判定してしまうのは、80点のラインを見落としたようなものです。"
      },
      {
        "text": "1",
        "isCorrect": false,
        "whyWrong": "result=1 になるには外側の条件 score≧60 が偽である必要があります。score=72 は 60 以上なので外側は真となり、result=1 には到達しません。",
        "analogy": "72点は60点の合格ラインを超えているのに、不合格(1)と判定してしまったようなものです。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "result=0 になる処理はプログラム中にありません。結果は 1, 2, 3 のいずれかです。",
        "analogy": "用意されていない評価ランクを選んでしまったようなものです。プログラムの処理を正確に追いましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"score": 72, "result": "未定義"}, "action": "score に 72 を代入"},
      {"step": 2, "variables": {"score": 72, "result": "未定義"}, "action": "外側の条件判定: score ≧ 60 → 72 ≧ 60 → 真"},
      {"step": 3, "variables": {"score": 72, "result": "未定義"}, "action": "内側の条件判定: score ≧ 80 → 72 ≧ 80 → 偽"},
      {"step": 4, "variables": {"score": 72, "result": 2}, "action": "内側の条件が偽なので result ← 2"},
      {"step": 5, "variables": {"score": 72, "result": 2}, "action": "result の値 2 を表示"}
    ],
    "traceAnalogy": "レストランの予約判定です。まず「予約があるか？」（60点以上か）を確認して通過し、次に「VIP席か？」（80点以上か）を確認します。72点は一般席（result=2）に案内されます。",
    "overallExplanation": "ネストしたif文の問題です。条件分岐が入れ子になっている場合、外側の条件が真のときのみ内側の条件が評価されます。各条件の真偽を外側から順に判定していくことがポイントです。"
  },
  {
    "questionId": "q-trace-010",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "for文とif文の組み合わせ（偶数カウント）",
    "level": 2,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: count, i\ncount ← 0\ni を 1 から 8 まで 1 ずつ増やしながら繰り返す\n  もし i mod 2 = 0 ならば\n    count ← count + 1\n  を実行する\nを繰り返す\n表示(count)",
    "choices": [
      {
        "text": "4",
        "isCorrect": true,
        "whyCorrect": "1から8までの偶数は 2,4,6,8 の4個です。i mod 2 = 0 となるのは偶数のときだけなので、count は4回増加して最終値は4です。",
        "analogy": "1から8までの番号札から偶数だけを取り出す作業です。2番、4番、6番、8番の4枚が偶数なので、数えると4枚です。",
        "deepDive": "n mod 2 = 0 は偶数判定の定番パターンです。2で割った余りが0なら偶数、1なら奇数です。カウンタ変数を0で初期化し、条件に合致するたびに1加算するのはカウント処理の基本形です。"
      },
      {
        "text": "3",
        "isCorrect": false,
        "whyWrong": "1から7までの偶数が3個（2,4,6）なので、「8まで」を「7まで」と読み間違えた可能性があります。8も偶数でカウントされるので、正解は4です。",
        "analogy": "8番目の番号札を見落としたようなものです。「8まで」は8を含みます。"
      },
      {
        "text": "5",
        "isCorrect": false,
        "whyWrong": "1から8まで8個の数のうち偶数は4個です。5個になることはありません。偶数と奇数は交互に並ぶので、8個中ちょうど半分の4個が偶数です。",
        "analogy": "交互に並んだ白と黒のタイルが8枚あるとき、白は4枚です。5枚にはなりません。"
      },
      {
        "text": "8",
        "isCorrect": false,
        "whyWrong": "これは全ての数をカウントした場合の値です。if文の条件 i mod 2 = 0 により偶数のみがカウントされるので、全8個ではなく4個です。",
        "analogy": "偶数だけを数える指示なのに、全部の番号を数えてしまったようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"count": 0, "i": "未定義"}, "action": "count を 0 で初期化"},
      {"step": 2, "variables": {"count": 0, "i": 1}, "action": "i=1: 1 mod 2 = 1 ≠ 0 → カウントしない"},
      {"step": 3, "variables": {"count": 1, "i": 2}, "action": "i=2: 2 mod 2 = 0 → count = 0+1 = 1"},
      {"step": 4, "variables": {"count": 1, "i": 3}, "action": "i=3: 3 mod 2 = 1 ≠ 0 → カウントしない"},
      {"step": 5, "variables": {"count": 2, "i": 4}, "action": "i=4: 4 mod 2 = 0 → count = 1+1 = 2"},
      {"step": 6, "variables": {"count": 2, "i": 5}, "action": "i=5: 5 mod 2 = 1 ≠ 0 → カウントしない"},
      {"step": 7, "variables": {"count": 3, "i": 6}, "action": "i=6: 6 mod 2 = 0 → count = 2+1 = 3"},
      {"step": 8, "variables": {"count": 3, "i": 7}, "action": "i=7: 7 mod 2 = 1 ≠ 0 → カウントしない"},
      {"step": 9, "variables": {"count": 4, "i": 8}, "action": "i=8: 8 mod 2 = 0 → count = 3+1 = 4"},
      {"step": 10, "variables": {"count": 4, "i": 8}, "action": "ループ終了、count の値 4 を表示"}
    ],
    "traceAnalogy": "工場のベルトコンベアで製品が1番から8番まで流れてきます。品質チェック係は偶数番号の製品だけを箱に入れます。2番、4番、6番、8番の4個が箱に入り、count=4です。",
    "overallExplanation": "for文とif文を組み合わせた条件カウントの問題です。ループの各回で条件を判定し、条件に合致する場合のみカウンタを増加させます。mod演算による偶数判定がポイントです。"
  },
  {
    "questionId": "q-trace-011",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "while文のトレース",
    "level": 2,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: n, count\nn ← 100\ncount ← 0\nn > 1 の間繰り返す\n  n ← n div 2\n  count ← count + 1\nを繰り返す\n表示(count)",
    "choices": [
      {
        "text": "6",
        "isCorrect": true,
        "whyCorrect": "n を 2 で割り続けます: 100→50→25→12→6→3→1。n が 1 になった時点でループ終了。6回割ったので count=6 です。",
        "analogy": "紙を半分に折る作業です。100cm の紙を半分に折ると50cm、また半分で25cm...と6回折ると1cm以下になります（整数除算なので端数は切り捨て）。",
        "deepDive": "この処理は「2で何回割れるか」を数えるもので、おおよそ log2(n) に相当します。log2(100) ≒ 6.64 なので整数部分の6回が答えです。div は整数除算（小数点以下切り捨て）です。"
      },
      {
        "text": "7",
        "isCorrect": false,
        "whyWrong": "n=1 のとき条件 n>1 は偽となりループを抜けるので、7回目の除算は実行されません。while文は条件判定→処理の順なので、条件が偽になった時点で止まります。",
        "analogy": "「1より大きい間」続ける作業なので、1になったら作業は終了です。もう1回余分にやる必要はありません。"
      },
      {
        "text": "5",
        "isCorrect": false,
        "whyWrong": "5回の除算では n=100→50→25→12→6→3 で n=3 となり、まだ n>1 が真なのでループは続きます。6回目で n=3 div 2=1 となりループ終了です。",
        "analogy": "まだ折れる紙が残っているのに途中で止めてしまったようなものです。n=3 はまだ 1 より大きいので続けます。"
      },
      {
        "text": "50",
        "isCorrect": false,
        "whyWrong": "50 は 100 div 2 の結果で、1回目の除算結果です。問題が求めているのは除算の回数（count）であって、n の途中の値ではありません。",
        "analogy": "「何回折ったか」を聞いているのに「1回目に折った後の長さ」を答えてしまったようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"n": 100, "count": 0}, "action": "n=100, count=0 で初期化"},
      {"step": 2, "variables": {"n": 100, "count": 0}, "action": "条件判定: n > 1 → 100 > 1 → 真"},
      {"step": 3, "variables": {"n": 50, "count": 1}, "action": "n ← 100 div 2 = 50, count = 1"},
      {"step": 4, "variables": {"n": 50, "count": 1}, "action": "条件判定: n > 1 → 50 > 1 → 真"},
      {"step": 5, "variables": {"n": 25, "count": 2}, "action": "n ← 50 div 2 = 25, count = 2"},
      {"step": 6, "variables": {"n": 25, "count": 2}, "action": "条件判定: n > 1 → 25 > 1 → 真"},
      {"step": 7, "variables": {"n": 12, "count": 3}, "action": "n ← 25 div 2 = 12, count = 3"},
      {"step": 8, "variables": {"n": 12, "count": 3}, "action": "条件判定: n > 1 → 12 > 1 → 真"},
      {"step": 9, "variables": {"n": 6, "count": 4}, "action": "n ← 12 div 2 = 6, count = 4"},
      {"step": 10, "variables": {"n": 6, "count": 4}, "action": "条件判定: n > 1 → 6 > 1 → 真"},
      {"step": 11, "variables": {"n": 3, "count": 5}, "action": "n ← 6 div 2 = 3, count = 5"},
      {"step": 12, "variables": {"n": 3, "count": 5}, "action": "条件判定: n > 1 → 3 > 1 → 真"},
      {"step": 13, "variables": {"n": 1, "count": 6}, "action": "n ← 3 div 2 = 1, count = 6"},
      {"step": 14, "variables": {"n": 1, "count": 6}, "action": "条件判定: n > 1 → 1 > 1 → 偽 → ループ終了"},
      {"step": 15, "variables": {"n": 1, "count": 6}, "action": "count の値 6 を表示"}
    ],
    "traceAnalogy": "大きなケーキを半分ずつ切り分けていく作業です。100gのケーキを半分にすると50g、また半分で25g...と切り続け、1g以下になったら終了。切った回数を数えます。",
    "overallExplanation": "while文と整数除算(div)のトレース問題です。ループの継続条件 n>1 を毎回確認し、n を2で整数除算しながら回数を数えます。div は小数点以下を切り捨てることに注意しましょう。"
  },
  {
    "questionId": "q-trace-012",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "配列要素の合計",
    "level": 2,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: arr = {4, 7, 2, 9, 1}\n○整数型: sum, i\nsum ← 0\ni を 0 から 4 まで 1 ずつ増やしながら繰り返す\n  sum ← sum + arr[i]\nを繰り返す\n表示(sum)",
    "choices": [
      {
        "text": "23",
        "isCorrect": true,
        "whyCorrect": "配列の全要素を合計します。4+7+2+9+1 = 23 です。",
        "analogy": "財布の中のコインを全部数える作業です。4円、7円、2円、9円、1円のコインが入っていて、全部で23円です。",
        "deepDive": "配列の添え字は通常0から始まります（0-indexed）。要素数5の配列はarr[0]からarr[4]までです。配列の全要素の合計を求めるパターンは基本中の基本です。"
      },
      {
        "text": "22",
        "isCorrect": false,
        "whyWrong": "合計の計算ミスです。4+7=11、11+2=13、13+9=22...ここで止めてしまうとarr[4]=1が加算されていません。最後の要素まで含めると23です。",
        "analogy": "コインを数えるときに最後の1枚を見落としたようなものです。「4まで」なので添え字4の要素も含みます。"
      },
      {
        "text": "14",
        "isCorrect": false,
        "whyWrong": "14 は 4+7+2+1 で、arr[3]=9 を飛ばした場合の値です。ループは順に全要素を加算するので、要素の飛ばしは起きません。",
        "analogy": "列に並んだ人を順番に数えているのに、1人飛ばしてしまったようなものです。"
      },
      {
        "text": "9",
        "isCorrect": false,
        "whyWrong": "9 は配列の最大値（arr[3]）ですが、このプログラムは最大値ではなく合計を求めています。sum に全要素を加算しています。",
        "analogy": "「全部でいくら？」と聞かれているのに「一番大きなコインはいくら？」と答えてしまったようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"arr": "{4,7,2,9,1}", "sum": 0, "i": "未定義"}, "action": "配列と sum を初期化"},
      {"step": 2, "variables": {"sum": 4, "i": 0}, "action": "i=0: sum ← 0 + arr[0] = 0 + 4 = 4"},
      {"step": 3, "variables": {"sum": 11, "i": 1}, "action": "i=1: sum ← 4 + arr[1] = 4 + 7 = 11"},
      {"step": 4, "variables": {"sum": 13, "i": 2}, "action": "i=2: sum ← 11 + arr[2] = 11 + 2 = 13"},
      {"step": 5, "variables": {"sum": 22, "i": 3}, "action": "i=3: sum ← 13 + arr[3] = 13 + 9 = 22"},
      {"step": 6, "variables": {"sum": 23, "i": 4}, "action": "i=4: sum ← 22 + arr[4] = 22 + 1 = 23"},
      {"step": 7, "variables": {"sum": 23, "i": 4}, "action": "ループ終了、sum の値 23 を表示"}
    ],
    "traceAnalogy": "レジでの会計作業です。カゴの中の商品を1個ずつスキャンして合計に加えていきます。4円→11円→13円→22円→23円と、最後の商品まで合計し終えたら表示します。",
    "overallExplanation": "配列の全要素を合計するプログラムです。ループで添え字0から順にアクセスし、各要素を累計変数 sum に加算します。配列の添え字が0始まりであることと、ループ範囲に注意しましょう。"
  },
  {
    "questionId": "q-trace-013",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "逆順表示",
    "level": 2,
    "question": "次の擬似言語プログラムを実行したとき、表示される順序として正しいものはどれか。",
    "pseudoCode": "○整数型の配列: data = {10, 20, 30, 40}\n○整数型: i\ni を 3 から 0 まで 1 ずつ減らしながら繰り返す\n  表示(data[i])\nを繰り返す",
    "choices": [
      {
        "text": "40, 30, 20, 10",
        "isCorrect": true,
        "whyCorrect": "i は 3→2→1→0 と減少するので、data[3]=40, data[2]=30, data[1]=20, data[0]=10 の順に表示されます。",
        "analogy": "本棚の上から順に本を取り出すようなものです。4段目(40)→3段目(30)→2段目(20)→1段目(10)の順に取り出します。",
        "deepDive": "配列を逆順にアクセスするには、添え字を最大値から0まで減少させます。「最後の要素のインデックス = 要素数-1」なので、要素数4の配列では添え字3から始めます。"
      },
      {
        "text": "10, 20, 30, 40",
        "isCorrect": false,
        "whyWrong": "これは正順（添え字 0→3）で表示した場合の結果です。プログラムでは i を 3 から 0 まで減らしているので、逆順になります。",
        "analogy": "「上から順に」と指示されたのに「下から順に」取り出してしまったようなものです。ループの方向に注目しましょう。"
      },
      {
        "text": "40, 30, 20",
        "isCorrect": false,
        "whyWrong": "i=0 のときも処理は実行されます。「0まで」は 0 を含むので、data[0]=10 も表示されます。要素は4個全て表示されます。",
        "analogy": "1階まで階段を降りるのに、2階で止まってしまったようなものです。「0まで」は0を含みます。"
      },
      {
        "text": "30, 20, 10, 40",
        "isCorrect": false,
        "whyWrong": "ループは i=3 から始まるので最初に表示されるのは data[3]=40 です。添え字は連続的に減少するので、順序が入れ替わることはありません。",
        "analogy": "階段を降りるとき、順番を飛ばしたり戻ったりはしません。3段目→2段目→1段目→0段目と順に降ります。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"data": "{10,20,30,40}", "i": 3}, "action": "i=3 でループ開始"},
      {"step": 2, "variables": {"i": 3}, "action": "表示(data[3]) → 40 を表示"},
      {"step": 3, "variables": {"i": 2}, "action": "表示(data[2]) → 30 を表示"},
      {"step": 4, "variables": {"i": 1}, "action": "表示(data[1]) → 20 を表示"},
      {"step": 5, "variables": {"i": 0}, "action": "表示(data[0]) → 10 を表示"},
      {"step": 6, "variables": {"i": 0}, "action": "ループ終了"}
    ],
    "traceAnalogy": "トランプのカードを4枚横に並べて、右端から順に裏返していく作業です。右端(40)→右から2番目(30)→左から2番目(20)→左端(10)の順にめくります。",
    "overallExplanation": "配列を逆順に表示するプログラムです。ループ変数 i を大きい値から小さい値に向かって減少させることで、配列の末尾から先頭に向かってアクセスします。"
  },
  {
    "questionId": "q-trace-014",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "フラグ変数の使い方",
    "level": 2,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: arr = {3, 7, 2, 8, 5}\n○論理型: found\n○整数型: i\nfound ← false\ni を 0 から 4 まで 1 ずつ増やしながら繰り返す\n  もし arr[i] > 6 ならば\n    found ← true\n  を実行する\nを繰り返す\nもし found = true ならば\n  表示(1)\nそうでなければ\n  表示(0)\nを実行する",
    "choices": [
      {
        "text": "1",
        "isCorrect": true,
        "whyCorrect": "配列に 6 より大きい要素（7, 8）が存在するため、found は true になります。found=true なので 1 が表示されます。",
        "analogy": "教室で「身長170cm以上の人はいますか？」と聞いたとき、1人でもいれば「います(1)」と答えます。全員が170cm未満なら「いません(0)」です。7と8は6より大きいので「います」です。",
        "deepDive": "フラグ変数は「条件に合致する要素が存在するか」を記録するためのパターンです。一度 true になったら false に戻さないのがポイントです。「存在する」ことが確定したら、それ以降のチェックは結果を変えません。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "found=false のまま（6より大きい要素がない場合）に表示される値です。配列には 7 と 8 があり、どちらも 6 より大きいので found は true になります。",
        "analogy": "教室に170cm以上の人がいるのに「いない」と答えてしまったようなものです。1人でもいれば found は true です。"
      },
      {
        "text": "2",
        "isCorrect": false,
        "whyWrong": "このプログラムの出力は 1 か 0 のみです。found は6より大きい要素の個数ではなく、存在するかどうかの真偽値です。",
        "analogy": "「いるかいないか」を聞いているのに「何人いるか」を答えてしまったようなものです。フラグは「ある/なし」の二択です。"
      },
      {
        "text": "8",
        "isCorrect": false,
        "whyWrong": "8 は配列の最大値ですが、このプログラムは最大値を表示するのではなく、6より大きい要素が存在するかどうかを判定しています。",
        "analogy": "「170cm以上の人がいますか？」に「180cmです」と答えてしまったようなものです。聞かれているのは存在の有無です。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"arr": "{3,7,2,8,5}", "found": false, "i": "未定義"}, "action": "found を false で初期化"},
      {"step": 2, "variables": {"found": false, "i": 0}, "action": "i=0: arr[0]=3, 3>6 は偽 → found は false のまま"},
      {"step": 3, "variables": {"found": true, "i": 1}, "action": "i=1: arr[1]=7, 7>6 は真 → found ← true"},
      {"step": 4, "variables": {"found": true, "i": 2}, "action": "i=2: arr[2]=2, 2>6 は偽 → found は true のまま"},
      {"step": 5, "variables": {"found": true, "i": 3}, "action": "i=3: arr[3]=8, 8>6 は真 → found は true のまま"},
      {"step": 6, "variables": {"found": true, "i": 4}, "action": "i=4: arr[4]=5, 5>6 は偽 → found は true のまま"},
      {"step": 7, "variables": {"found": true}, "action": "found=true なので 1 を表示"}
    ],
    "traceAnalogy": "迷子のペットを探す作業です。家中の部屋を1つずつ確認し、1部屋でもペットが見つかれば「見つけた！(true)」とフラグを立てます。一度見つけたら、残りの部屋を確認してもフラグは下がりません。",
    "overallExplanation": "フラグ変数（論理型）を使った存在判定の問題です。配列を走査し、条件に合致する要素が1つでもあれば found を true にします。フラグは一度 true になったら変わらない点がポイントです。"
  },
  {
    "questionId": "q-trace-015",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "文字列の長さカウント",
    "level": 2,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○文字列型: s\n○整数型: len, i\ns ← \"ABCDE\"\nlen ← 0\ni を 0 から 文字列長(s) - 1 まで 1 ずつ増やしながら繰り返す\n  len ← len + 1\nを繰り返す\n表示(len)",
    "choices": [
      {
        "text": "5",
        "isCorrect": true,
        "whyCorrect": "文字列 \"ABCDE\" の文字数は5です。i が 0 から 4 まで5回ループするので、len は 0+1+1+1+1+1 = 5 になります。",
        "analogy": "「ABCDE」と書かれた5文字の看板の文字を1つずつ指差して数えると、5文字です。",
        "deepDive": "文字列の長さを求めるには通常、組み込み関数（文字列長）を使いますが、このプログラムは各文字を1つずつ数えることで長さを求める基本的なアルゴリズムです。"
      },
      {
        "text": "4",
        "isCorrect": false,
        "whyWrong": "添え字は 0 から 4 ですが、ループ回数は 5 回（0,1,2,3,4）です。添え字の最大値と文字数を混同しないようにしましょう。",
        "analogy": "マンションの0階から4階まで5フロアあるのに、「最上階は4階だから4フロア」と数えてしまったようなものです。"
      },
      {
        "text": "6",
        "isCorrect": false,
        "whyWrong": "len の初期値が 1 だった場合の結果です。プログラムでは len=0 で初期化しているので、最終値は 5 です。",
        "analogy": "数え始めを1からではなく0から始めるのがプログラミングの基本です。初期値を正確に確認しましょう。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "0 は len の初期値です。ループが実行されるとlen は1ずつ増加します。文字列 \"ABCDE\" は空文字列ではないのでループは実行されます。",
        "analogy": "文字が書いてある看板なのに「何も書いていない」と答えてしまったようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"s": "ABCDE", "len": 0, "i": "未定義"}, "action": "s=\"ABCDE\", len=0 で初期化"},
      {"step": 2, "variables": {"len": 1, "i": 0}, "action": "i=0: len ← 0 + 1 = 1"},
      {"step": 3, "variables": {"len": 2, "i": 1}, "action": "i=1: len ← 1 + 1 = 2"},
      {"step": 4, "variables": {"len": 3, "i": 2}, "action": "i=2: len ← 2 + 1 = 3"},
      {"step": 5, "variables": {"len": 4, "i": 3}, "action": "i=3: len ← 3 + 1 = 4"},
      {"step": 6, "variables": {"len": 5, "i": 4}, "action": "i=4: len ← 4 + 1 = 5"},
      {"step": 7, "variables": {"len": 5, "i": 4}, "action": "ループ終了、len の値 5 を表示"}
    ],
    "traceAnalogy": "ビーズのネックレスの珠を1つずつ数える作業です。A、B、C、D、E の5つの珠を順に数えていくと、合計5つとわかります。",
    "overallExplanation": "文字列の各文字を1つずつ数えて長さを求めるプログラムです。添え字は0から始まりますが、ループの実行回数は文字数と一致します。初期値と添え字の範囲に注意しましょう。"
  },
  {
    "questionId": "q-trace-016",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "累乗計算",
    "level": 2,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: base, exp, result, i\nbase ← 3\nexp ← 4\nresult ← 1\ni を 1 から exp まで 1 ずつ増やしながら繰り返す\n  result ← result * base\nを繰り返す\n表示(result)",
    "choices": [
      {
        "text": "81",
        "isCorrect": true,
        "whyCorrect": "3の4乗を計算しています。result = 1*3*3*3*3 = 81 です。ループ4回で base=3 を4回掛けます。",
        "analogy": "1枚の紙を3倍コピーする機械に4回通すと、1→3→9→27→81枚になります。毎回3倍になるので、4回で3の4乗=81枚です。",
        "deepDive": "累乗計算の基本アルゴリズムです。result を 1 で初期化し、base を exp 回掛けることで base^exp を求めます。初期値が 1 なのは掛け算の単位元だからです。"
      },
      {
        "text": "12",
        "isCorrect": false,
        "whyWrong": "12 は base * exp = 3 * 4 の結果です。累乗(3^4)は掛け算(3*4)とは異なります。3を4回掛ける（3*3*3*3=81）のが正しい計算です。",
        "analogy": "「3を4回掛ける」と「3に4を掛ける」は違います。3×4=12 と 3^4=81 は異なる計算です。"
      },
      {
        "text": "27",
        "isCorrect": false,
        "whyWrong": "27 は 3^3 = 27 で、3回しか掛けなかった場合の値です。exp=4 なのでループは4回実行され、3を4回掛けて81になります。",
        "analogy": "コピー機に4回通すべきところを3回で止めてしまったようなものです。あと1回通す必要があります。"
      },
      {
        "text": "64",
        "isCorrect": false,
        "whyWrong": "64 は 4^3 = 64 で、base と exp を逆にした場合の値です。このプログラムは base=3 を exp=4 回掛けるので、3^4=81 です。",
        "analogy": "レシピの材料と分量を取り違えたようなものです。3を4回掛けるのであって、4を3回掛けるのではありません。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"base": 3, "exp": 4, "result": 1, "i": "未定義"}, "action": "base=3, exp=4, result=1 で初期化"},
      {"step": 2, "variables": {"result": 3, "i": 1}, "action": "i=1: result ← 1 * 3 = 3"},
      {"step": 3, "variables": {"result": 9, "i": 2}, "action": "i=2: result ← 3 * 3 = 9"},
      {"step": 4, "variables": {"result": 27, "i": 3}, "action": "i=3: result ← 9 * 3 = 27"},
      {"step": 5, "variables": {"result": 81, "i": 4}, "action": "i=4: result ← 27 * 3 = 81"},
      {"step": 6, "variables": {"result": 81, "i": 4}, "action": "ループ終了、result の値 81 を表示"}
    ],
    "traceAnalogy": "細胞分裂のイメージです。1つの細胞が毎回3つに分裂するとき、4回分裂すると1→3→9→27→81個になります。毎回3倍に増えていきます。",
    "overallExplanation": "累乗（べき乗）を求めるプログラムです。result を 1 で初期化し、ループで base を繰り返し掛けます。result の初期値が 1 である理由は、掛け算の単位元（何を掛けても値が変わらない数）だからです。"
  },
  {
    "questionId": "q-trace-017",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "二重for文（九九の一部）",
    "level": 3,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: sum, i, j\nsum ← 0\ni を 1 から 3 まで 1 ずつ増やしながら繰り返す\n  j を 1 から 3 まで 1 ずつ増やしながら繰り返す\n    sum ← sum + i * j\n  を繰り返す\nを繰り返す\n表示(sum)",
    "choices": [
      {
        "text": "36",
        "isCorrect": true,
        "whyCorrect": "i*jの全組み合わせの合計です。i=1: 1+2+3=6, i=2: 2+4+6=12, i=3: 3+6+9=18。合計 6+12+18=36 です。",
        "analogy": "3x3の九九表の左上部分の全マスを合計する作業です。1の段(1+2+3)と2の段(2+4+6)と3の段(3+6+9)を全部足すと36です。",
        "deepDive": "二重ループは外側ループの各回に対して内側ループが全回実行されます。この場合、外側3回×内側3回=計9回の掛け算が行われます。二重ループの実行回数は外側×内側で求められます。"
      },
      {
        "text": "18",
        "isCorrect": false,
        "whyWrong": "18 は i=3 のときの内側ループだけの合計（3+6+9=18）です。i=1, i=2 のときの合計も加えると 6+12+18=36 になります。",
        "analogy": "九九表の3の段だけ足して、1の段と2の段を忘れてしまったようなものです。全ての段を合計しましょう。"
      },
      {
        "text": "9",
        "isCorrect": false,
        "whyWrong": "9 は i=3, j=3 のときの i*j=9 で、最後の1回の計算結果です。sum は全9回の i*j を累積的に加算するので、最後の値だけではありません。",
        "analogy": "テストの全問の点数の合計を聞かれているのに、最後の問題の点数だけ答えてしまったようなものです。"
      },
      {
        "text": "27",
        "isCorrect": false,
        "whyWrong": "27 は 3^3=27 や他の計算結果です。二重ループの各回で i*j を加算する処理を全ステップ追跡すると 36 が正しい合計です。",
        "analogy": "計算を途中で間違えたようなものです。全9回の掛け算結果を1つずつ丁寧に足し合わせましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"sum": 0, "i": 1, "j": 1}, "action": "i=1,j=1: sum ← 0 + 1*1 = 1"},
      {"step": 2, "variables": {"sum": 3, "i": 1, "j": 2}, "action": "i=1,j=2: sum ← 1 + 1*2 = 3"},
      {"step": 3, "variables": {"sum": 6, "i": 1, "j": 3}, "action": "i=1,j=3: sum ← 3 + 1*3 = 6"},
      {"step": 4, "variables": {"sum": 8, "i": 2, "j": 1}, "action": "i=2,j=1: sum ← 6 + 2*1 = 8"},
      {"step": 5, "variables": {"sum": 12, "i": 2, "j": 2}, "action": "i=2,j=2: sum ← 8 + 2*2 = 12"},
      {"step": 6, "variables": {"sum": 18, "i": 2, "j": 3}, "action": "i=2,j=3: sum ← 12 + 2*3 = 18"},
      {"step": 7, "variables": {"sum": 21, "i": 3, "j": 1}, "action": "i=3,j=1: sum ← 18 + 3*1 = 21"},
      {"step": 8, "variables": {"sum": 27, "i": 3, "j": 2}, "action": "i=3,j=2: sum ← 21 + 3*2 = 27"},
      {"step": 9, "variables": {"sum": 36, "i": 3, "j": 3}, "action": "i=3,j=3: sum ← 27 + 3*3 = 36"},
      {"step": 10, "variables": {"sum": 36}, "action": "ループ終了、sum の値 36 を表示"}
    ],
    "traceAnalogy": "3×3のチョコレートの板があり、各マスに「行番号×列番号」個のチョコが入っています。全マスのチョコを集めて数えると36個です。外側のループが行、内側のループが列に対応します。",
    "overallExplanation": "二重for文のトレース問題です。外側ループ変数 i の各値に対して、内側ループ変数 j が全範囲を走ります。全9回の i*j の計算結果を累積加算して36が得られます。"
  },
  {
    "questionId": "q-trace-018",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "配列の最大値と位置",
    "level": 3,
    "question": "次の擬似言語プログラムを実行したとき、表示される maxPos の値は何か。",
    "pseudoCode": "○整数型の配列: arr = {5, 2, 8, 1, 6}\n○整数型: maxVal, maxPos, i\nmaxVal ← arr[0]\nmaxPos ← 0\ni を 1 から 4 まで 1 ずつ増やしながら繰り返す\n  もし arr[i] > maxVal ならば\n    maxVal ← arr[i]\n    maxPos ← i\n  を実行する\nを繰り返す\n表示(maxPos)",
    "choices": [
      {
        "text": "2",
        "isCorrect": true,
        "whyCorrect": "配列の最大値は arr[2]=8 です。走査中に arr[2]=8>5(maxVal) で maxPos=2 に更新され、以降 arr[3]=1, arr[4]=6 は 8 を超えないので maxPos=2 のままです。",
        "analogy": "マラソンの順位表で、ランナーの記録を順番に見ていき、最速タイムの選手の番号を記録します。3番目の選手（添え字2）が最速だったので、番号2が答えです。",
        "deepDive": "最大値の位置（インデックス）を求めるアルゴリズムです。最大値だけでなく、その位置も同時に記録することで、後から最大値の要素にアクセスできます。"
      },
      {
        "text": "8",
        "isCorrect": false,
        "whyWrong": "8 は最大値（maxVal）であり、最大値の位置（maxPos）ではありません。問題が表示しているのは maxPos（添え字）です。",
        "analogy": "「最速のランナーは何番目？」と聞かれているのに「タイムは8秒です」と答えてしまったようなものです。位置を聞いています。"
      },
      {
        "text": "4",
        "isCorrect": false,
        "whyWrong": "4 は配列の最後の添え字ですが、arr[4]=6 は最大値 8 より小さいため maxPos は更新されません。最後の要素が最大値とは限りません。",
        "analogy": "最後に確認した選手が必ず最速とは限りません。途中の選手のほうが速い場合もあります。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "0 は maxPos の初期値です。arr[2]=8 が arr[0]=5 より大きいため、maxPos は 2 に更新されます。初期値のまま変わらないわけではありません。",
        "analogy": "最初の選手を暫定チャンピオンにしましたが、もっと速い選手が現れたのにチャンピオンを更新しなかったようなものです。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"arr": "{5,2,8,1,6}", "maxVal": 5, "maxPos": 0}, "action": "maxVal=arr[0]=5, maxPos=0 で初期化"},
      {"step": 2, "variables": {"maxVal": 5, "maxPos": 0, "i": 1}, "action": "i=1: arr[1]=2, 2>5 は偽 → 更新なし"},
      {"step": 3, "variables": {"maxVal": 8, "maxPos": 2, "i": 2}, "action": "i=2: arr[2]=8, 8>5 は真 → maxVal=8, maxPos=2"},
      {"step": 4, "variables": {"maxVal": 8, "maxPos": 2, "i": 3}, "action": "i=3: arr[3]=1, 1>8 は偽 → 更新なし"},
      {"step": 5, "variables": {"maxVal": 8, "maxPos": 2, "i": 4}, "action": "i=4: arr[4]=6, 6>8 は偽 → 更新なし"},
      {"step": 6, "variables": {"maxVal": 8, "maxPos": 2}, "action": "ループ終了、maxPos の値 2 を表示"}
    ],
    "traceAnalogy": "クラスの成績優秀者を探す場面です。出席番号順に点数を確認し、暫定トップの点数とその出席番号を記録します。3番目(添え字2)の生徒が8点で最高だったので、出席番号2が答えです。",
    "overallExplanation": "配列から最大値とその位置を同時に求めるプログラムです。暫定最大値(maxVal)とその添え字(maxPos)を管理し、より大きい値が見つかるたびに両方を更新します。"
  },
  {
    "questionId": "q-trace-019",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "配列の逆転",
    "level": 3,
    "question": "次の擬似言語プログラムを実行した後の配列 arr の内容として正しいものはどれか。",
    "pseudoCode": "○整数型の配列: arr = {1, 2, 3, 4, 5}\n○整数型: left, right, temp\nleft ← 0\nright ← 4\nleft < right の間繰り返す\n  temp ← arr[left]\n  arr[left] ← arr[right]\n  arr[right] ← temp\n  left ← left + 1\n  right ← right - 1\nを繰り返す\n表示(arr[0])\n表示(arr[1])\n表示(arr[2])\n表示(arr[3])\n表示(arr[4])",
    "choices": [
      {
        "text": "5, 4, 3, 2, 1",
        "isCorrect": true,
        "whyCorrect": "両端から中央に向かって要素を交換していきます。1回目: arr[0]とarr[4]を交換→{5,2,3,4,1}、2回目: arr[1]とarr[3]を交換→{5,4,3,2,1}。配列が逆順になります。",
        "analogy": "5人が一列に並んでいるとき、両端の2人が場所を交換し、次にその内側の2人が交換すると、全員の並び順が逆になります。真ん中の人はそのまま動きません。",
        "deepDive": "配列の逆転は左右のポインタを中央に向かって動かしながら交換するアルゴリズムです。要素数が奇数の場合、中央の要素は交換不要です。計算量は O(n/2) = O(n) です。"
      },
      {
        "text": "5, 2, 3, 4, 1",
        "isCorrect": false,
        "whyWrong": "これは1回目の交換だけを行った状態です。left=1, right=3 の時点でまだ left<right が真なので、arr[1]とarr[3]の交換も行われます。",
        "analogy": "一列の両端だけ交換して終わりにしてしまい、内側の交換を忘れたようなものです。left<right の間は交換を続けます。"
      },
      {
        "text": "1, 2, 3, 4, 5",
        "isCorrect": false,
        "whyWrong": "これは元の配列のままで、交換が行われていない状態です。while文の条件 left<right は最初 0<4 で真なので、ループは実行されます。",
        "analogy": "並び替えの指示があったのに、誰も動かなかったようなものです。条件を確認するとループは実行されます。"
      },
      {
        "text": "5, 4, 3, 4, 5",
        "isCorrect": false,
        "whyWrong": "交換ではなく上書きしてしまった場合の誤答です。temp変数を使って正しく交換（swap）しているので、元の値は失われません。",
        "analogy": "一時保管場所(temp)を使わずに直接入れ替えようとすると値が消えますが、tempを使えば正しく交換できます。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"arr": "{1,2,3,4,5}", "left": 0, "right": 4}, "action": "初期状態"},
      {"step": 2, "variables": {"arr": "{1,2,3,4,5}", "left": 0, "right": 4}, "action": "条件判定: 0 < 4 → 真"},
      {"step": 3, "variables": {"arr": "{5,2,3,4,1}", "left": 0, "right": 4, "temp": 1}, "action": "arr[0]とarr[4]を交換: {5,2,3,4,1}"},
      {"step": 4, "variables": {"arr": "{5,2,3,4,1}", "left": 1, "right": 3}, "action": "left=1, right=3 に更新"},
      {"step": 5, "variables": {"arr": "{5,2,3,4,1}", "left": 1, "right": 3}, "action": "条件判定: 1 < 3 → 真"},
      {"step": 6, "variables": {"arr": "{5,4,3,2,1}", "left": 1, "right": 3, "temp": 2}, "action": "arr[1]とarr[3]を交換: {5,4,3,2,1}"},
      {"step": 7, "variables": {"arr": "{5,4,3,2,1}", "left": 2, "right": 2}, "action": "left=2, right=2 に更新"},
      {"step": 8, "variables": {"arr": "{5,4,3,2,1}", "left": 2, "right": 2}, "action": "条件判定: 2 < 2 → 偽 → ループ終了"},
      {"step": 9, "variables": {"arr": "{5,4,3,2,1}"}, "action": "配列の全要素を表示: 5,4,3,2,1"}
    ],
    "traceAnalogy": "本棚の5冊の本の並び順を逆にする作業です。まず左端と右端の本を交換し、次に左から2番目と右から2番目を交換します。真ん中の本は動かす必要がありません。2回の交換で逆順が完成します。",
    "overallExplanation": "配列を逆順にするアルゴリズムです。左右のポインタを両端から中央に向かって動かしながら要素を交換します。left < right が偽になった時点（ポインタが交差）でループが終了します。"
  },
  {
    "questionId": "q-trace-020",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "素数判定",
    "level": 3,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: n, i\n○論理型: isPrime\nn ← 11\nisPrime ← true\ni を 2 から n - 1 まで 1 ずつ増やしながら繰り返す\n  もし n mod i = 0 ならば\n    isPrime ← false\n  を実行する\nを繰り返す\nもし isPrime = true ならば\n  表示(1)\nそうでなければ\n  表示(0)\nを実行する",
    "choices": [
      {
        "text": "1",
        "isCorrect": true,
        "whyCorrect": "11は素数です。2から10までのどの数でも11を割り切れない（余りが0にならない）ので、isPrime は true のまま。よって 1 が表示されます。",
        "analogy": "11個のクッキーを2人、3人、4人...10人で均等に分けようとしても、どの人数でも余りが出ます。均等に分けられないということは、11は素数です。",
        "deepDive": "素数は1と自分自身以外で割り切れない2以上の整数です。この判定法は単純ですが、実際にはi*i≦nの範囲まで調べれば十分です（平方根以下の約数チェック）。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "0が表示されるのは n が素数でない場合です。11は2,3,4,...,10のいずれでも割り切れない素数なので、isPrime は true のまま 1 が表示されます。",
        "analogy": "11は「約数が1と11だけ」という素数の条件を満たしています。割り切れる数があると勘違いしていませんか？"
      },
      {
        "text": "11",
        "isCorrect": false,
        "whyWrong": "このプログラムが表示するのは n の値ではなく、素数かどうかの判定結果（1 または 0）です。",
        "analogy": "「この人は成人ですか？（はい/いいえ）」と聞かれて「25歳です」と年齢を答えてしまったようなものです。判定結果を聞いています。"
      },
      {
        "text": "true",
        "isCorrect": false,
        "whyWrong": "isPrime 自体は true ですが、表示されるのは isPrime の値ではなく、条件分岐の結果として表示(1) が実行された結果の 1 です。",
        "analogy": "内部の変数の値と、画面に表示される値は異なる場合があります。プログラムの最後まで追跡しましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"n": 11, "isPrime": true, "i": "未定義"}, "action": "n=11, isPrime=true で初期化"},
      {"step": 2, "variables": {"isPrime": true, "i": 2}, "action": "i=2: 11 mod 2 = 1 ≠ 0 → 変更なし"},
      {"step": 3, "variables": {"isPrime": true, "i": 3}, "action": "i=3: 11 mod 3 = 2 ≠ 0 → 変更なし"},
      {"step": 4, "variables": {"isPrime": true, "i": 4}, "action": "i=4: 11 mod 4 = 3 ≠ 0 → 変更なし"},
      {"step": 5, "variables": {"isPrime": true, "i": 5}, "action": "i=5: 11 mod 5 = 1 ≠ 0 → 変更なし"},
      {"step": 6, "variables": {"isPrime": true, "i": 6}, "action": "i=6: 11 mod 6 = 5 ≠ 0 → 変更なし"},
      {"step": 7, "variables": {"isPrime": true, "i": 7}, "action": "i=7: 11 mod 7 = 4 ≠ 0 → 変更なし"},
      {"step": 8, "variables": {"isPrime": true, "i": 8}, "action": "i=8: 11 mod 8 = 3 ≠ 0 → 変更なし"},
      {"step": 9, "variables": {"isPrime": true, "i": 9}, "action": "i=9: 11 mod 9 = 2 ≠ 0 → 変更なし"},
      {"step": 10, "variables": {"isPrime": true, "i": 10}, "action": "i=10: 11 mod 10 = 1 ≠ 0 → 変更なし"},
      {"step": 11, "variables": {"isPrime": true}, "action": "ループ終了、isPrime=true なので 1 を表示"}
    ],
    "traceAnalogy": "11個のビー玉を色々な人数のグループに分けてみる実験です。2人組、3人組、4人組...と試しても、どの人数でも余りなく分けられません。これは11が素数（1と自分自身でしか割れない）であることを意味します。",
    "overallExplanation": "素数判定のプログラムです。2からn-1までの全ての整数で割り切れるか確認し、1つでも割り切れたらisPrimeをfalseにします。11はどの数でも割り切れないため素数と判定されます。"
  },
  {
    "questionId": "q-trace-021",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "文字列の逆順",
    "level": 3,
    "question": "次の擬似言語プログラムを実行したとき、表示される文字列は何か。",
    "pseudoCode": "○文字列型: s, rev\n○整数型: i, len\ns ← \"EXAM\"\nlen ← 4\nrev ← \"\"\ni を len - 1 から 0 まで 1 ずつ減らしながら繰り返す\n  rev ← rev + s[i]\nを繰り返す\n表示(rev)",
    "choices": [
      {
        "text": "MAXE",
        "isCorrect": true,
        "whyCorrect": "i を 3→2→1→0 と減らしながら s[i] を rev に連結します。s[3]='M', s[2]='A', s[1]='X', s[0]='E' で rev=\"MAXE\" です。",
        "analogy": "鏡に映した文字のように、「EXAM」を右から左に読むと「MAXE」になります。1文字ずつ末尾から取り出して新しい文字列に並べていきます。",
        "deepDive": "文字列の逆転は回文判定やデータ変換でよく使われます。空文字列に末尾から1文字ずつ連結する方法が基本です。文字列の添え字も配列と同様に0始まりです。"
      },
      {
        "text": "EXAM",
        "isCorrect": false,
        "whyWrong": "元の文字列がそのまま表示されるわけではありません。i を len-1 から 0 まで逆順に走査しているので、文字列は逆順に連結されます。",
        "analogy": "巻き戻し再生なのに、通常再生の結果を答えてしまったようなものです。ループの方向に注目しましょう。"
      },
      {
        "text": "MAEX",
        "isCorrect": false,
        "whyWrong": "文字の順序が正しくありません。s[3]='M', s[2]='A', s[1]='X', s[0]='E' の順で連結されるので「MAXE」です。各添え字に対応する文字を正確に確認しましょう。",
        "analogy": "文字を並べ替える際に、途中で順番を間違えたようなものです。添え字と文字の対応を1つずつ確認しましょう。"
      },
      {
        "text": "EXMA",
        "isCorrect": false,
        "whyWrong": "添え字の対応が間違っています。s=\"EXAM\" では s[0]='E', s[1]='X', s[2]='A', s[3]='M' です。逆順は s[3],s[2],s[1],s[0] = M,A,X,E = \"MAXE\" です。",
        "analogy": "カードの位置を間違えてシャッフルしてしまったようなものです。各添え字の文字を正確に確認しましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"s": "EXAM", "rev": "", "len": 4, "i": "未定義"}, "action": "初期化"},
      {"step": 2, "variables": {"rev": "M", "i": 3}, "action": "i=3: rev ← \"\" + s[3] = \"\" + \"M\" = \"M\""},
      {"step": 3, "variables": {"rev": "MA", "i": 2}, "action": "i=2: rev ← \"M\" + s[2] = \"M\" + \"A\" = \"MA\""},
      {"step": 4, "variables": {"rev": "MAX", "i": 1}, "action": "i=1: rev ← \"MA\" + s[1] = \"MA\" + \"X\" = \"MAX\""},
      {"step": 5, "variables": {"rev": "MAXE", "i": 0}, "action": "i=0: rev ← \"MAX\" + s[0] = \"MAX\" + \"E\" = \"MAXE\""},
      {"step": 6, "variables": {"rev": "MAXE"}, "action": "ループ終了、rev の値 \"MAXE\" を表示"}
    ],
    "traceAnalogy": "本のページを最後から1枚ずつめくって、各ページの内容を新しいノートに書き写す作業です。最終ページから始めて最初のページまで進むと、内容の順番が逆になったノートができあがります。",
    "overallExplanation": "文字列を逆順にするプログラムです。空文字列 rev に対して、元の文字列の末尾から先頭に向かって1文字ずつ連結することで逆順の文字列を作成します。"
  },
  {
    "questionId": "q-trace-022",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "ユークリッドの互除法",
    "level": 3,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型: a, b, temp\na ← 48\nb ← 18\nb ≠ 0 の間繰り返す\n  temp ← b\n  b ← a mod b\n  a ← temp\nを繰り返す\n表示(a)",
    "choices": [
      {
        "text": "6",
        "isCorrect": true,
        "whyCorrect": "ユークリッドの互除法で48と18の最大公約数を求めています。48 mod 18=12 → 18 mod 12=6 → 12 mod 6=0。b=0でループ終了、a=6が最大公約数です。",
        "analogy": "48mと18mのロープを同じ長さに切り分けたいとき、最も長い単位長を求める作業です。48を18で割ると余り12、18を12で割ると余り6、12を6で割ると余り0。6mが最大の共通単位です。",
        "deepDive": "ユークリッドの互除法は最大公約数(GCD)を効率的に求めるアルゴリズムです。「大きい方を小さい方で割った余りで置き換える」を繰り返し、余りが0になったときの割る数が GCD です。紀元前300年頃のユークリッドが考案した、最古のアルゴリズムの1つです。"
      },
      {
        "text": "12",
        "isCorrect": false,
        "whyWrong": "12 は最初の余り（48 mod 18 = 12）ですが、ループはまだ続きます。b=12≠0 なので次の反復に進み、最終的に a=6 になります。",
        "analogy": "ロープの切り分け作業を1回で止めてしまったようなものです。余りが0になるまで続ける必要があります。"
      },
      {
        "text": "18",
        "isCorrect": false,
        "whyWrong": "18 は b の初期値です。ループの最初の反復で b は 48 mod 18 = 12 に更新されます。初期値がそのまま答えではありません。",
        "analogy": "作業を始める前の状態を答えてしまったようなものです。ループ内の処理を追跡しましょう。"
      },
      {
        "text": "0",
        "isCorrect": false,
        "whyWrong": "0 は最終的な b の値です。ループ終了条件は b=0 ですが、表示されるのは a の値（最大公約数=6）です。",
        "analogy": "ループが止まった理由（b=0）と、表示される値（a=6）を混同しています。表示されるのは a です。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"a": 48, "b": 18}, "action": "初期値: a=48, b=18"},
      {"step": 2, "variables": {"a": 48, "b": 18}, "action": "条件判定: b≠0 → 18≠0 → 真"},
      {"step": 3, "variables": {"a": 18, "b": 12, "temp": 18}, "action": "temp=18, b=48 mod 18=12, a=18"},
      {"step": 4, "variables": {"a": 18, "b": 12}, "action": "条件判定: b≠0 → 12≠0 → 真"},
      {"step": 5, "variables": {"a": 12, "b": 6, "temp": 12}, "action": "temp=12, b=18 mod 12=6, a=12"},
      {"step": 6, "variables": {"a": 12, "b": 6}, "action": "条件判定: b≠0 → 6≠0 → 真"},
      {"step": 7, "variables": {"a": 6, "b": 0, "temp": 6}, "action": "temp=6, b=12 mod 6=0, a=6"},
      {"step": 8, "variables": {"a": 6, "b": 0}, "action": "条件判定: b≠0 → 0≠0 → 偽 → ループ終了"},
      {"step": 9, "variables": {"a": 6}, "action": "a の値 6 を表示"}
    ],
    "traceAnalogy": "正方形のタイルで長方形の床を隙間なく敷き詰めたいとき、使える最大のタイルサイズを求める作業です。48cm×18cmの床に対して、まず18cm角を試すと余り12cm、次に12cm角を試すと余り6cm、6cm角なら余りなく敷き詰められます。最大タイルサイズは6cmです。",
    "overallExplanation": "ユークリッドの互除法は2つの整数の最大公約数(GCD)を求める有名なアルゴリズムです。a を b で割った余りで b を置き換え、b が 0 になるまで繰り返します。最後の a の値が GCD です。"
  },
  {
    "questionId": "q-trace-023",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "配列のシフト操作",
    "level": 3,
    "question": "次の擬似言語プログラムを実行した後の配列 arr の内容として正しいものはどれか。",
    "pseudoCode": "○整数型の配列: arr = {10, 20, 30, 40, 50}\n○整数型: saved, i\nsaved ← arr[0]\ni を 0 から 3 まで 1 ずつ増やしながら繰り返す\n  arr[i] ← arr[i + 1]\nを繰り返す\narr[4] ← saved\n表示(arr[0])\n表示(arr[1])\n表示(arr[2])\n表示(arr[3])\n表示(arr[4])",
    "choices": [
      {
        "text": "20, 30, 40, 50, 10",
        "isCorrect": true,
        "whyCorrect": "先頭要素を保存し、全要素を左に1つシフトし、保存した値を末尾に入れます。これは左回転（ローテーション）操作です。",
        "analogy": "回転寿司のベルトコンベアのように、先頭のお皿を取り出して一番後ろに回すと、{20,30,40,50,10}という並びになります。",
        "deepDive": "配列の回転（ローテーション）は、先頭要素を末尾に移動する左回転と、末尾要素を先頭に移動する右回転があります。このパターンはキューやリングバッファの実装で使われます。"
      },
      {
        "text": "10, 20, 30, 40, 50",
        "isCorrect": false,
        "whyWrong": "これは元の配列のままです。ループで arr[i]←arr[i+1] が実行されるため、要素は左にシフトされます。",
        "analogy": "ベルトコンベアが動いたのに、並び順が変わっていないと考えるのは間違いです。各要素が1つ左に移動します。"
      },
      {
        "text": "20, 30, 40, 50, 50",
        "isCorrect": false,
        "whyWrong": "左シフト後の最後の要素に saved=10 を代入する処理を見落としています。arr[4] ← saved で末尾に元の先頭要素 10 が入ります。",
        "analogy": "回転寿司で取り出したお皿を捨ててしまい、最後のお皿がそのまま残ったようなものです。取り出したお皿は最後に戻します。"
      },
      {
        "text": "50, 10, 20, 30, 40",
        "isCorrect": false,
        "whyWrong": "これは右回転（末尾→先頭）の結果です。このプログラムは左回転（先頭→末尾）を行っています。シフトの方向を正確に追跡しましょう。",
        "analogy": "回転の方向を逆にしてしまったようなものです。このプログラムは左方向に回転させています。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"arr": "{10,20,30,40,50}", "saved": 10}, "action": "saved ← arr[0] = 10 を保存"},
      {"step": 2, "variables": {"arr": "{20,20,30,40,50}", "i": 0}, "action": "i=0: arr[0] ← arr[1] = 20"},
      {"step": 3, "variables": {"arr": "{20,30,30,40,50}", "i": 1}, "action": "i=1: arr[1] ← arr[2] = 30"},
      {"step": 4, "variables": {"arr": "{20,30,40,40,50}", "i": 2}, "action": "i=2: arr[2] ← arr[3] = 40"},
      {"step": 5, "variables": {"arr": "{20,30,40,50,50}", "i": 3}, "action": "i=3: arr[3] ← arr[4] = 50"},
      {"step": 6, "variables": {"arr": "{20,30,40,50,10}"}, "action": "arr[4] ← saved = 10"},
      {"step": 7, "variables": {"arr": "{20,30,40,50,10}"}, "action": "配列を表示: 20,30,40,50,10"}
    ],
    "traceAnalogy": "電車の先頭車両を切り離して最後尾に連結する作業です。先頭(10)を退避させ、各車両を1つ前にずらし(20→先頭, 30→2番目...)、最後に退避させた車両(10)を最後尾に連結します。",
    "overallExplanation": "配列の左回転（ローテーション）のプログラムです。先頭要素を退避させ、全要素を1つ左にシフトし、退避した値を末尾に入れます。要素の上書きで値が失われないよう saved に保存する点がポイントです。"
  },
  {
    "questionId": "q-trace-024",
    "examType": "科目B",
    "category": "擬似言語トレース",
    "subcategory": "擬似言語トレース",
    "topic": "条件付き累計",
    "level": 3,
    "question": "次の擬似言語プログラムを実行したとき、表示される値は何か。",
    "pseudoCode": "○整数型の配列: scores = {85, 42, 73, 91, 56, 68}\n○整数型: sum, count, i\nsum ← 0\ncount ← 0\ni を 0 から 5 まで 1 ずつ増やしながら繰り返す\n  もし scores[i] ≧ 60 ならば\n    sum ← sum + scores[i]\n    count ← count + 1\n  を実行する\nを繰り返す\n表示(sum div count)",
    "choices": [
      {
        "text": "79",
        "isCorrect": true,
        "whyCorrect": "60点以上の要素は 85, 73, 91, 68 の4個です。合計=85+73+91+68=317、317 div 4=79 が表示されます。",
        "analogy": "テストで合格（60点以上）した生徒だけの平均点を求めます。合格者は85,73,91,68点の4人で、合計317点÷4人=79点（整数除算）です。",
        "deepDive": "条件付き平均の計算パターンです。sumとcountを同時に更新し、最後に sum div count で整数の平均を求めます。div（整数除算）なので小数点以下は切り捨てられます。"
      },
      {
        "text": "69",
        "isCorrect": false,
        "whyWrong": "これは全6要素の合計(85+42+73+91+56+68=415)を6で割った値(415 div 6=69)です。このプログラムは60点以上の要素だけを対象としています。",
        "analogy": "合格者だけの平均を求めるべきなのに、不合格者も含めて計算してしまったようなものです。"
      },
      {
        "text": "91",
        "isCorrect": false,
        "whyWrong": "91は配列内の最大値ですが、プログラムは条件付き平均を求めており、最大値を求めるものではありません。",
        "analogy": "「平均点は？」と聞かれて「最高点は91点です」と答えてしまったようなものです。"
      },
      {
        "text": "317",
        "isCorrect": false,
        "whyWrong": "317は60点以上の要素の合計（85+73+91+68=317）ですが、最後に sum div count で count=4 で割っています。合計ではなく平均が表示されます。",
        "analogy": "割り算の手前で止めてしまったようなものです。最後の sum div count の計算も忘れずに行いましょう。"
      }
    ],
    "traceTable": [
      {"step": 1, "variables": {"scores": "{85,42,73,91,56,68}", "sum": 0, "count": 0}, "action": "初期化"},
      {"step": 2, "variables": {"sum": 85, "count": 1, "i": 0}, "action": "i=0: scores[0]=85≧60 → sum=85, count=1"},
      {"step": 3, "variables": {"sum": 85, "count": 1, "i": 1}, "action": "i=1: scores[1]=42<60 → スキップ"},
      {"step": 4, "variables": {"sum": 158, "count": 2, "i": 2}, "action": "i=2: scores[2]=73≧60 → sum=158, count=2"},
      {"step": 5, "variables": {"sum": 249, "count": 3, "i": 3}, "action": "i=3: scores[3]=91≧60 → sum=249, count=3"},
      {"step": 6, "variables": {"sum": 249, "count": 3, "i": 4}, "action": "i=4: scores[4]=56<60 → スキップ"},
      {"step": 7, "variables": {"sum": 317, "count": 4, "i": 5}, "action": "i=5: scores[5]=68≧60 → sum=317, count=4"},
      {"step": 8, "variables": {"sum": 317, "count": 4}, "action": "sum div count = 317 div 4 = 79 を表示"}
    ],
    "traceAnalogy": "クラスのテストで60点以上の合格者だけの平均点を計算する先生の作業です。答案を1枚ずつ見て、60点以上なら合計に加えて人数も数えます。最後に合計÷人数で平均点を出します。",
    "overallExplanation": "条件付き累計と平均の計算プログラムです。配列要素のうち条件を満たすものだけの合計と個数を求め、整数除算で平均を計算します。合計だけでなく個数も条件付きでカウントする点がポイントです。"
  }]
