[
  {
    "questionId": "q-ap-031",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "マージソート",
    "level": 6,
    "question": "マージソートで要素数 n の配列をソートするときの時間計算量として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "O(n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n) は線形探索など単純な1回の走査で実現される計算量です。マージソートは分割と統合の両工程が必要なため、O(n) では収まりません。",
          "analogy": "本棚1列を端から見ていくだけなら O(n) ですが、マージソートは本棚を何度も分けて並べ直すので、それ以上の手間がかかります。"
        }
      },
      {
        "id": "b",
        "text": "O(n log n)",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "マージソートは配列を半分に分割することを繰り返すため分割深さが log n となり、各レベルで全要素の統合に O(n) かかります。掛け合わせると O(n log n) になります。これは最良・平均・最悪いずれの場合でも保証される計算量です。",
          "analogy": "本 n 冊を1冊ずつのグループに分け（log n 回の分割）、隣のグループと順序を保ちながらまとめる作業（毎回 n 冊分の比較）を繰り返すイメージです。何回まとめる段階があっても、各段階で必ず全冊確認するので n × log n の手間がかかります。",
          "deepDive": "マージソートは分割統治法の代表例です。T(n) = 2T(n/2) + O(n) という漸化式をマスター定理に当てはめると O(n log n) が導かれます。クイックソートが最悪 O(n²) になりうるのに対し、マージソートは常に O(n log n) を保証できる安定ソートです。ただし追加メモリ O(n) が必要という欠点があります。"
        }
      },
      {
        "id": "c",
        "text": "O(n²)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n²) はバブルソートや挿入ソートなど、全要素の組み合わせを比較するアルゴリズムの計算量です。マージソートはそれより効率的な分割統治法を使うため O(n²) にはなりません。",
          "analogy": "O(n²) は 100 人参加者全員が互いに1回ずつ握手する場合（100×99/2 回）のイメージです。マージソートはそこまで非効率ではありません。"
        }
      },
      {
        "id": "d",
        "text": "O(log n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(log n) は二分探索など、問題を半分に絞り込むだけで完結するアルゴリズムの計算量です。マージソートは絞り込んだ後に全要素を統合する工程があるため、O(log n) では足りません。",
          "analogy": "辞書で単語を見つけるだけなら O(log n) ですが、バラバラのページを順番通りに並べ直す作業が加わると、それ以上の手間が必要です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "マージソートの時間計算量は O(n log n) であり、最良・平均・最悪のすべてのケースで保証されます。",
      "keyPoint": "分割深さ log n と各レベルの統合コスト O(n) を掛け合わせて O(n log n) と覚えましょう。",
      "relatedTopics": ["クイックソート", "ヒープソート", "分割統治法", "安定ソート"],
      "studyTip": "主要なソートアルゴリズムの計算量を表にまとめて比較すると整理しやすいです。バブル O(n²)、マージ O(n log n)、クイック 平均 O(n log n) 最悪 O(n²) という対比で覚えましょう。"
    },
    "tags": ["マージソート", "時間計算量", "分割統治法", "安定ソート"]
  },
  {
    "questionId": "q-ap-032",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "マージソート",
    "level": 6,
    "question": "マージソートの「統合（マージ）」フェーズについて正しく説明しているものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "2つのソート済みの部分配列を先頭から比較しながら1つのソート済み配列に結合する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "マージフェーズでは、それぞれがソート済みの2つの部分配列の先頭要素を比較し、小さい方を結果配列に移す操作を繰り返します。どちらかが空になったら残りをそのまま追加します。この操作により O(n) で2つのソート済み列を1つに統合できます。",
          "analogy": "2列に並んだ人が身長順に並んでいるとき、両列の先頭同士を比べて低い方から新しい列に移していくイメージです。両列がソート済みなので、先頭だけ比べれば次に並べる人が必ず決まります。",
          "deepDive": "この統合操作が O(n) で完了することがマージソート全体の O(n log n) を支えています。また、同じ値の要素の相対順序が保たれるため、マージソートは安定ソートとして分類されます。"
        }
      },
      {
        "id": "b",
        "text": "ピボットを選び、それより小さい要素と大きい要素に分けて再帰的にソートする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはクイックソートの説明です。マージソートの分割はピボットを使わず、単純に配列の中央で半分に分けます。",
          "analogy": "クイックソートは「だいたい真ん中の人より背の高い/低い人で2列に分ける」作業、マージソートは「まず機械的に前半・後半で分ける」作業です。"
        }
      },
      {
        "id": "c",
        "text": "未ソートの部分配列から最小値を選んで先頭に移動させることを繰り返す",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは選択ソートの説明です。マージソートのマージフェーズは既にソートされた2つの列を合わせる操作であり、全体から最小値を探す操作とは異なります。",
          "analogy": "選択ソートは毎回残り全員の中から一番低い人を探す作業ですが、マージソートのマージは2つのソート済み列の先頭だけ比べればよいので効率的です。"
        }
      },
      {
        "id": "d",
        "text": "隣接する要素を比較し、順序が逆なら交換することを繰り返す",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはバブルソートの説明です。マージソートのマージフェーズは既にソート済みの2つの配列を結合するため、隣接要素の交換は行いません。",
          "analogy": "バブルソートは泡が浮かぶように隣同士を入れ替える作業ですが、マージソートのマージは2本の整理済みレーンを1本に合流させる高速な作業です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "マージソートのマージフェーズは、2つのソート済み部分配列の先頭を順番に比較しながら1つの配列に統合する O(n) の操作です。",
      "keyPoint": "「ソート済みの列を統合する」という点がポイントです。ソート済みだから先頭の比較だけで済み、効率的です。",
      "relatedTopics": ["クイックソート", "選択ソート", "バブルソート", "安定ソート"],
      "studyTip": "マージソートの動作を手で追うときは、小さな配列（4〜8要素）で実際に分割と統合を紙に書いてみると理解が深まります。"
    },
    "tags": ["マージソート", "マージフェーズ", "安定ソート", "分割統治法"]
  },
  {
    "questionId": "q-ap-033",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "クイックソート",
    "level": 6,
    "question": "クイックソートで最悪の時間計算量 O(n²) になりやすい状況として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "配列がランダムな順序で与えられたとき",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ランダムな順序のデータはクイックソートが最も得意とするケースです。ピボットが平均的に中央付近の値になりやすく、分割が均等になるため平均 O(n log n) で動作します。",
          "analogy": "ランダムに並んだカードからピボットを1枚引くと、だいたい真ん中の強さのカードが選ばれやすく、うまく2分割できます。"
        }
      },
      {
        "id": "b",
        "text": "配列がすでにソート済み、または逆順でソートされているとき",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "クイックソートで先頭や末尾の要素をピボットとする実装では、すでにソート済みの配列の場合、毎回ピボットが最小値（または最大値）になります。その結果、分割が極端に偏り（1要素と n-1 要素に分割）、再帰の深さが n になって O(n²) になります。",
          "analogy": "身長順に並んだクラスで「一番左の人をピボットにして背の高い/低いグループに分ける」ルールにすると、一番左が常に最短なので毎回「自分だけ」と「残り全員」に分かれてしまい、全然効率的でありません。",
          "deepDive": "この問題への対策として「三数のメジアン法（先頭・中央・末尾の3要素のうち中間値をピボットにする）」や「ランダムピボット選択」が使われます。また Python の sorted() や Java の Arrays.sort() はクイックソートをベースにしながらもこれらの最悪ケース対策を組み込んでいます。"
        }
      },
      {
        "id": "c",
        "text": "配列の要素数が奇数のとき",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "要素数が奇数か偶数かはクイックソートの計算量に影響しません。計算量を左右するのはピボット選択の良し悪し、すなわち分割の均等さです。",
          "analogy": "グループ分けのうまさは人数の奇偶ではなく、基準になる人をどう選ぶかで決まります。"
        }
      },
      {
        "id": "d",
        "text": "配列に重複した要素が多数含まれるとき",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "重複要素の多いデータが最悪ケースに直結するわけではありません。ただし三方向分割（Dutch National Flag 問題）を使わない実装では効率が落ちる場合があります。最悪 O(n²) の直接の原因は「ピボットが常に最大値または最小値になること」です。",
          "analogy": "同じ強さのカードが多い場合は困ることもありますが、一番の問題はピボット（基準）が毎回端っこの強さになることです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "クイックソートは平均 O(n log n) ですが、ピボットが常に最大値または最小値になる場合（ソート済み・逆順のデータに先頭・末尾ピボットを使う場合など）は最悪 O(n²) になります。",
      "keyPoint": "クイックソートの性能はピボット選択に大きく依存します。均等に分割できれば高速、偏れば低速になります。",
      "relatedTopics": ["マージソート", "ピボット選択", "三数のメジアン法", "ランダムピボット"],
      "studyTip": "クイックソートの最悪ケースは試験頻出です。「すでにソート済みのデータ＋先頭ピボット」の組み合わせが最悪 O(n²) になる具体的なシナリオとして覚えておきましょう。"
    },
    "tags": ["クイックソート", "時間計算量", "最悪ケース", "ピボット選択"]
  },
  {
    "questionId": "q-ap-034",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "クイックソート",
    "level": 6,
    "question": "クイックソートの「三数のメジアン法（median-of-three）」によるピボット選択の説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "配列の先頭・中央・末尾の3要素の中央値をピボットとして選ぶ手法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "三数のメジアン法は配列の先頭・中央・末尾の3つの要素を取り出し、その中央値（三つの中で大きさが真ん中のもの）をピボットとして採用します。これにより、すでにソート済みや逆順のデータでも偏った分割を避けられ、最悪ケースの頻度を大幅に減らすことができます。",
          "analogy": "3人の審査員の採点の平均ではなく「中間点を出した審査員の点を使う」ルールに似ています。一人が極端に高かったり低かったりしても、真ん中の人の点を選べば極端にはなりません。",
          "deepDive": "この手法は完全にランダムなピボット選択よりも実用的で、現実的なデータ（ほぼソート済みのデータなど）に対して特に有効です。GCC の std::sort や多くの実用ライブラリで採用されています。O(n²) を完全に排除はできませんが、発生確率を大幅に低下させます。"
        }
      },
      {
        "id": "b",
        "text": "配列全体の中央値を求めてピボットとして選ぶ手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "配列全体の中央値を正確に求めるには O(n) または O(n log n) の追加コストがかかり、ソート全体の効率が下がります。三数のメジアン法は3要素だけを見るため O(1) で済む点が重要です。",
          "analogy": "全員の身長を計って真ん中を探すのは大変ですが、3人だけ選んでその中間を使うのは素早く済みます。"
        }
      },
      {
        "id": "c",
        "text": "ランダムに3つの要素を選び、その平均値をピボットとして選ぶ手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "三数のメジアン法は平均値ではなく中央値（メジアン）を使います。また、ランダム選択ではなく先頭・中央・末尾という決まった位置から3要素を選びます。",
          "analogy": "3人の得点の「平均」を基準にするのではなく、「真ん中の得点を持つ人」を基準にするのが中央値（メジアン）の考え方です。"
        }
      },
      {
        "id": "d",
        "text": "配列を3等分してそれぞれの先頭要素をピボット候補とする手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "三数のメジアン法は配列を3等分するわけではありません。先頭・中央・末尾の3か所から1要素ずつ取り出して中央値を求めます。分割数や3等分とは関係がありません。",
          "analogy": "本棚の「最初・真ん中・最後」の本を3冊取り出して真ん中の厚さの本を基準にするのが三数のメジアン法です。棚を3区間に分けるわけではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "三数のメジアン法は、配列の先頭・中央・末尾の3要素の中央値をピボットに選ぶことで、クイックソートの最悪ケースの発生を抑える実用的な手法です。",
      "keyPoint": "3要素の「中央値（メジアン）」を選ぶことで、極端なピボットになりにくくなります。",
      "relatedTopics": ["クイックソート", "ランダムピボット", "最悪ケース対策", "時間計算量"],
      "studyTip": "ピボット選択の手法（先頭固定・ランダム・三数メジアン）の違いと、それぞれの最悪ケース発生リスクをセットで覚えておきましょう。"
    },
    "tags": ["クイックソート", "ピボット選択", "三数のメジアン法", "最悪ケース対策"]
  },
  {
    "questionId": "q-ap-035",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "ハッシュ法と衝突解決",
    "level": 6,
    "question": "ハッシュ表における衝突（コリジョン）の解決方法として「チェイン法（連鎖法）」の説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "衝突した要素を、次の空きバケットに順番に格納していく方法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはオープンアドレス法（特に線形探索法）の説明です。チェイン法はバケット内部に連結リストを持ち、衝突した要素をそのリストに追加します。",
          "analogy": "駐車場で「この区画が埋まっていたら次の区画を探す」のがオープンアドレス法、「この区画に縦列駐車できるスペースを延ばす」のがチェイン法です。"
        }
      },
      {
        "id": "b",
        "text": "同じハッシュ値を持つ要素を連結リストでつないで管理する方法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "チェイン法（連鎖法）では、ハッシュ表の各バケットがリストの先頭ポインタを持ちます。同じハッシュ値（バケット番号）を持つ要素が複数あった場合、そのバケットから始まる連結リストに追加していきます。探索時は該当バケットのリストを線形探索します。",
          "analogy": "図書館の書棚（バケット）に収まりきらない本を、その書棚から延びる追加シェルフ（連結リスト）に積んでいくイメージです。同じジャンルの本が増えてもシェルフを延ばせばよく、他のジャンルに影響しません。",
          "deepDive": "チェイン法の利点は、テーブルの充填率が高くなっても性能劣化がオープンアドレス法より緩やかなことです。負荷率（格納要素数 / バケット数）が 1 を超えても動作できます。欠点は各バケットにポインタを持つためメモリオーバーヘッドがあることと、キャッシュ効率がやや低いことです。"
        }
      },
      {
        "id": "c",
        "text": "衝突が起きたら別のハッシュ関数で再計算して空きバケットを見つける方法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはダブルハッシュ法（二重ハッシュ法）の説明です。オープンアドレス法の一種であり、チェイン法とは別の仕組みです。チェイン法は別のバケットを探すのではなく、同じバケットにリストを伸ばして対処します。",
          "analogy": "衝突のたびに別の駐車場を探しに行くのがダブルハッシュ法、同じ駐車場内で縦列駐車できるよう区画を広げるのがチェイン法です。"
        }
      },
      {
        "id": "d",
        "text": "衝突が起きたらハッシュ表のサイズを2倍に拡張して全要素を再配置する方法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはリハッシュ（動的ハッシュ）の説明であり、チェイン法ではありません。リハッシュは充填率が一定値を超えたときに実行されることがありますが、衝突の「解決方法」というよりも「テーブル拡張の仕組み」です。",
          "analogy": "駐車場がいっぱいになったら駐車場全体を2倍に増築して車を配置し直すのはリハッシュ、チェイン法はいっぱいになった区画に縦列で続けて停める仕組みです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "チェイン法は各バケットに連結リストを持ち、同じハッシュ値の要素をリストに追加することで衝突を解決します。オープンアドレス法と並ぶ代表的な衝突解決手法です。",
      "keyPoint": "チェイン法 ＝「バケット内でリストを伸ばす」、オープンアドレス法 ＝「別のバケットを探す」という対比を押さえましょう。",
      "relatedTopics": ["オープンアドレス法", "ダブルハッシュ法", "線形探索法", "負荷率"],
      "studyTip": "チェイン法とオープンアドレス法の特徴（メモリ使用量、充填率との関係、実装のしやすさ）を比較表で整理すると試験対策になります。"
    },
    "tags": ["ハッシュ法", "衝突解決", "チェイン法", "連鎖法", "連結リスト"]
  },
  {
    "questionId": "q-ap-036",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "ハッシュ法と衝突解決",
    "level": 6,
    "question": "ハッシュ表の負荷率（ロードファクター）について正しく説明しているものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "負荷率は「バケット数 ÷ 格納要素数」で求められ、1.0 に近いほど性能がよい",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "計算式が逆です。負荷率は「格納要素数 ÷ バケット数」で求められます。また 1.0 に近いほど衝突が増えて性能が低下するため、実運用では 0.7〜0.8 以下に保つことが推奨されます。",
          "analogy": "駐車場の混み具合は「空き区画 ÷ 車の台数」ではなく「車の台数 ÷ 総区画数」で表します。満車（1.0）に近いほど入庫しにくくなります。"
        }
      },
      {
        "id": "b",
        "text": "負荷率は「格納要素数 ÷ バケット数」で求められ、高くなるほど衝突の頻度が増える",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "負荷率（ロードファクター）= 格納要素数 n / バケット数 m で定義されます。負荷率が低いほどバケットに空きが多く衝突しにくいですが、メモリ効率は下がります。逆に負荷率が高くなるほど衝突頻度が増えて探索・挿入の効率が低下します。一般的に 0.7〜0.8 を閾値として動的にリサイズする実装が多いです。",
          "analogy": "60席の映画館（バケット数）に 42 人（格納要素数）が入ると負荷率は 0.7（70%）です。席が埋まるほど他の客と隣り合わせ（衝突）になりやすくなります。",
          "deepDive": "Java の HashMap はデフォルトの負荷率を 0.75 に設定しています。負荷率が 0.75 を超えると内部配列を2倍に拡張して全要素をリハッシュします。Python の dict も同様の動的拡張を行い、これによって平均 O(1) の探索性能を維持しています。"
        }
      },
      {
        "id": "c",
        "text": "負荷率は常に 0 以上 1 以下の範囲に収まる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "チェイン法を使ったハッシュ表では、1つのバケットに複数の要素を格納できるため負荷率が 1 を超えることがあります。オープンアドレス法では 1 以下に制限されます。",
          "analogy": "縦列駐車（チェイン法）が許されている駐車場なら、区画数より多くの車が停まれるので「駐車率」が 1 を超えることがあります。"
        }
      },
      {
        "id": "d",
        "text": "負荷率が低いほど衝突頻度が高くなり、探索効率が低下する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "逆です。負荷率が低い（バケットに余裕がある）ほど衝突は起きにくく、探索効率は高くなります。負荷率が高い（バケットが混雑している）ほど衝突が多くなり効率が低下します。",
          "analogy": "駐車場がガラガラ（低負荷率）なら好きな場所に停めやすく、満車近く（高負荷率）になるほど空き探しに時間がかかります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "負荷率 = 格納要素数 ÷ バケット数。高いほど衝突が増えて性能が低下するため、実用上は 0.7〜0.8 程度を上限にリサイズすることが多いです。",
      "keyPoint": "「格納数 ÷ バケット数」という計算式と、「高いほど衝突増・性能低下」という関係をセットで覚えましょう。",
      "relatedTopics": ["ハッシュ関数", "チェイン法", "オープンアドレス法", "リハッシュ"],
      "studyTip": "負荷率の概念は Java の HashMap など現実のデータ構造の設計に直結します。負荷率と性能の関係をグラフで描いてみると直感的に理解できます。"
    },
    "tags": ["ハッシュ法", "負荷率", "ロードファクター", "衝突", "性能"]
  },
  {
    "questionId": "q-ap-037",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "木構造の走査",
    "level": 7,
    "question": "次の二分木を前順（pre-order）で走査した結果として正しいものはどれか。\n\n      A\n     / \\\n    B   C\n   / \\\n  D   E",
    "choices": [
      {
        "id": "a",
        "text": "A, B, D, E, C",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "前順（pre-order）は「根 → 左部分木 → 右部分木」の順に再帰的に訪問します。この木では：A（根）→ B（左子）→ D（B の左子）→ E（B の右子）→ C（A の右子）となります。「根を先に訪問する」のが前順の特徴です。",
          "analogy": "会社の組織図で「社長 → 部長 → 課長」の順に名簿を作るようなイメージです。上位（根）のメンバーを先に書き出して、その後に下位の組織を展開していきます。",
          "deepDive": "前順走査（pre-order traversal）は木のコピーや木構造をファイルに保存・復元する際に利用されます。根を最初に処理することで、木を再現するのに必要な情報（構造）を先に確保できるためです。"
        }
      },
      {
        "id": "b",
        "text": "D, B, E, A, C",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは中順（in-order）走査の結果です。中順は「左部分木 → 根 → 右部分木」の順に訪問します。D（左）→ B（根）→ E（右）→ A（全体根）→ C（右）となります。",
          "analogy": "中順は「子供が先、親が後」のイメージです。組織図なら末端の社員を先に並べ、最後に社長を書く形になります。"
        }
      },
      {
        "id": "c",
        "text": "D, E, B, C, A",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは後順（post-order）走査の結果です。後順は「左部分木 → 右部分木 → 根」の順に訪問します。D → E → B → C → A となります。",
          "analogy": "後順は「すべての子供が先に片付いてから親が登場」するイメージです。組織図なら全員の業績を集計してから最後に社長が承認する流れに似ています。"
        }
      },
      {
        "id": "d",
        "text": "A, C, B, E, D",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは前順でも中順でも後順でもない誤った順序です。前順の訪問順序は「根 → 左 → 右」ですので、根 A の次は左の B であり、C は A の右の部分木として最後に訪問します。",
          "analogy": "組織図を「社長 → 右の部長 → 左の部長」の順に書いてしまうと、決めたルール（左から）に反します。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "前順（pre-order）走査は「根 → 左 → 右」の順序で再帰的に訪問します。この木の場合は A → B → D → E → C です。",
      "keyPoint": "前順（pre）は根が「前」、中順（in）は根が「中」、後順（post）は根が「後」に訪問されると覚えましょう。",
      "relatedTopics": ["中順走査", "後順走査", "二分探索木", "深さ優先探索"],
      "studyTip": "具体的な木の図を描いて3種類の走査を全部書き出す練習をするのが確実です。問題を見たら「pre：根が先、in：根が中、post：根が最後」と唱えながら手を動かしましょう。"
    },
    "tags": ["木構造", "前順走査", "pre-order", "深さ優先探索", "二分木"]
  },
  {
    "questionId": "q-ap-038",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "木構造の走査",
    "level": 7,
    "question": "二分探索木（BST）を中順（in-order）で走査したとき、訪問される順序の特徴として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "要素が挿入された順序で訪問される",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "中順走査は挿入順序ではなく、木の構造（左・根・右）に基づいて訪問します。挿入順序を保持するデータ構造は連結リストや配列です。",
          "analogy": "本を本棚にバラバラに並べた後、タイトルのアルファベット順に取り出す操作が中順走査です。入れた順番で取り出すのとは違います。"
        }
      },
      {
        "id": "b",
        "text": "要素が昇順で訪問される",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "二分探索木（BST）の性質として、任意のノードに対して「左部分木のすべての値 < 根の値 < 右部分木のすべての値」が成り立ちます。中順走査は「左 → 根 → 右」なので、この BST の性質と組み合わさって要素が昇順に訪問されます。これは BST をソート済み配列に変換する基本操作として利用されます。",
          "analogy": "本棚が「著者名の五十音順で、左の棚は『あ行』より前、右の棚は後」というルールで整理されている場合、左端から右端に向かって本を取り出すと自動的に五十音順になります。",
          "deepDive": "この性質を利用して BST から k番目に小さい要素を O(k + 木の高さ) で取得したり、範囲クエリ（a 以上 b 以下の全要素を返す）を効率的に処理したりできます。平衡 BST（AVL木、赤黒木）を使えば O(log n) で挿入・削除・探索が保証されます。"
        }
      },
      {
        "id": "c",
        "text": "要素が降順で訪問される",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "中順走査は昇順です。降順で訪問させたい場合は「右 → 根 → 左」の逆中順（reverse in-order）走査を使います。",
          "analogy": "本棚を左から右に取り出せば五十音順（昇順）、右から左に取り出せば逆順（降順）になります。中順走査は左→右の通常方向です。"
        }
      },
      {
        "id": "d",
        "text": "最も深いノードから順に訪問される",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "深さを基準に訪問する走査は幅優先探索（BFS）や深さ優先探索（DFS）の特定の実装ですが、中順走査は深さではなく「左・根・右」という木の構造の位置関係に基づいて訪問します。",
          "analogy": "書棚の段の深さ（1段目、2段目…）ではなく、横の並び順（左→中→右）で本を取り出すのが中順走査のイメージです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "二分探索木を中順（in-order）走査すると要素が昇順に訪問されます。これは BST の「左 < 根 < 右」という性質と「左 → 根 → 右」という中順の組み合わせによる特徴です。",
      "keyPoint": "BST の中順走査 ＝ 昇順ソート済み出力。試験頻出の性質です。",
      "relatedTopics": ["二分探索木", "前順走査", "後順走査", "AVL木", "ソート"],
      "studyTip": "BST に要素を挿入して中順走査すると昇順になる性質はソートアルゴリズム（木ソート）にも応用されます。具体的な数値の BST で手を動かして確認しましょう。"
    },
    "tags": ["二分探索木", "中順走査", "in-order", "ソート", "昇順"]
  },
  {
    "questionId": "q-ap-039",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "ヒープソート",
    "level": 7,
    "question": "ヒープソートの説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "最大ヒープを構築し、根と末尾の要素を交換しながらソートする手法で、時間計算量は常に O(n log n) である",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ヒープソートは①全要素で最大ヒープ（親 ≥ 子を満たすヒープ）を構築し（O(n)）、②根（最大値）をヒープの末尾と交換して取り出し、残りの要素でヒープ性質を修復（O(log n)）する操作を n-1 回繰り返します。合計 O(n) + O(n log n) = O(n log n) です。最良・平均・最悪すべてで O(n log n) が保証されます。",
          "analogy": "大きい人を先頭に並べたグループ（最大ヒープ）から先頭の人を取り出して列の末尾に移し、残りの人で再び先頭を大きい人に整え直す作業を繰り返すイメージです。毎回先頭に最大の人が来るよう整えるコストが log n です。",
          "deepDive": "ヒープソートはインプレース（追加メモリ O(1)）であり、最悪でも O(n log n) という点でクイックソートより理論的に優れています。ただし実際のキャッシュ効率はクイックソートより劣るため、実用的な速度はクイックソートの方が速いことが多いです。また安定ソートではないという点も覚えておきましょう。"
        }
      },
      {
        "id": "b",
        "text": "最小ヒープを構築し、根から順に要素を取り出すと降順のソート結果が得られる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "最小ヒープの根は最小値なので、根から順に取り出すと昇順の結果が得られます（降順ではありません）。また一般的なヒープソートは最大ヒープを使います。",
          "analogy": "一番軽い荷物を常に取り出せるタワー（最小ヒープ）から順番に取り出すと、軽い順（昇順）に並びます。重い順（降順）にしたければ最大ヒープを使います。"
        }
      },
      {
        "id": "c",
        "text": "ヒープソートは安定ソートであり、同じ値の要素の相対順序が保たれる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ヒープソートは不安定ソートです。ヒープの構築・修復の過程で同じ値の要素の相対順序が入れ替わることがあります。安定ソートの代表例はマージソートや挿入ソートです。",
          "analogy": "グループの中から「一番大きい人を取り出す」操作を繰り返すと、同じ身長の人同士がどちらが先に取り出されるかは保証されません。"
        }
      },
      {
        "id": "d",
        "text": "ヒープソートの時間計算量は平均 O(n log n)、最悪 O(n²) である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ヒープソートは最悪でも O(n log n) が保証されます。最悪 O(n²) になるのはクイックソート（適切なピボット選択をしない場合）です。ヒープソートの全ケース O(n log n) 保証がクイックソートに対する理論的優位点の一つです。",
          "analogy": "ヒープソートは毎回「グループの最大を見つける」という操作の効率が常に log n で安定しているため、最悪でも O(n log n) が崩れません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ヒープソートは最大ヒープを使い、根の最大値を末尾と交換しながらソートする手法です。時間計算量は最良・平均・最悪すべて O(n log n)、追加メモリ O(1) ですが不安定ソートです。",
      "keyPoint": "ヒープソートの特徴：常に O(n log n)、インプレース、不安定ソート。マージソートとの対比で覚えましょう（マージは安定だが O(n) 追加メモリが必要）。",
      "relatedTopics": ["最大ヒープ", "優先度付きキュー", "マージソート", "クイックソート", "安定ソート"],
      "studyTip": "ソートアルゴリズムを「安定/不安定」「インプレース/追加メモリ必要」「最悪計算量」の3軸で比較表を作ると試験に強くなります。"
    },
    "tags": ["ヒープソート", "最大ヒープ", "時間計算量", "インプレース", "不安定ソート"]
  },
  {
    "questionId": "q-ap-040",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "グラフの探索（BFS応用）",
    "level": 7,
    "question": "幅優先探索（BFS）を使って解くのに最も適した問題はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "迷路において、スタートからゴールまでの最短経路を求める",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "BFS（幅優先探索）は隣接するノードを順番に探索するため、重みなしグラフ（各辺のコストが等しい場合）における最短経路を確実に見つけることができます。BFS がゴールに初めて到達したとき、その経路がスタートからゴールへの最短経路です。迷路問題は重みなしグラフとして表現できるため BFS が最適です。",
          "analogy": "水面に石を投げると同心円状に波紋が広がるように、BFS もスタート地点から距離1、距離2…と均等に探索を広げていきます。最初にゴールに到達した波紋の半径が最短距離です。",
          "deepDive": "BFS が最短経路を保証できるのは、キュー（FIFO）を使って距離の小さいノードから処理するためです。辺にコスト（重み）がある場合は BFS の代わりにダイクストラ法を使います。BFS の時間計算量は O(V + E)（V はノード数、E は辺数）です。"
        }
      },
      {
        "id": "b",
        "text": "ファイルシステムのディレクトリ階層を深い順に列挙する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "深い順に列挙するには深さ優先探索（DFS）が適しています。BFS は「浅い（スタートに近い）ノードから順に探索する」性質を持つため、深さ優先ではなく幅優先です。",
          "analogy": "ディレクトリを一番奥まで潜ってから戻るのが DFS（木の幹を根から葉まで一気に進む）、各階層を一通り見渡してから次の深さに進むのが BFS です。"
        }
      },
      {
        "id": "c",
        "text": "数式の括弧の対応関係を検証する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "括弧の対応関係はスタック（LIFO）を使って解くのが適しています。開き括弧をスタックに積み、閉じ括弧が来たらポップして対応を確認します。BFS はグラフの探索に使う手法です。",
          "analogy": "かっこの対応確認はお皿の積み重ね（スタック）で管理するイメージです。BFS の波紋を使う必要はありません。"
        }
      },
      {
        "id": "d",
        "text": "再帰的なフィボナッチ数列の計算を高速化する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "フィボナッチ数列の高速化には動的計画法（メモ化）が適しています。BFS は無関係です。再帰的計算の重複を排除して O(n) で計算できます。",
          "analogy": "計算済みの答えを手帳（メモ）に書いておいて同じ問いが来たら手帳を見るのが動的計画法です。探索の波紋（BFS）は別の問題に使う道具です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "BFS は重みなしグラフの最短経路問題に最も適したアルゴリズムです。スタートから距離順にノードを探索するため、最初にゴールに到達したとき必ず最短経路です。",
      "keyPoint": "BFS ＝ 最短経路（重みなし）、DFS ＝ 全経路探索や深さ優先が必要な問題、という使い分けを押さえましょう。",
      "relatedTopics": ["深さ優先探索（DFS）", "ダイクストラ法", "グラフ理論", "キュー"],
      "studyTip": "BFS はキュー（FIFO）を使い、DFS はスタック（LIFO）または再帰を使うという実装の違いも試験で問われます。両方の実装をコードで書いてみると定着します。"
    },
    "tags": ["BFS", "幅優先探索", "最短経路", "グラフ探索", "キュー"]
  },
  {
    "questionId": "q-ap-041",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "グラフの探索（DFS応用）",
    "level": 7,
    "question": "深さ優先探索（DFS）を使ってグラフのトポロジカルソートを行うことの説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "閉路（サイクル）を持つ有向グラフでも、必ずトポロジカルソートの結果が得られる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "トポロジカルソートは有向非巡回グラフ（DAG）にのみ適用できます。閉路があるグラフにはトポロジカル順序が存在しないため、DFS を使ってもトポロジカルソートは成立しません。",
          "analogy": "「A が終わったら B を始める」「B が終わったら C を始める」「C が終わったら A を始める」という作業指示には順序が成立しません。ループがある計画はスタート地点が決められません。"
        }
      },
      {
        "id": "b",
        "text": "DFS でノードを完全に訪問し終えた（出る）順に並べ、逆順にするとトポロジカル順序が得られる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "DFS ベースのトポロジカルソートでは、各ノードへの訪問を再帰で深く進め、そのノードから出るすべての辺の先のノードを処理し終えた後にそのノードをスタックに積みます。最終的にスタックをポップした順序がトポロジカル順序になります。これは「出る順の逆順」と等価です。",
          "analogy": "料理の準備を「材料の下準備が終わってから鍋に入れる、鍋が煮立ったら盛り付ける」の順に進めるとき、最後に完了する作業（盛り付け）が最初にスタックから出てきます。逆順にすると「最初にすべき作業」から並びます。",
          "deepDive": "DFS によるトポロジカルソートの時間計算量は O(V + E) です。同じ問題を BFS を使って解く手法は Kahn's アルゴリズム（入次数 0 のノードをキューに入れる方法）と呼ばれます。どちらも DAG にのみ適用でき、閉路検出にも使えます。"
        }
      },
      {
        "id": "c",
        "text": "DFS で最初に訪問したノードから順に並べるとトポロジカル順序が得られる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「最初に訪問した順」ではなく「訪問が完了した（出た）順の逆順」がトポロジカル順序です。最初に訪問したノードは依存先（前提となるノード）よりも先に見つかることが多く、そのまま順序にはなりません。",
          "analogy": "料理の指示書を読み始めた順（訪問順）ではなく、すべての手順を終えた順の逆順が正しい作業手順になります。"
        }
      },
      {
        "id": "d",
        "text": "BFS でトポロジカルソートを行う場合と比べると、DFS の方が常に少ない計算コストで結果が得られる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "DFS ベースと BFS ベース（Kahn's アルゴリズム）のトポロジカルソートは、どちらも O(V + E) であり計算コストは同等です。状況や実装の好みによって使い分けますが、一方が常に優れているわけではありません。",
          "analogy": "レシピを「材料から追う方法（DFS）」と「工程の入次数から追う方法（BFS/Kahn）」で整理する手間はどちらも同程度です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "DFS によるトポロジカルソートは、ノードから「出る」ときにスタックに積み、最後にスタックをポップすることで依存順序（トポロジカル順序）を得ます。DAG にのみ適用可能です。",
      "keyPoint": "「出る順の逆順 ＝ トポロジカル順序」という DFS トポロジカルソートの核心を押さえましょう。",
      "relatedTopics": ["幅優先探索（BFS）", "Kahn's アルゴリズム", "有向非巡回グラフ（DAG）", "閉路検出"],
      "studyTip": "タスクのスケジューリングやコンパイルの依存関係など、現実問題への応用例を考えながら学ぶとトポロジカルソートの有用性が理解しやすくなります。"
    },
    "tags": ["DFS", "深さ優先探索", "トポロジカルソート", "DAG", "グラフ探索"]
  },
  {
    "questionId": "q-ap-042",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "ヒープソート",
    "level": 7,
    "question": "配列 [4, 10, 3, 5, 1] を最大ヒープとして構築したとき、根（配列インデックス 0）に来る値として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "4",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "4 は元の配列の先頭ですが、最大ヒープの構築では「親が子以上」という性質を満たすように要素を並べ替えます。4 より大きい要素があるため、4 が根にはなりません。",
          "analogy": "一番高い台（根）には一番背が高い人が立ちます。4 は一番背が高くないので台に立てません。"
        }
      },
      {
        "id": "b",
        "text": "10",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "最大ヒープの性質は「任意のノードの値が、その子のノードの値以上である」ことです。したがって根（最上位）には配列全体の最大値が来ます。配列 [4, 10, 3, 5, 1] の最大値は 10 なので、最大ヒープ構築後の根は 10 です。実際のヒープ構築後の配列は [10, 5, 3, 4, 1] などになります。",
          "analogy": "会社のヒエラルキーで「自分は必ず部下より偉い」ルールを守ると、一番上（根）には全社員の中で最も偉い人（最大値 10）が来ます。",
          "deepDive": "最大ヒープの構築アルゴリズムは後ろから前に向かって各ノードに対して「ヒープ性質の修復（sift-down）」を行います。この操作の計算量は O(n) です（各ノードで O(log n) かかるように見えますが、下位ノードの方が多く sift-down の距離が短いため合計 O(n) になります）。"
        }
      },
      {
        "id": "c",
        "text": "1",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1 は配列の最小値です。根に最小値が来るのは最小ヒープの性質です。問題では最大ヒープを構築するため、根には最大値（10）が来ます。",
          "analogy": "最大ヒープは「一番強い人を常に頂点に置くルール」、最小ヒープは「一番弱い人を頂点に置くルール」です。最大ヒープなので 1（最弱）は頂点に来ません。"
        }
      },
      {
        "id": "d",
        "text": "5",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "5 は配列 [4, 10, 3, 5, 1] の中で 2 番目に大きい値ですが、根には最大値の 10 が来ます。ヒープ構築後、5 は根の子ノードとして位置づけられます。",
          "analogy": "「副社長」に当たる 5 は社長（10）の下に配置されます。副社長が社長になるわけではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "最大ヒープでは根に配列全体の最大値が来ます。配列 [4, 10, 3, 5, 1] の最大値は 10 なので根は 10 です。",
      "keyPoint": "最大ヒープの根 ＝ 最大値、最小ヒープの根 ＝ 最小値。この基本を押さえましょう。",
      "relatedTopics": ["ヒープソート", "優先度付きキュー", "完全二分木", "ヒープ性質"],
      "studyTip": "ヒープを配列で表現するとき、インデックス i のノードの左の子は 2i+1、右の子は 2i+2、親は (i-1)/2 の整数部になります。この関係を覚えて手で操作してみましょう。"
    },
    "tags": ["ヒープ", "最大ヒープ", "ヒープ構築", "優先度付きキュー", "完全二分木"]
  },
  {
    "questionId": "q-ap-043",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "マージソート",
    "level": 8,
    "question": "外部マージソート（external merge sort）が利用される主な理由として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "マルチコアCPUを活用して並列にソートを行うため",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "並列処理を活用するためにマージソートを使う場合もありますが、それは「並列マージソート」の文脈です。外部マージソートの主目的は並列化ではなく、メモリに収まらない大規模データの処理です。",
          "analogy": "複数の料理人が同時に調理するのは並列マージソートのイメージです。外部マージソートは「一度に持ち運べる量に分けてキッチンと倉庫を往復する」仕組みです。"
        }
      },
      {
        "id": "b",
        "text": "ソートするデータが主記憶（RAM）に収まらないほど大きい場合に、補助記憶（ディスク）を活用してソートを行うため",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "外部マージソートは、ソート対象のデータが主記憶（RAM）に全部載せられないほど大規模なとき（例：数十GB のログファイル）に使われます。データをRAMに収まるチャンクに分割してそれぞれをソートし（ランと呼ぶ）、その後ランをディスクから読み込みながらマージします。I/O 回数を最小化することが設計の核心です。",
          "analogy": "引っ越しの荷物が一度にトラックに積みきれないとき、何往復かに分けて運ぶのに似ています。外部マージソートはその往復回数（ディスクI/O）を最小化するように設計された仕組みです。",
          "deepDive": "外部マージソートの手順は①データをブロックに分割してRAMでソートしディスクに書き出す（ランの作成）、② k-way マージを使ってランを段階的にマージする、です。k-way マージには最小ヒープを使って各ランの先頭要素を管理することで O(n log k) でマージできます。データベース管理システムの ORDER BY 処理などでよく使われます。"
        }
      },
      {
        "id": "c",
        "text": "整数以外の文字列やオブジェクトをソートするためのアルゴリズムとして設計されているため",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "マージソートは整数でも文字列でもオブジェクトでも汎用的に使えます。外部マージソートは「文字列用のマージソート」ではなく、「大規模データを補助記憶を使ってソートする方式」です。",
          "analogy": "外部マージソートは「大きな荷物を運ぶ方式」であって、「特定の種類の荷物専用の箱」ではありません。"
        }
      },
      {
        "id": "d",
        "text": "比較ベースのソートより高速な O(n) を実現するため",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "外部マージソートも比較ベースのソートであり O(n log n) です。O(n) で動くのはカウントソートやバケットソートなどの非比較ソートです。外部マージソートの目的は速度の改善ではなく、大規模データをディスクを使って扱えるようにすることです。",
          "analogy": "外部マージソートは「より速い方法」ではなく「RAM に入りきらない大荷物を処理できる方法」です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "外部マージソートは、データが主記憶（RAM）に収まらない場合に補助記憶（ディスク）を活用してソートを行うアルゴリズムです。データをチャンクに分割してソートし、k-way マージで統合します。",
      "keyPoint": "外部マージソートのキーワードは「大規模データ」「主記憶に収まらない」「ディスクI/O を最小化」です。",
      "relatedTopics": ["k-way マージ", "優先度付きキュー", "データベース", "ディスクI/O"],
      "studyTip": "外部マージソートはデータベースの ORDER BY 処理や大規模ログ解析の文脈で頻出です。「なぜ RAM に乗らないとき問題になるか（I/O コストが支配的になるため）」まで理解しておくと応用問題に強くなります。"
    },
    "tags": ["外部マージソート", "大規模データ", "補助記憶", "k-wayマージ", "ディスクIO"]
  },
  {
    "questionId": "q-ap-044",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "木構造の走査",
    "level": 8,
    "question": "後順（post-order）走査が実際の処理で応用される場面として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ファイルシステムのディレクトリツリーで、各ディレクトリの合計サイズを計算する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ディレクトリの合計サイズを求めるには、まずすべての子ディレクトリ・ファイルのサイズが確定してから、親ディレクトリのサイズを集計する必要があります。後順走査は「左部分木 → 右部分木 → 根」の順で処理するため、子の処理が親より先に完了します。これによりボトムアップに合計サイズを積み上げることができます。",
          "analogy": "会社の部署別の経費を集計するとき、まず末端の担当者が自分の経費を報告し、課長が課全体を集計し、部長が部全体を集計するという「下から上への集計」が後順のイメージです。",
          "deepDive": "後順走査は「子の処理結果を使って親の処理を行う」ボトムアップ型の問題に広く適用されます。数式木の評価（オペランドを先に評価してから演算子を適用）、木の削除（子から削除してから親を削除）、構文木のコード生成なども後順を使います。"
        }
      },
      {
        "id": "b",
        "text": "二分探索木からソート済みのリストを生成する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "二分探索木からソート済みリストを生成するには中順（in-order）走査を使います。後順走査では昇順にはなりません。",
          "analogy": "本棚を左から右に取り出す（中順）と五十音順になりますが、子棚を先に空にしてから親棚を取り出す（後順）では順番が変わります。"
        }
      },
      {
        "id": "c",
        "text": "木構造をシリアライズ（直列化）して保存・復元する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "木構造のシリアライズには前順（pre-order）走査がよく使われます。根を最初に記録することで、復元時に木の構造を上から順に再構築できるためです。後順では根が最後になり、復元が困難になります。",
          "analogy": "組織図を文書に保存するとき、社長→部長→課長の順（前順）で書いておけば、後で同じ組織を上から再現できます。"
        }
      },
      {
        "id": "d",
        "text": "グラフの連結成分を幅広く探索する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "グラフの連結成分の探索には幅優先探索（BFS）や深さ優先探索（DFS）を使います。後順走査は木の走査の一種であり、グラフの連結成分探索とは直接関係ありません。",
          "analogy": "連結成分を探すのは「地図のどの地域がつながっているか」を調べる作業であり、木の後順走査（下から集計）とは用途が異なります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "後順（post-order）走査は「子の処理が完了してから親を処理する」ボトムアップの問題に適しています。ディレクトリサイズの合計計算や数式木の評価などが代表例です。",
      "keyPoint": "後順 ＝「子が先、根が最後」＝ ボトムアップ集計に最適。「何のために使うか」を用途とセットで覚えましょう。",
      "relatedTopics": ["前順走査", "中順走査", "数式木", "構文木", "木の削除"],
      "studyTip": "「前順→木のコピー・シリアライズ」「中順→BST のソート出力」「後順→ボトムアップ集計・削除」という対応を用途とセットで暗記すると実践的です。"
    },
    "tags": ["後順走査", "post-order", "木構造", "ディレクトリ", "ボトムアップ"]
  },
  {
    "questionId": "q-ap-045",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "グラフの探索（BFS/DFS応用）",
    "level": 8,
    "question": "有向グラフで「閉路（サイクル）が存在するかどうか」を検出するアルゴリズムとして最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ダイクストラ法を用いて、各ノードからの最短経路を求める",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ダイクストラ法は最短経路問題を解くアルゴリズムであり、閉路の検出には使いません。また、ダイクストラ法は負の重みを持つ辺があると正しく動作しません。",
          "analogy": "「どのルートで目的地に一番速く着けるか」を調べるダイクストラ法は、「同じ場所をぐるっと一周するルートがあるか」という質問に答える道具ではありません。"
        }
      },
      {
        "id": "b",
        "text": "幅優先探索（BFS）を用いて、各ノードの訪問済みフラグを管理する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "BFS で訪問済みフラグを管理するだけでは有向グラフの閉路を正確に検出できません。BFS は無向グラフの閉路検出には使えますが、有向グラフでは「前向き辺」「交差辺」「後退辺（閉路を示す）」の区別が必要で、この区別は DFS の方が自然に対処できます。",
          "analogy": "水面に広がる波紋（BFS）では、どの経路を通って来たかの記録が難しく、有向の一方通行ルートで同じ場所に戻るかどうかを正確に判断しにくいです。"
        }
      },
      {
        "id": "c",
        "text": "深さ優先探索（DFS）を用いて、現在の探索経路上のノード（グレーノード）への後退辺を検出する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "DFS ベースの閉路検出では、各ノードに「未訪問（白）」「現在の探索スタック上（グレー）」「訪問完了（黒）」の3状態を持ちます。あるノードから辺をたどった先がグレーのノード（現在の DFS スタック上にあるノード）であれば、それは「後退辺」であり閉路（サイクル）が存在することを意味します。",
          "analogy": "迷路を進んでいるとき、「今まさに通っているルート上の部屋」に繋がる扉を見つけたら、ぐるりと一周するルート（閉路）があることがわかります。引き返してきた（黒）部屋への扉は閉路ではありません。",
          "deepDive": "この3色（白・グレー・黒）による状態管理は CLRS（アルゴリズム入門）でも説明される標準的な手法です。閉路なし ＝ トポロジカルソート可能（DAG）という関係もあります。時間計算量は O(V + E) です。DFS で後退辺が見つかった時点でサイクルが確定するため、グラフ全体を走査しなくても早期終了できます。"
        }
      },
      {
        "id": "d",
        "text": "各ノードの入次数（in-degree）を管理し、入次数が 0 でないノードが残った場合にサイクルありと判定する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "入次数を使った閉路検出（Kahn's アルゴリズム）では「入次数 0 のノードをすべて除去していき、最後に残ったノードがあればサイクルあり」と判定します。「入次数が 0 でないノードが残った場合」という説明は正しい方向ですが、単純に入次数の管理だけでは不十分です。この手法は BFS ベース（Kahn's アルゴリズム）であり、DFS ベースの説明とは異なります。",
          "analogy": "作業の前提が満たされない（入次数 0 にならない）作業が残れば、どこかでループしているということを意味します。これは Kahn's アルゴリズムの考え方です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "有向グラフの閉路検出には、DFS で「後退辺（現在の探索スタック上のグレーノードへの辺）」を検出する手法が標準的です。白・グレー・黒の3状態でノードを管理します。",
      "keyPoint": "DFS の3色（白・グレー・黒）管理で、グレーノードへの辺 ＝ 後退辺 ＝ 閉路あり、という判定ロジックを覚えましょう。",
      "relatedTopics": ["トポロジカルソート", "DFS", "Kahn's アルゴリズム", "DAG", "有向グラフ"],
      "studyTip": "閉路検出は DAG 判定・トポロジカルソートの前提確認として重要です。DFS の3色管理を手で追いながら小さなグラフで実践してみましょう。"
    },
    "tags": ["DFS", "閉路検出", "サイクル検出", "後退辺", "グラフ理論", "DAG"]
  },
  {
    "questionId": "q-ap-046",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "ハッシュ法と衝突解決",
    "level": 8,
    "question": "オープンアドレス法における「二次探索法（quadratic probing）」の説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "衝突が起きたとき、固定幅のステップで次のバケットを探す方法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは線形探索法（linear probing）の説明です。線形探索法は一定のステップ幅（例：1）で次のバケットを探します。二次探索法は1回目、4バケット先、9バケット先…というように二乗のステップで探します。",
          "analogy": "一定間隔で次の駐車区画を探すのが線形探索法、1区画→4区画→9区画と飛びながら探すのが二次探索法です。"
        }
      },
      {
        "id": "b",
        "text": "衝突が起きるたびにステップ幅を二乗（1²、2²、3²…）ずつ増やして次のバケットを探す方法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "二次探索法では、k 回目の衝突後の探索先を（元のハッシュ値 + k²）mod テーブルサイズで求めます。1回目は1²=1バケット先、2回目は2²=4バケット先、3回目は3²=9バケット先…というように二乗で増えるステップを使います。これにより線形探索法で問題になる「一次クラスタリング（連続した空き不足）」を緩和できます。",
          "analogy": "駐車場で「1つ先がダメなら4つ先、4つ先もダメなら9つ先…」とどんどん離れたところを探すイメージです。同じ混雑エリアに集中せず、点々と広がって探せます。",
          "deepDive": "二次探索法の問題点は「二次クラスタリング」です。同じハッシュ値を持つキーはすべて同じ探索シーケンスをたどるため、それらのキーが同じバケットを奪い合うことになります。これを完全に解決するのがダブルハッシュ法です。また、テーブルサイズが素数のとき、二次探索法はテーブルの少なくとも半分のバケットを探索できることが証明されています。"
        }
      },
      {
        "id": "c",
        "text": "衝突が起きたとき、2つ目のハッシュ関数を使って別のバケットを探す方法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはダブルハッシュ法（double hashing）の説明です。ダブルハッシュ法は2つ目のハッシュ関数でステップ幅を決めるため、探索シーケンスがキーごとに異なり、クラスタリングを最も効果的に防げます。",
          "analogy": "2つ目の地図を見て次の駐車場を探すのがダブルハッシュ法、決まった飛び方（1²、2²…）で探すのが二次探索法です。"
        }
      },
      {
        "id": "d",
        "text": "衝突した要素を別のハッシュ表に移して格納する方法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはカッコー・ハッシング（Cuckoo Hashing）の概念に近い説明です。オープンアドレス法では同じ1つのハッシュ表内で空きバケットを探します。別のハッシュ表を使うのは異なる仕組みです。",
          "analogy": "二次探索法は同じ駐車場内で空きを探す方法です。別の駐車場に移るのは全く別の仕組みです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "二次探索法は、衝突時に1²→2²→3²…のステップで次のバケットを探すオープンアドレス法の一種です。線形探索法の一次クラスタリングを緩和しますが、二次クラスタリングが残る点が欠点です。",
      "keyPoint": "線形探索法：一定ステップ、二次探索法：二乗ステップ、ダブルハッシュ：第2ハッシュ関数でステップを決める。この3種類の違いを押さえましょう。",
      "relatedTopics": ["線形探索法", "ダブルハッシュ法", "クラスタリング", "オープンアドレス法", "チェイン法"],
      "studyTip": "オープンアドレス法の3手法（線形・二次・ダブルハッシュ）はクラスタリングへの対策がそれぞれ異なります。「一次クラスタリング → 二次クラスタリング → クラスタリングなし」という解決の流れで覚えると整理しやすいです。"
    },
    "tags": ["ハッシュ法", "オープンアドレス法", "二次探索法", "クラスタリング", "衝突解決"]
  },
  {
    "questionId": "q-ap-047",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "グラフの探索（BFS/DFS応用）",
    "level": 8,
    "question": "ダイクストラ法を使って最短経路を求める際の前提条件として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "グラフのすべての辺の重みが非負（0 以上）でなければならない",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ダイクストラ法は「確定した最短距離は後から更新されない」という前提に基づいて動作します。負の重みの辺があると、確定後のノードへの経路がさらに短くなる可能性があり、アルゴリズムの正確性が崩れます。したがって、すべての辺の重みが非負であることが必須条件です。",
          "analogy": "「一度決めた最短ルートは覆さない」というルールで地図上のルートを決めているとき、後から「この道を通るとポイントがもらえてマイナスコストになる」という道が現れると、決め直しが必要になってルールが崩れます。",
          "deepDive": "負の重みを持つグラフの最短経路はベルマン-フォード法（O(VE)）を使います。また、負閉路（一周すると合計コストが負になる閉路）がある場合は最短経路が定義できません。ダイクストラ法は優先度付きキュー（最小ヒープ）を使うことで O((V + E) log V) で動作します。"
        }
      },
      {
        "id": "b",
        "text": "グラフが有向グラフでなければならない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ダイクストラ法は有向グラフでも無向グラフでも使えます。無向グラフは各辺を両方向の有向辺として扱えばよいだけです。必須条件は有向グラフであることではなく、辺の重みが非負であることです。",
          "analogy": "「一方通行の道（有向グラフ）しかない地図」でなくても、「往来可能な道（無向グラフ）がある地図」でもナビ（ダイクストラ法）は使えます。"
        }
      },
      {
        "id": "c",
        "text": "グラフが木構造（サイクルなし）でなければならない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ダイクストラ法はサイクルがあるグラフにも適用できます。訪問済みノードを確定済みとしてスキップするため、サイクルがあっても無限ループにはなりません。木構造でなくても動作します。",
          "analogy": "ナビは環状交差点（サイクル）がある道路でも最短経路を計算できます。一度通過した交差点は「確定済み」として再訪問しません。"
        }
      },
      {
        "id": "d",
        "text": "グラフのすべての辺の重みが整数でなければならない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ダイクストラ法は実数（浮動小数点数）の重みでも正しく動作します。整数でなければならないという制約はありません。必要なのは「非負」であることであって「整数」であることではありません。",
          "analogy": "ナビのルート計算は距離が「1.5km」や「2.3km」などの小数でも正しく動きます。整数距離だけに限定する必要はありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ダイクストラ法の必須前提条件は「すべての辺の重みが非負（0 以上）であること」です。負の重みがあるグラフにはベルマン-フォード法を使います。",
      "keyPoint": "ダイクストラ法 ＝ 非負の重み必須。負の重みがある場合はベルマン-フォード法。この使い分けを覚えましょう。",
      "relatedTopics": ["ベルマン-フォード法", "BFS", "最短経路", "優先度付きキュー", "グラフ理論"],
      "studyTip": "ダイクストラ法は試験でも頻出です。アルゴリズムの動作手順（未確定ノードから最小コストを選んで確定）を小さなグラフで手を動かして追うと、前提条件の意味が直感的にわかります。"
    },
    "tags": ["ダイクストラ法", "最短経路", "グラフ探索", "非負重み", "優先度付きキュー"]
  },
  {
    "questionId": "q-ap-048",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "クイックソート",
    "level": 8,
    "question": "クイックソートをほぼソート済みのデータに適用する際の性能改善手法として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "部分配列が小さくなったら、クイックソートの代わりに挿入ソートに切り替える",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「ハイブリッドソート（Introsort など）」の手法の一部ですが、「ほぼソート済みのデータ」への対策として最も直接的ではありません。挿入ソートへの切り替えは部分配列が小さい場合の一般的な最適化ですが、「ほぼソート済み」という問題の根本（ピボット選択の偏り）を解決しません。",
          "analogy": "少人数になったら並べ直しをやりやすい方法に変えるのは一般的な効率化ですが、「ほぼ整列済みの大人数」という問題の核心（先頭が最小/最大になりやすいピボット選択）には直接効かない可能性があります。"
        }
      },
      {
        "id": "b",
        "text": "ランダムにピボットを選択することで、最悪ケースの発生確率を統計的に下げる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ほぼソート済みのデータに先頭ピボットや末尾ピボットを使うと、ピボットが常に最小値か最大値になって最悪 O(n²) が発生します。ランダムピボット選択を採用すると、どんな入力データに対してもピボットが極端な値になる確率は低く抑えられ、期待値として O(n log n) の性能を維持できます。",
          "analogy": "ほぼ身長順に並んだクラスで「一番左の人」をピボットに選ぶと常に最短になります。ランダムにピボットを選べば、どこを切り取っても程よい身長の人が選ばれる可能性が高くなります。",
          "deepDive": "ランダムピボット選択を使ったクイックソートの期待計算量は O(n log n) であり、最悪ケースの発生確率は入力に依存せず非常に小さくなります（確率論的保証）。実際の実装では擬似乱数生成のコストも考慮する必要がありますが、三数のメジアン法と組み合わせることでさらに実用的な実装になります。Python の timsort（挿入ソート＋マージソートのハイブリッド）はほぼソート済みデータへの特化として有名な別のアプローチです。"
        }
      },
      {
        "id": "c",
        "text": "ピボットを常に配列の中央要素に固定する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "中央固定ピボットはランダム選択よりも効果的ではありません。ほぼソート済みデータの中央要素は中央値に近いことが多いですが、特殊なデータパターン（例：パイプオルガン型など）では中央固定でも最悪に近い性能になる場合があります。ランダム選択は任意の入力に対して統計的な保証を与えます。",
          "analogy": "クラスの真ん中の人（中央固定）をピボットにするのは悪くないですが、もし真ん中の人が偶然に一番背が低い場合があります。ランダムに選べばそのリスクを数学的に下げられます。"
        }
      },
      {
        "id": "d",
        "text": "再帰の深さが一定値を超えたら、マージソートに完全に切り替える",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは Introsort の設計に似ていますが（ただし Introsort はヒープソートに切り替える）、「ほぼソート済みデータへの対策」として最も直接的ではありません。また、問題はピボット選択にあるため、マージソートに切り替えることよりもピボット選択の改善が根本的な解決策です。",
          "analogy": "深くなりすぎたら別の方法に変えるのは一つの手段ですが、「なぜ深くなるか（ピボット選択の問題）」を直接解決する方がより根本的です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ほぼソート済みのデータへのクイックソート最適化として最も効果的なのは「ランダムピボット選択」です。入力の偏りに依存せず、期待計算量 O(n log n) を統計的に保証します。",
      "keyPoint": "ランダムピボット選択は「どんな入力でも高い確率で O(n log n)」という確率論的保証を与える重要な手法です。",
      "relatedTopics": ["三数のメジアン法", "Introsort", "Timsort", "最悪ケース対策", "クイックソート"],
      "studyTip": "ランダムピボット・三数のメジアン・Introsort（深さ制限でヒープソートに切り替え）・Timsort（ほぼソート済みに特化）という実用的なソートアルゴリズムの工夫を体系的に学ぶと、高度な問題にも対応できます。"
    },
    "tags": ["クイックソート", "ランダムピボット", "ほぼソート済み", "最悪ケース対策", "Introsort"]
  }
]
