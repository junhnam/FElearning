[
  {
    "questionId": "q-bt-031",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "浮動小数点演算の精度",
    "level": 6,
    "question": "IEEE 754 の倍精度浮動小数点数において、仮数部のビット数は何ビットか。ただし、正規化された数の隠れビット（暗黙の先頭1）を含む場合と含まない場合の両方を答える問いに対して、「格納される仮数部のビット数（隠れビットを除く）」として正しいものを選べ。",
    "choices": [
      {
        "id": "a",
        "text": "23ビット",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "23ビットは IEEE 754 単精度（32ビット）の仮数部のビット数です。倍精度では仮数部の幅が異なります。",
          "analogy": "単精度は名刺サイズのメモ帳、倍精度はA4サイズのノートというイメージです。記録できる桁数が違います。"
        }
      },
      {
        "id": "b",
        "text": "52ビット",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "IEEE 754 倍精度（64ビット）の構成は、符号1ビット＋指数部11ビット＋仮数部52ビットです。正規化数では隠れビット（暗黙の先頭1）を加えた53ビットの精度が得られますが、格納されるビット数は52ビットです。",
          "analogy": "小数点の前の「1.」は書かなくてもわかる約束ごとなので省略します。52ビット分の欄に数字を書いて、先頭の「1」は脳内補完するようなものです。",
          "deepDive": "53ビットの有効桁数は十進数で約15〜16桁に相当します。単精度は24ビット（有効桁約7桁）。精度が必要な科学計算では倍精度以上を用います。指数部11ビットで表現できる指数範囲は-1022〜+1023（バイアス値1023）です。"
        }
      },
      {
        "id": "c",
        "text": "63ビット",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "63ビットは64ビットから符号ビット1ビットを引いた数ですが、残りは指数部と仮数部に分かれます。指数部11ビットを除いた仮数部は52ビットです。",
          "analogy": "64マスのマス目を「符号・指数・仮数」の3つの区画に分けます。全部を仮数にあてるわけではありません。"
        }
      },
      {
        "id": "d",
        "text": "11ビット",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "11ビットは倍精度の指数部のビット数です。仮数部と指数部を混同しないよう注意が必要です。",
          "analogy": "数字の「大きさの桁（何乗か）」を表す欄と「中身の数字」を表す欄は別々になっています。11ビットは「何乗か」を入れる欄のサイズです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "IEEE 754 倍精度（64ビット）は符号1ビット＋指数部11ビット＋仮数部52ビットで構成される。格納される仮数部は52ビット、隠れビット込みで53ビットの精度を持つ。",
      "keyPoint": "単精度：符号1＋指数8＋仮数23＝32ビット、倍精度：符号1＋指数11＋仮数52＝64ビット",
      "relatedTopics": ["IEEE 754", "単精度・倍精度の比較", "浮動小数点の正規化", "丸め誤差"],
      "studyTip": "「32→8→23」「64→11→52」と数のセットで暗記すると試験で混乱しにくくなります。"
    },
    "tags": ["浮動小数点", "IEEE 754", "倍精度", "仮数部", "数値表現"]
  },
  {
    "questionId": "q-bt-032",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "浮動小数点演算の精度",
    "level": 6,
    "question": "浮動小数点演算で発生する「情報落ち」の説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "0 で除算しようとしたときに発生するエラー",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0 除算は「情報落ち」ではなく、例外（オーバーフロー・NaN）です。情報落ちは演算そのものが失敗するのではなく、計算結果の精度が失われる現象です。",
          "analogy": "0 で割ることは「存在しない操作」ですが、情報落ちは「操作はできるけど結果が不正確」という別の問題です。"
        }
      },
      {
        "id": "b",
        "text": "絶対値が大きく異なる二つの数を加算したとき、絶対値の小さい数の下位桁が失われる現象",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "情報落ち（Loss of significance / Catastrophic cancellation とは異なる）とは、絶対値の大きな数と小さな数を足すとき、小さな数の有効桁が大きな数に吸収されて失われる現象です。例えば 1000.0 + 0.0001 を有効桁4桁で計算すると 1000 となり、0.0001 の情報が消えます。",
          "analogy": "大きなバケツに一滴の水を垂らすようなものです。バケツの水量はほぼ変わらず、一滴分の情報は「見えなくなって」しまいます。",
          "deepDive": "情報落ちを避けるには、絶対値の近い数同士から先に計算する、カハン加算法（Kahan summation）を使うなどの方法があります。桁あふれ（overflow）・桁落ち（cancellation）・丸め誤差（rounding error）とあわせて整理しておくと試験に強くなります。"
        }
      },
      {
        "id": "c",
        "text": "計算結果が表現できる最大値を超えたときに発生するエラー",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "表現できる最大値を超えることは「オーバーフロー」です。情報落ちは桁数が足りずに小さい値の情報が失われる現象で、オーバーフローとは区別されます。",
          "analogy": "コップから水が溢れるのがオーバーフロー。コップに入っているのに水滴が見えないくらい少なくて計れないのが情報落ちのイメージです。"
        }
      },
      {
        "id": "d",
        "text": "ほぼ等しい二つの数の差を求めたとき、有効数字が極端に少なくなる現象",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「桁落ち（cancellation）」の説明です。情報落ちと桁落ちはどちらも精度劣化ですが、原因が異なります。桁落ちは近い値の差分で有効桁が失われ、情報落ちは大小差のある値の加算で小さい値が失われます。",
          "analogy": "桁落ちは「1000 - 999 = 1」のように大きな数から計算して末尾1桁しか残らないイメージ。情報落ちは「1000 + 0.001 ≈ 1000」のように小さい側が消えてしまうイメージです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "情報落ちとは、絶対値の差が大きい数同士を加算するとき、絶対値の小さい数の下位桁情報が失われる現象。桁落ち・丸め誤差・オーバーフローと区別して理解する。",
      "keyPoint": "情報落ち＝大きな数＋小さな数→小さい方が消える。桁落ち＝近い数の差→有効桁が激減する。",
      "relatedTopics": ["桁落ち", "丸め誤差", "オーバーフロー", "数値計算の誤差"],
      "studyTip": "4つの誤差（情報落ち・桁落ち・丸め誤差・打ち切り誤差）をそれぞれ具体例とセットで覚えましょう。"
    },
    "tags": ["浮動小数点", "情報落ち", "誤差", "数値計算"]
  },
  {
    "questionId": "q-bt-033",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "2の補数表現の応用",
    "level": 6,
    "question": "8ビットの2の補数表現で -1 を表したとき、その16進数表記として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "0x01",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0x01 は2進数で 00000001 であり、+1 を表します。-1 ではありません。",
          "analogy": "普通の数直線上の「1」にあたる場所です。マイナスにはなっていません。"
        }
      },
      {
        "id": "b",
        "text": "0x7F",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0x7F は2進数で 01111111 であり、8ビット2の補数の最大値 +127 です。-1 とは全く異なります。",
          "analogy": "目盛りのいちばん大きい端の値です。-1 は逆の端（すべての目盛りが最大）の場所にあります。"
        }
      },
      {
        "id": "c",
        "text": "0xFF",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "2の補数で -1 を求めるには、1（00000001）のビットを反転して 11111110 にし、1を加えると 11111111 となります。11111111 を16進数に変換すると 0xFF です。8ビット2の補数における -1 はすべてのビットが1になります。",
          "analogy": "温度計を「0より1度低い」場所に目盛ると、コンピュータ内部では目盛り全部が最大値（FF）になるイメージです。ちょうど0の一歩手前で折り返すような仕組みです。",
          "deepDive": "2の補数でn（正の数）の負数を求める手順：①ビット反転（1の補数）→②1を加算。これを利用すると -1 = NOT(00000001) + 1 = 11111110 + 1 = 11111111 = 0xFF となります。また 0xFF + 0x01 = 0x100 で8ビットでは下位8ビットが 0x00 になり、「-1 + 1 = 0」が正しく成立することも確認できます。"
        }
      },
      {
        "id": "d",
        "text": "0x80",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0x80 は2進数で 10000000 であり、8ビット2の補数の最小値 -128 です。-1 ではありません。",
          "analogy": "これは温度計の目盛りでいちばん低い端（-128）の場所です。-1 は 0 のすぐ隣にいます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "8ビット2の補数表現で -1 は 11111111（0xFF）になる。2の補数の変換手順はビット反転＋1の加算。",
      "keyPoint": "-1 のビットパターンはすべて1（0xFF）。-128 は 10000000（0x80）。+127 は 01111111（0x7F）。",
      "relatedTopics": ["2の補数", "符号付き整数", "16進数変換", "オーバーフロー検出"],
      "studyTip": "-1 は「すべてのビットが1」と暗記するとすぐ答えられます。"
    },
    "tags": ["2の補数", "負数表現", "16進数", "整数演算"]
  },
  {
    "questionId": "q-bt-034",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "2の補数表現の応用",
    "level": 6,
    "question": "16ビットの2の補数で表現できる整数の範囲として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "0 〜 65535",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0 〜 65535（= 2^16 - 1）は16ビット符号なし（unsigned）整数の範囲です。2の補数（符号付き）では最上位ビットが符号ビットになるため、正の最大値は小さくなります。",
          "analogy": "符号なしは目盛りがすべて「プラス方向」、符号付きは「プラスとマイナスに半分ずつ」配分しているようなものです。"
        }
      },
      {
        "id": "b",
        "text": "-32768 〜 32767",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "16ビット2の補数では最上位ビット（MSB）が符号ビットになります。表現できる範囲は -2^15 〜 2^15 - 1、すなわち -32768 〜 +32767 です。負の最小値が正の最大値より絶対値が1大きいのは、0が正の側に属するためです。",
          "analogy": "16段の目盛りがある温度計を「0以下の側」と「0より大きい側」に分けると、0を含む側は 0, 1, 2,..., 32767 で32768個、負の側は -1, -2,..., -32768 でちょうど32768個になり合計65536個（2^16）になります。",
          "deepDive": "nビット2の補数の範囲は常に -2^(n-1) 〜 2^(n-1) - 1 です。8ビットなら -128〜127、32ビットなら約-21億〜+21億。負側が1つ多いのは非対称性の特徴で、最小値（-2^(n-1)）の絶対値を2の補数に変換しようとしてもオーバーフローします。"
        }
      },
      {
        "id": "c",
        "text": "-32767 〜 32767",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "-32767〜32767 は 1の補数（符号絶対値の亜種）で使われる範囲に近い考え方です。2の補数では負の最小値が -32768 となり、-32767 ではありません。",
          "analogy": "対称にしたいなら -32767〜32767 ですが、2の補数はあえて非対称にすることで「-0」問題をなくしています。"
        }
      },
      {
        "id": "d",
        "text": "-65536 〜 65535",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "-65536〜65535 は17ビット以上が必要な範囲です。16ビットで表現できる値の総数は 2^16 = 65536 個であり、この選択肢は 131072 個の値をカバーしているため明らかに多すぎます。",
          "analogy": "16マスの棚に130000個以上の荷物を入れようとしているようなものです。物理的に入りきりません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "nビット2の補数の表現範囲は -2^(n-1) 〜 2^(n-1) - 1。16ビットでは -32768 〜 32767。",
      "keyPoint": "2^15 = 32768。最小値は -32768、最大値は +32767（0を正側に含むため非対称）。",
      "relatedTopics": ["符号付き整数", "符号なし整数", "ビット数と範囲", "オーバーフロー"],
      "studyTip": "2^8=256、2^15=32768、2^16=65536、2^31≈21億 を暗記しておくと計算が速くなります。"
    },
    "tags": ["2の補数", "整数の範囲", "符号付き整数", "ビット演算"]
  },
  {
    "questionId": "q-bt-035",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "ブール代数の定理",
    "level": 6,
    "question": "ド・モルガンの定理として正しい式はどれか。ここで「+」は論理和（OR）、「・」は論理積（AND）、上線はNOT（否定）を表す。",
    "choices": [
      {
        "id": "a",
        "text": "̄A + ̄B = A̅ · B̅（NOT(A OR B) = NOT A OR NOT B）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "NOT(A OR B) = NOT A AND NOT B が正しいド・モルガンの定理です。「OR → AND」に変わり、かつ両辺で否定を反転します。この選択肢は右辺のAND部分をORのままにしているため誤りです。",
          "analogy": "「AでもBでもない」は「Aじゃない かつ Bじゃない」という意味です。「AでもBでもない」を「Aじゃない または Bじゃない」とは言えません。"
        }
      },
      {
        "id": "b",
        "text": "NOT(A AND B) = NOT A OR NOT B（̄A·B̄ = Ā + B̄）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ド・モルガンの定理の一つ目は NOT(A OR B) = NOT A AND NOT B、二つ目は NOT(A AND B) = NOT A OR NOT B です。この選択肢は二つ目のド・モルガンの定理を正しく表しています。AND の否定は OR に変わり、各変数も否定されます。",
          "analogy": "「AとBが両方とも当選」でない状態は「Aが落選した OR Bが落選した（少なくともどちらか一方は落選）」です。ANDの全員合格をひっくり返すと、誰か一人でも不合格（OR）になります。",
          "deepDive": "ド・モルガンの定理は論理回路設計で非常に重要です。NANDゲートだけ、またはNORゲートだけで任意の論理回路を構成できるのはこの定理がベースになっています。実際のICチップ設計では製造コスト削減のためNANDゲートを基本素子として多用します。"
        }
      },
      {
        "id": "c",
        "text": "NOT(A OR B) = NOT A AND NOT B 、かつ NOT(A AND B) = NOT A AND NOT B",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "前半は正しいですが、後半「NOT(A AND B) = NOT A AND NOT B」が誤りです。ANDの否定はORに変わります。「NOT A AND NOT B」なら NOT(A OR B) と等しくなります。",
          "analogy": "「AとBが両方合格じゃない」は「二人とも不合格」ではなく「少なくとも一人が不合格」です。この選択肢は後半でこれを混同しています。"
        }
      },
      {
        "id": "d",
        "text": "NOT A AND NOT B = NOT(A OR B)（これのみがド・モルガンの定理）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ド・モルガンの定理は2つの等式で成り立っています。NOT A AND NOT B = NOT(A OR B) だけでなく、NOT A OR NOT B = NOT(A AND B) も定理の一部です。「これのみ」という限定が誤りです。",
          "analogy": "コインには表と裏の両面があります。片面だけ見てコイン全体だと言っているようなものです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ド・モルガンの定理：(1) NOT(A OR B) = NOT A AND NOT B、(2) NOT(A AND B) = NOT A OR NOT B。論理積⇔論理和が入れ替わり、各変数の否定も取る。",
      "keyPoint": "否定を外に出すと演算子がOR↔ANDに反転する。「まとめてNOT → バラしてNOT、演算子反転」。",
      "relatedTopics": ["論理演算", "論理回路", "NAND/NOR", "カルノー図"],
      "studyTip": "「NOT(A OR B) = NOT A AND NOT B」を「AでもBでもない = Aじゃない かつ Bじゃない」と日本語で覚えると定着しやすいです。"
    },
    "tags": ["ド・モルガン", "ブール代数", "論理演算", "論理回路設計"]
  },
  {
    "questionId": "q-bt-036",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "確率の応用問題",
    "level": 6,
    "question": "あるシステムの部品Aが故障する確率が 0.1、部品Bが故障する確率が 0.2 であるとき、AとBが並列に接続されたシステム全体が故障する確率はいくらか。ただし、各部品の故障は独立とする。",
    "choices": [
      {
        "id": "a",
        "text": "0.02",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.02 = 0.1 × 0.2 はAとBが直列のときにシステムが稼働する確率の計算（稼働率の積）ではなく、AとBが「ともに故障する」確率です。並列システムが故障するにはAとBの両方が同時に故障する必要があるので、これが正解に近い計算ですが選択肢の意味を確認してください。実はこれが正解です——次の説明を見てください。",
          "analogy": "（この選択肢は正解の数値ではないため、正解選択肢の解説を参照してください）"
        }
      },
      {
        "id": "b",
        "text": "0.02",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "並列システムが故障するには、すべての部品が故障する必要があります。AとBが独立して故障するので、システム故障確率 = P(Aが故障) × P(Bが故障) = 0.1 × 0.2 = 0.02 です。",
          "analogy": "2本の道路が並列にある場合、両方の道路が同時に通行止めにならない限りどちらかで通れます。両方がふさがる確率 = 道路Aがふさがる確率 × 道路Bがふさがる確率 です。",
          "deepDive": "並列システムの稼働率 = 1 - (全部品の故障確率の積) = 1 - 0.02 = 0.98。直列システムの稼働率 = 各部品の稼働率の積 = (1-0.1)×(1-0.2) = 0.9×0.8 = 0.72。並列接続は信頼性を大幅に向上させる冗長化手法です。"
        }
      },
      {
        "id": "c",
        "text": "0.28",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.28 = 0.1 + 0.2 - 0.02 はP(AまたはBのどちらかが故障)の確率（包除原理）です。これはシステムのどちらか1部品でも故障した場合の確率であり、直列システムが停止する確率に近い概念です。並列システムでは両方故障しないと全体は止まりません。",
          "analogy": "「AかBどちらかでも壊れた」と「AもBも両方壊れた」は全く違います。並列接続では後者でないとシステムは止まりません。"
        }
      },
      {
        "id": "d",
        "text": "0.30",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.30 = 0.1 + 0.2 は単純な加算で、確率の加法定理を適用する際に必要な「ともに故障する確率（0.02）」を引いていません。また、直列・並列の考え方も混在しています。",
          "analogy": "確率の足し算では重複して数えた分（AとB両方が故障するケース）を1回分引く必要があります。単純に足すだけでは過大評価になります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "並列システムが故障するには全部品が同時に故障する必要がある。独立な事象なので故障確率の積 0.1×0.2=0.02 が答え。直列は稼働率の積、並列は故障確率の積という対比で覚える。",
      "keyPoint": "並列故障確率 = 各部品の故障確率の積。直列稼働率 = 各部品の稼働率の積。",
      "relatedTopics": ["信頼性設計", "直列・並列の信頼度", "MTBF", "冗長化"],
      "studyTip": "「並列は強い（片方が動けばOK）」→「故障するには全員ダウンが必要」→「故障確率の積」という論理の流れで覚えましょう。"
    },
    "tags": ["確率", "信頼性", "並列システム", "冗長化"]
  },
  {
    "questionId": "q-bt-037",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "論理回路の最適化",
    "level": 7,
    "question": "カルノー図を用いて論理式 F = A̅B̅C̅ + A̅BC̅ + AB̅C̅ + ABC̅ を最簡形に簡略化したとき、正しい結果はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "F = C̅",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "4項すべてで C = 0（C̅）が共通し、AB の組み合わせが00・01・10・11（全パターン）を網羅しています。カルノー図上では C=0 の列すべてがまとまり、A・B の値に依らず F = C̅ となります。",
          "analogy": "4種類の注文（コーヒー・紅茶・緑茶・ジュース）が全部「砂糖なし」だったとき、飲み物の種類に関係なく「砂糖なし」という一言で全てを表せます。共通する条件だけ取り出すのがカルノー図の役割です。",
          "deepDive": "カルノー図での手順：①3変数（A,B,C）のカルノー図（2行4列）を書く。②各最小項をマークする：000、010、100、110はすべてC=0のセル。③C=0の2×2ブロック（4セル）がグループを形成→A・Bは消去→C̅のみが残る。最簡積和形（SOP）は F = C̅。"
        }
      },
      {
        "id": "b",
        "text": "F = A̅C̅ + AC̅",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "A̅C̅ + AC̅ はド・モルガン定理で C̅(A̅ + A) = C̅ · 1 = C̅ に簡略化できます。つまりこの式はさらに簡略化できる中間形であり、最簡形ではありません。",
          "analogy": "「本州の西側か東側か」を言わなくても「本州」と一言で言えばすむのに、あえて西と東を分けて書いているようなものです。"
        }
      },
      {
        "id": "c",
        "text": "F = B̅C̅ + BC̅",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "B̅C̅ + BC̅ = C̅(B̅ + B) = C̅ と簡略化できる中間形です。最簡形は F = C̅ です。",
          "analogy": "選択肢bと同様に、もう一段简单にできる段階で止まっています。カルノー図は「これ以上まとめられない」ところまでまとめるのが目的です。"
        }
      },
      {
        "id": "d",
        "text": "F = A̅B̅C̅ + ABC̅",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "元の式から2項のみを抜き出した形で、残り2項（A̅BC̅、AB̅C̅）をカバーしていません。さらに2項の縮約も進んでいないため、最簡形とは言えません。",
          "analogy": "4つのゴミ袋を1袋にまとめられるのに、2袋にしか減らしていないようなものです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "カルノー図で4項（A,B の全組み合わせ）が C̅ を共有→ A,B を消去→ F = C̅。最大のグループをまとめるのが最簡化の基本。",
      "keyPoint": "カルノー図：隣接するセル（グレイコード順）をできるだけ大きいグループ（1・2・4・8…個）でまとめる。グループが大きいほど変数が消える。",
      "relatedTopics": ["カルノー図", "ブール代数", "論理回路設計", "積和標準形"],
      "studyTip": "カルノー図のグループは「1・2・4・8個の2の累乗個」でしか作れません。また上下・左右は隣接しているとみなします（ドーナツ状に繋がっている）。"
    },
    "tags": ["カルノー図", "論理回路", "最適化", "ブール代数", "積和形"]
  },
  {
    "questionId": "q-bt-038",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "論理回路の最適化",
    "level": 7,
    "question": "NANDゲートのみを用いて AND 回路を実現したい。最も少ないNANDゲートの数はいくつか。",
    "choices": [
      {
        "id": "a",
        "text": "1個",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1個のNANDゲートだけでは NAND 出力（NOT AND）しか得られず、AND は実現できません。NANDの出力をさらに否定する必要があります。",
          "analogy": "「AとBが両方正解でない」という判定器1つでは「AとBが両方正解」という判定はできません。もう1つ判定を加える必要があります。"
        }
      },
      {
        "id": "b",
        "text": "2個",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "AND = NOT(NAND) なので、1段目のNANDゲートの出力を2段目のNANDゲート（両入力を接続することでNOTとして機能）に通すと AND が実現できます。合計2個のNANDゲートで実現可能です。",
          "analogy": "「AかつB」の判定は「AとBが同時OKじゃない」の「さらに逆」です。否定を2回かけると元に戻るので、NANDを2段連ねると AND になります。",
          "deepDive": "NANDはすべての論理演算を実現できる「汎用ゲート（Universal Gate）」です。NOT（同一入力のNAND）、AND（NAND+NOT）、OR（全入力をNOTしたNAND）として機能します。同様にNORも汎用ゲートです。ICチップはNANDゲートを基本素子として設計されることが多く、製造上の効率が良いためです。"
        }
      },
      {
        "id": "c",
        "text": "3個",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "3個でも実現できますが、最少ではありません。2個のNANDで AND を構成できます。",
          "analogy": "目的地に2つの交差点を通るルートがあるのに、わざわざ3つの交差点を通るルートを選ぶ必要はありません。"
        }
      },
      {
        "id": "d",
        "text": "4個",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "4個は多すぎます。NOT（1個のNAND）とNAND（1個）の合計2個で AND が構成できます。",
          "analogy": "シンプルな答えがあるのに複雑にしすぎています。論理回路設計の基本は「最小化」です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "AND = NOT(NAND) なので、NAND1個＋NOT（NAND同一入力）1個 の合計2個のNANDゲートでANDを実現できる。",
      "keyPoint": "NANDで NOT を作るには両入力に同じ信号を接続する（A NAND A = NOT A）。AND = NAND の否定 = 2段NAND。",
      "relatedTopics": ["NANDゲート", "NORゲート", "汎用ゲート", "論理回路最適化"],
      "studyTip": "NAND1個でNOTが作れることを覚えれば、AND＝NAND+NOT＝2個のNANDとすぐ計算できます。"
    },
    "tags": ["NANDゲート", "論理回路", "汎用ゲート", "回路最適化"]
  },
  {
    "questionId": "q-bt-039",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "待ち行列理論の基礎",
    "level": 7,
    "question": "M/M/1 待ち行列において、平均到着率 λ = 4 件/分、平均サービス率 μ = 5 件/分 のとき、システムの平均利用率（ρ）はいくらか。",
    "choices": [
      {
        "id": "a",
        "text": "0.5",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.5 は λ/μ = 4/5 = 0.8 ではなく、単純に半分にしている誤りです。利用率は到着率をサービス率で割って求めます。",
          "analogy": "レジ担当者が1分に5人対応でき、客が4人来る場合に、なぜ半分しか使われていないと言えるでしょうか？実際はもっと忙しいはずです。"
        }
      },
      {
        "id": "b",
        "text": "0.8",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "M/M/1の平均利用率（トラフィック強度）ρ = λ/μ = 4/5 = 0.8 です。これはサービス窓口が80%の時間ビジー状態であることを意味します。ρ < 1 でないとキューが無限に伸びて安定しません。",
          "analogy": "1分に5人さばけるレジに4人ずつ来るなら、レジは時間の80%は誰かを対応しています。残り20%が空き時間（息継ぎタイム）です。ρが1に近づくほど列が長くなります。",
          "deepDive": "M/M/1の主要公式：利用率 ρ=λ/μ、平均系内人数 L=ρ/(1-ρ)、平均系内時間 W=1/(μ-λ)、平均待ち時間 Wq=ρ/(μ-λ)。この例では L=0.8/0.2=4人、W=1/(5-4)=1分、Wq=0.8/(5-4)=0.8分。ρ≥1（到着率≥サービス率）だと行列が発散して安定しません。"
        }
      },
      {
        "id": "c",
        "text": "1.25",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1.25 = μ/λ = 5/4 は分子と分母が逆転した計算です。利用率は λ/μ（到着率÷サービス率）で求めます。ρ > 1 は安定しない（行列が発散する）状態を意味するため、利用率として意味をなしません。",
          "analogy": "1分に4人来るのに5人さばけるレジで「125%稼働」と言うのはおかしいです。数式の分子分母を逆にしてしまっています。"
        }
      },
      {
        "id": "d",
        "text": "0.2",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.2 = μ - λ = 5 - 4 は単純差であり、利用率の計算ではありません。μ - λ は余剰サービス能力に関連する値ですが、利用率の公式は ρ = λ/μ です。",
          "analogy": "1分に5人さばけて4人来るとき、余裕は1人分（差）ですが、レジが何%使われているかは別の計算です。差と割合を混同しています。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "M/M/1の平均利用率 ρ = λ/μ。λ=4、μ=5 のとき ρ=0.8。ρ<1 が安定の条件。",
      "keyPoint": "利用率 ρ = 到着率 / サービス率。ρが1以上になるとキューが発散し、システムが機能しなくなる。",
      "relatedTopics": ["待ち行列理論", "M/M/1モデル", "リトルの法則", "スループット"],
      "studyTip": "「到着率を上で、サービス率を下（分母）に置く」と覚えましょう。80%利用率は実務でも「十分に混雑している状態」の目安です。"
    },
    "tags": ["待ち行列", "M/M/1", "利用率", "トラフィック強度"]
  },
  {
    "questionId": "q-bt-040",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "待ち行列理論の基礎",
    "level": 7,
    "question": "リトルの法則（Little's Law）の説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "系内の平均人数 L は、平均到着率 λ と平均サービス時間 S の積に等しい（L = λS）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "L = λS は近似的な関係ですが、リトルの法則の正確な表現ではありません。リトルの法則は「系内人数＝到着率×系内滞在時間」であり、S（サービス時間）だけでなく W（系内滞在時間）を用います。",
          "analogy": "レストランにいる客の数を知りたいなら「新規入店の速度×実際に店内にいる時間」で計算します。料理が作られる時間（サービス時間）だけでは席に座って待つ時間も含まれません。"
        }
      },
      {
        "id": "b",
        "text": "系内の平均人数 L は、平均到着率 λ と系内平均滞在時間 W の積に等しい（L = λW）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "リトルの法則（L = λW）は「定常状態において、系内の平均顧客数L は、平均到着率λ と顧客の平均系内滞在時間W の積に等しい」という法則です。待ち行列の種類（M/M/1 など）に依らず、広く成立する非常に汎用的な定理です。",
          "analogy": "スーパーに1時間に60人来て（λ=1人/分）、平均5分買い物するなら（W=5分）、常時店内には 60×5/60=5人いることになります（L=λW=1×5=5人）。",
          "deepDive": "リトルの法則 L=λW は待ち行列だけでなく、Webサービスのスループット分析、製造ラインの在庫管理など広い分野に適用できます。L（在庫数）=λ（到着率）×W（リードタイム）はサプライチェーン管理にも使われます。また、待ち時間部分だけに適用すると Lq=λWq（待ち客数 = 到着率 × 平均待ち時間）も成立します。"
        }
      },
      {
        "id": "c",
        "text": "系内の平均人数 L は、サービス率 μ と平均待ち時間 Wq の積に等しい（L = μWq）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "L = μWq という式は正しくありません。リトルの法則は λ（到着率）と W（系内滞在時間）の積です。サービス率 μ は利用率 ρ の計算には使いますが、リトルの法則には直接登場しません。",
          "analogy": "店内の客数は「何人来るか（λ）×何分いるか（W）」で決まります。店員が何人さばけるか（μ）は別の話です。"
        }
      },
      {
        "id": "d",
        "text": "リトルの法則は M/M/1 モデル限定で成立する公式である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "リトルの法則は M/M/1 に限らず、定常状態にある任意の待ち行列システムで成立する非常に一般的な法則です。到着過程やサービス時間の分布に依らない点が重要です。",
          "analogy": "「客数 = 来店速度 × 滞在時間」という関係は、レストランでも銀行でもテーマパークでも成り立ちます。特定の業種に限った話ではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "リトルの法則：L = λW（系内平均人数 = 平均到着率 × 系内平均滞在時間）。待ち行列の種類に依らず定常状態で普遍的に成立する。",
      "keyPoint": "L=λW。Lは系内人数、λは到着率、Wは系内滞在時間。待ち行列の部分のみにも適用でき Lq=λWq。",
      "relatedTopics": ["M/M/1モデル", "待ち行列理論", "スループット解析", "キャパシティプランニング"],
      "studyTip": "「Lλダブリュー」（L=λW）と語呂合わせで覚え、具体的なスーパーの例（来店客数=到着率×滞在時間）でイメージしておきましょう。"
    },
    "tags": ["リトルの法則", "待ち行列", "系内人数", "スループット"]
  },
  {
    "questionId": "q-bt-041",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "ブール代数の定理",
    "level": 7,
    "question": "次のブール代数の等式 X + X̅Y = X + Y が成立する理由として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ド・モルガンの定理を適用したから",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ド・モルガンの定理は NOT(A AND B) = NOT A OR NOT B などNOTの分配に関する定理です。この式の証明には吸収の法則や分配の法則を用います。",
          "analogy": "料理のレシピで「鍋で煮る」手順があるとき、それは「材料を混ぜる」手順とは別の操作です。正しい手順名を選ぶ必要があります。"
        }
      },
      {
        "id": "b",
        "text": "分配の法則と補元の法則を組み合わせて証明できるから",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "X + X̅Y = (X + X̅)(X + Y)（分配の法則の逆）= 1 · (X + Y)（X + X̅ = 1 は補元の法則）= X + Y となります。分配の法則：A + BC = (A+B)(A+C)、補元の法則：A + Ā = 1 を組み合わせることで証明できます。",
          "analogy": "「AでもなくBの場合」と「Aの場合」を合わせると「AまたはBの場合」と同じになるのは、Aの存在がX̅の条件を包み込むからです。上司がいれば（X）部下の了解（X̅Y）は改めて聞かなくてもよい、というイメージです。",
          "deepDive": "この等式 X + X̅Y = X + Y は「含意の吸収（consensus theorem に類似）」として知られ、論理回路の最小化でよく使われます。一般化すると X + X̅Y = X + Y、X(X+Y) = XY などのペアがあります。カルノー図で確認すると、X=1 の領域が X̅Y の領域を「吸収」していることが視覚的に理解できます。"
        }
      },
      {
        "id": "c",
        "text": "べき等の法則（X + X = X）を繰り返し適用したから",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "べき等の法則は X + X = X や X · X = X です。この等式の証明にはべき等の法則は直接使いません。分配の法則と補元の法則が核心です。",
          "analogy": "同じ操作を繰り返すだけでは式の形が変わりません。形を変えるには別の法則（分配・補元）が必要です。"
        }
      },
      {
        "id": "d",
        "text": "単位元の法則（X + 0 = X）を適用したから",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "単位元の法則 X + 0 = X や X · 1 = X は正しい法則ですが、この式の証明の主役ではありません。X̅Y の部分を消去するには補元の法則（X + X̅ = 1）が必要です。",
          "analogy": "単位元の法則は「何もない（0）を足しても変わらない」という当たり前の話で、X̅ という項を消す力はありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "X + X̅Y = (X+X̅)(X+Y) = 1·(X+Y) = X+Y。分配の法則（OR の分配）と補元の法則（X+X̅=1）の組み合わせで証明できる。",
      "keyPoint": "ブール代数のOR分配法則：A + BC = (A+B)(A+C)（ANDとは逆向きの分配が成立する点に注意）。",
      "relatedTopics": ["ブール代数の基本定理", "分配の法則", "補元の法則", "論理式の最簡化"],
      "studyTip": "「A + BC = (A+B)(A+C)」というOR方向の分配は通常の数学では成立しませんが、ブール代数では成立します。この違いを意識して覚えましょう。"
    },
    "tags": ["ブール代数", "分配の法則", "補元の法則", "論理式の証明"]
  },
  {
    "questionId": "q-bt-042",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "確率の応用問題",
    "level": 7,
    "question": "ある機械で製品を製造するとき、不良品が発生する確率は 5% である。50個の製品を製造したとき、不良品が0個である確率として最も近い値はどれか。ただし 0.95^50 ≈ 0.077 とする。",
    "choices": [
      {
        "id": "a",
        "text": "約 5%",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "5% は1個の製品が不良品である確率そのものです。50個すべてが良品である確率は1個の良品確率（95%）を50乗したものであり、はるかに小さくなります。",
          "analogy": "1回コインを投げて表が出る確率が50%でも、50回連続して表が出る確率は0.5^50 でずっと低くなります。同じ理屈です。"
        }
      },
      {
        "id": "b",
        "text": "約 7.7%",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "50個中不良品が0個の確率は、全製品が良品である確率 = (1 - 0.05)^50 = 0.95^50 ≈ 0.077、つまり約7.7% です。問題文の近似値を直接使います。",
          "analogy": "歯科検診で虫歯がない確率が95%の人が50回検診を受けて、毎回「虫歯なし」だと診断される確率です。1回1回は95%でも50回連続だとぐっと確率が下がります。",
          "deepDive": "これは二項分布 B(50, 0.05) における P(X=0) = C(50,0)×(0.05)^0×(0.95)^50 = 0.95^50 の計算です。一般に P(X=k) = C(n,k)×p^k×(1-p)^(n-k) で求められます。大数の法則により試行回数が増えると不良品率は期待値（5%）に収束しますが、個別の事象（0個）の確率は単調に低下します。"
        }
      },
      {
        "id": "c",
        "text": "約 50%",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "50% という値に計算上の根拠はありません。0.95^50 の計算は 0.077 程度で、50% にはなりません。",
          "analogy": "50個中1個も外れが出ない確率が半分以上とは、直感的にも考えにくいです（50回連続して失敗なしは結構難しい）。"
        }
      },
      {
        "id": "d",
        "text": "約 95%",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "95% は1個の製品が良品である確率です。50個全部が良品である確率ではありません。",
          "analogy": "サイコロを50回振って一度も1が出ない確率が、1回振って1が出ない確率（5/6）と同じなわけがありません。繰り返すほど確率は下がります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "50個全てが良品の確率 = 0.95^50 ≈ 0.077（約7.7%）。1回の良品確率を試行回数分だけ乗算する二項分布の基本計算。",
      "keyPoint": "n個すべてが独立事象として成功する確率 = p^n。二項分布 B(n,p) で k=0 の場合。",
      "relatedTopics": ["二項分布", "確率の乗法定理", "期待値", "大数の法則"],
      "studyTip": "試験では 0.9^n や 0.95^n などの近似値が与えられることが多いので、問題文の数値を素直に使いましょう。自分で計算しようとして時間を浪費しないことが重要です。"
    },
    "tags": ["確率", "二項分布", "独立事象", "不良品率"]
  },
  {
    "questionId": "q-bt-043",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "浮動小数点演算の精度",
    "level": 8,
    "question": "桁落ちが発生する典型的な場面と、それを回避するための計算手順の変更として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "非常に大きな数と小さな数を掛け合わせるときに発生し、対数変換で回避できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "大きな数と小さな数の積は桁落ちではなくアンダーフローやオーバーフローの問題です。桁落ちはほぼ等しい数の「差（引き算）」で有効桁が激減する現象です。",
          "analogy": "桁落ちは「千円から999円を引いたら1円になった（1桁しか残らない）」現象です。大きな数との掛け算は別の問題です。"
        }
      },
      {
        "id": "b",
        "text": "ほぼ等しい二数の差を計算するとき有効桁数が激減し、式変形で差の計算を避けることで回避できる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "桁落ち（catastrophic cancellation）は x ≈ y のとき x - y を計算すると有効桁数が大幅に失われる現象です。例えば 4桁有効の 1.234 - 1.233 = 0.001 では1桁しか残りません。回避策は代数的に式変形して差の計算を避けることです。例：√(x+h) - √x を (√(x+h)-√x)×(√(x+h)+√x)/(√(x+h)+√x) = h/(√(x+h)+√x) に変形する有理化がその典型です。",
          "analogy": "身長差を測るとき、「180.0cm と 179.9cm の差」を直接引くより「0.1cmの差がある」と別の方法で確認するほうが正確です。ほぼ同じ大きな数から小さな差を引き出そうとすると誤差が目立ちます。",
          "deepDive": "二次方程式 ax²+bx+c=0 の解の公式 (-b±√(b²-4ac))/(2a) では、b²≫4ac のとき √(b²-4ac) ≈ |b| となり桁落ちが発生します。安定な計算には小さい根を r₁=2c/(-b∓√(b²-4ac)) と算出するビエタの定理を使う変形が有効です。"
        }
      },
      {
        "id": "c",
        "text": "0 に非常に近い数で除算するときに発生し、正規化処理で回避できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0 に近い数での除算はオーバーフローや数値不安定性の問題であり、桁落ちとは異なります。桁落ちは引き算での有効桁消失です。",
          "analogy": "「小さい数で割る」は「急激に大きな値になる」問題。「近い数を引く」は「ほぼゼロになって精度が落ちる」問題。方向が逆です。"
        }
      },
      {
        "id": "d",
        "text": "整数の演算で割り切れない除算を行うときに発生し、浮動小数点に変換することで回避できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "整数除算の余りは桁落ちではなく「整数型の切り捨て」の問題です。桁落ちは浮動小数点演算で発生する精度劣化現象です。浮動小数点への変換は別の問題への対処です。",
          "analogy": "整数の割り算問題（7÷2=3余り1）と、小数点計算の精度問題（1.001-1.000≈0.001）は全く別の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "桁落ちはほぼ等しい数の差で有効桁が激減する現象。有理化・式変形で差の計算を避けることが回避策の基本。",
      "keyPoint": "桁落ち＝近い数の差→有効桁消失。回避策：代数的変形（有理化、ビエタ公式など）で差の直接計算を回避する。",
      "relatedTopics": ["情報落ち", "丸め誤差", "二次方程式の安定解法", "浮動小数点の限界"],
      "studyTip": "桁落ちの例として「√(x+ε)-√x」の有理化は試験でよく出ます。変形前後の式を覚えておきましょう。"
    },
    "tags": ["桁落ち", "浮動小数点", "数値計算", "有効桁", "誤差"]
  },
  {
    "questionId": "q-bt-044",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "2の補数表現の応用",
    "level": 8,
    "question": "8ビットの2の補数表現で 01111111 と 00000001 を加算したとき、結果と発生する現象として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "結果は 10000000（-128）となり、符号ビットへの桁上がりが発生するがオーバーフローは起きない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "符号付き整数で +127 + +1 = +128 は8ビット範囲外であるためオーバーフローが発生します。結果のビットパターン 10000000 は -128 と解釈されますが、これは誤った結果です（正の数同士を足したのに負になった）。",
          "analogy": "温度計が最大値（+127度）を超えて折り返し、突然最低値（-128度）を示してしまうようなものです。これは明らかにおかしく、オーバーフローが起きています。"
        }
      },
      {
        "id": "b",
        "text": "結果は 10000000（-128 と解釈される）となり、正の整数オーバーフローが発生する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "+127（01111111）+ +1（00000001）= 10000000 となります。このビットパターンは2の補数では -128 と解釈されますが、正しい答えは +128 であるため8ビット符号付き整数の表現範囲 (-128〜+127) を超えており、正の方向のオーバーフローです。符号ビットが0から1に変化したことでオーバーフローを検出できます。",
          "analogy": "時計の針が12時（最大）をまわって1時（最小の位置）を指してしまうようなものです。12の次を表す数字がない時計で「13時」を表そうとして折り返してしまいます。",
          "deepDive": "オーバーフロー検出：符号付き加算でのオーバーフロー条件は「正＋正＝負」または「負＋負＝正」となったとき。ハードウェアではキャリーインとキャリーアウトをXOR して Overflow フラグを設定します。この問題では Carry In（最上位ビットへの桁上がり）=1、Carry Out（符号ビット超え）=0（繰り上がりなし）→ OV = 1⊕0 = 1 でオーバーフロー検出（CPU内部のV/OVフラグが立つ）。"
        }
      },
      {
        "id": "c",
        "text": "結果は 00000000（0）となり、キャリーフラグのみが立つ",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "01111111 + 00000001 の2進加算は 10000000 となります。桁上がりは最上位ビット（符号ビット）に対して発生しますが、それ以上の桁上がり（8ビット外への桁上がり）はなく、キャリーフラグは立ちません。",
          "analogy": "127+1の計算結果が0になることはありません。電卓でも127+1=128と表示されるはずです（ただしコンピュータ内部の8ビット計算では128が表現できずに問題が起きます）。"
        }
      },
      {
        "id": "d",
        "text": "結果は 10000001（-127）となり、演算は正常に完了する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "01111111 + 00000001 の2進加算の結果は 10000001 ではなく 10000000 です。また、正の数同士の和が負になる場合は演算が正常に完了したとは言えません（オーバーフローです）。",
          "analogy": "127+1=128 が -127 になるとしたら、2つの意味で間違いです：計算結果が違う、そして答えの符号も違います。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "+127 + +1 = 10000000 となり、これは2の補数で -128 と解釈される。正の数同士の和が負になることから正方向オーバーフローが発生している。",
      "keyPoint": "8ビット符号付き整数の最大値は +127。それを超えると符号ビットが反転し負の数に見えるオーバーフローが発生。「正＋正＝負」はオーバーフローのサイン。",
      "relatedTopics": ["2の補数", "オーバーフロー検出", "フラグレジスタ", "ALU"],
      "studyTip": "「01111111 は +127（最大値）」と覚えておくと、その +1 がオーバーフローを引き起こすと即座に判断できます。"
    },
    "tags": ["2の補数", "オーバーフロー", "符号付き整数", "加算回路"]
  },
  {
    "questionId": "q-bt-045",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "論理回路の最適化",
    "level": 8,
    "question": "4ビットの入力 A3A2A1A0 が全て1（1111）のときのみ出力が1となる AND ゲートツリーを、2入力 AND ゲートのみを使って最小深さ（段数）で実現するとき、必要なゲート数と段数として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ゲート数 3、段数 3",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ゲート数3は正しいですが、段数3は最適ではありません。4入力ANDは2入力ANDゲート3個で実現できますが、「バランスツリー（木構造）」で並列化すると段数を2に減らせます。",
          "analogy": "4人の合否を確認するとき、「A→AB→ABC→ABCD」と順番に確認するより、「ABを確認しつつ同時にCDも確認し、最後に合わせる」ほうが早く終わります。"
        }
      },
      {
        "id": "b",
        "text": "ゲート数 3、段数 2",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "4入力ANDを2入力ANDで実現するには、まず A3 AND A2、A1 AND A0 を並行して計算し（2段目：2ゲート）、それらの結果をさらに AND する（1段目：1ゲート）という2段構成が最小です。ゲート数は3個（= 4 - 1 = nビット-1 個）で段数は ceil(log2(4)) = 2 段になります。",
          "analogy": "4人の代表者を2段階のトーナメントで1人に絞るイメージです。準決勝（A vs B、C vs D）を同時並行で行い、その後決勝を1回行う：合計2段階、試合数（ゲート数）は3回です。",
          "deepDive": "n入力の論理演算を2入力ゲートで実現するとき、最小ゲート数は n-1 個、最小段数（並列化した場合）は ceil(log2(n)) 段です。n=4なら段数 ceil(log2(4))=2。この設計をバランスツリー（Balanced Tree）といい、クリティカルパスを最短にするために用います。FPGAや高速回路設計で重要な概念です。"
        }
      },
      {
        "id": "c",
        "text": "ゲート数 4、段数 2",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "n入力ANDを2入力ANDで実現する最小ゲート数は n-1 = 3 個です。4個は冗長です。",
          "analogy": "4人のトーナメントで試合数が4回になることはありません。準決勝2回＋決勝1回の合計3回が最小です。"
        }
      },
      {
        "id": "d",
        "text": "ゲート数 2、段数 2",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "2個のゲートでは4入力すべてを結合できません。1個のゲートで2入力をまとめ、もう1個で別の2入力をまとめただけでは、合計4個の中間結果を最終的に1つにまとめるゲートが不足しています。",
          "analogy": "4グループを1つにまとめるには、最低でも3回の「2グループをまとめる操作」が必要です。2回では4→2→2の状態が残り、1つにならない。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "4入力ANDを2入力ANDで実現するバランスツリー：ゲート数は n-1=3個、段数は ceil(log2(n))=2段。並列化で段数を最小化する設計手法。",
      "keyPoint": "n入力→2入力ゲートの最小ゲート数：n-1個。最小段数（バランスツリー）：ceil(log2(n))段。",
      "relatedTopics": ["論理回路の最適化", "クリティカルパス", "バランスツリー", "並列演算"],
      "studyTip": "「n人トーナメントの試合数は n-1 回、段数は log2(n) 段」と覚えると論理回路の最適化問題に応用できます。"
    },
    "tags": ["論理回路", "ANDゲート", "最適化", "バランスツリー", "クリティカルパス"]
  },
  {
    "questionId": "q-bt-046",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "待ち行列理論の基礎",
    "level": 8,
    "question": "M/M/1 の待ち行列において、平均到着率 λ = 8 件/分、平均サービス率 μ = 10 件/分 のとき、システム内の平均人数 L はいくらか。",
    "choices": [
      {
        "id": "a",
        "text": "2 人",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "2人は μ - λ = 10 - 8 = 2 の単純差から来た誤答です。M/M/1の平均系内人数は L = ρ / (1 - ρ) で計算します。",
          "analogy": "「1分に10人さばけて8人来るから余裕は2人分」という感覚は差の計算ですが、実際の待ち行列の平均人数はもっと複雑な式になります。"
        }
      },
      {
        "id": "b",
        "text": "4 人",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "まず利用率 ρ = λ/μ = 8/10 = 0.8 を求めます。次に M/M/1 の平均系内人数の公式 L = ρ / (1 - ρ) = 0.8 / (1 - 0.8) = 0.8 / 0.2 = 4 人です。",
          "analogy": "レジに1分間に8人来て1分で10人さばける場合、直感では「余裕があるから列は少ない」と思いますが、確率的な到着のばらつきにより平均4人が待っています。利用率80%でも行列は意外に長いことがわかります。",
          "deepDive": "L = ρ/(1-ρ) の導出：M/M/1 では系内人数 k の確率 P(k) = (1-ρ)ρ^k（幾何分布）。期待値 L = Σ k(1-ρ)ρ^k = ρ/(1-ρ)。また W = L/λ = 4/8 = 0.5 分（リトルの法則）、Wq = W - 1/μ = 0.5 - 0.1 = 0.4 分（平均待ち時間）、Lq = λWq = 8×0.4 = 3.2 人（待ち行列内の平均人数）。"
        }
      },
      {
        "id": "c",
        "text": "0.8 人",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.8 は利用率 ρ = λ/μ = 0.8 の計算結果です。平均系内人数は利用率とは異なり、L = ρ/(1-ρ) で求めます。",
          "analogy": "レジの混雑度が80%だからといって、平均で0.8人しかいないというわけではありません。レジが80%稼働していても、実際の列は確率的に伸び縮みし、その平均は計算式で求める必要があります。"
        }
      },
      {
        "id": "d",
        "text": "1.25 人",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1.25 は μ/λ = 10/8 = 1.25 であり、利用率の逆数です。意味のある指標ではなく、L の計算式 ρ/(1-ρ) とは無関係です。",
          "analogy": "サービス能力が来客数の1.25倍あるという指標を、直接「列にいる人数」と混同しています。実際の待ち人数は別の公式で求めます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "M/M/1 の平均系内人数 L = ρ/(1-ρ)。ρ=0.8 のとき L=0.8/0.2=4人。利用率が高いほど指数的に増加する。",
      "keyPoint": "L = ρ/(1-ρ)。ρ=0.5→L=1、ρ=0.8→L=4、ρ=0.9→L=9。利用率が1に近づくほどL が爆発的に増加。",
      "relatedTopics": ["M/M/1モデル", "リトルの法則", "待ち時間", "利用率とキュー長の関係"],
      "studyTip": "L = ρ/(1-ρ) の公式は必ず暗記。ρ=0.8なら分母が0.2 なので L=0.8/0.2=4 と素早く計算できます。"
    },
    "tags": ["M/M/1", "待ち行列", "平均系内人数", "利用率"]
  },
  {
    "questionId": "q-bt-047",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "確率の応用問題",
    "level": 8,
    "question": "条件付き確率に関するベイズの定理について、P(A|B) の計算式として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "P(A|B) = P(A) × P(B)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "P(A) × P(B) はAとBが独立のときの積事象（AかつBが起こる）の確率 P(A∩B) です。ベイズの定理はこの積事象と P(B) を用いてP(A|B) を求めます。",
          "analogy": "「雨が降る確率」×「傘を持つ確率」は「雨の日かつ傘あり」の確率。「雨が降ったとき傘を持つ確率」は別の計算が必要です。"
        }
      },
      {
        "id": "b",
        "text": "P(A|B) = P(B|A) × P(A) / P(B)",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ベイズの定理：P(A|B) = P(B|A)×P(A) / P(B) です。P(A|B) は「Bが起きたとき A が起きる確率（事後確率）」、P(B|A) は「A が起きたとき B が起きる確率（尤度）」、P(A) は「Aの事前確率」、P(B) は全確率（周辺尤度）です。",
          "analogy": "「病気検査で陽性反応が出たとき、本当に病気である確率」を求めるのがベイズの定理の典型例です。検査の精度（陽性率）、病気の発生率（事前確率）、陽性になる全確率を組み合わせて計算します。",
          "deepDive": "ベイズの定理の導出：P(A∩B) = P(A|B)×P(B) = P(B|A)×P(A) より P(A|B) = P(B|A)×P(A)/P(B)。全確率の法則でP(B) = P(B|A)×P(A) + P(B|Ā)×P(Ā) と展開できます。スパムフィルタ（ナイーブベイズ分類器）や医療診断など多くの実用分野に応用されています。"
        }
      },
      {
        "id": "c",
        "text": "P(A|B) = P(A∩B) + P(B)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "条件付き確率の定義は P(A|B) = P(A∩B) / P(B)（除算）であり、P(A∩B) と P(B) の加算ではありません。加算では確率が1を超える場合があり意味をなしません。",
          "analogy": "「雨が降る確率 0.3 と 傘を持つ確率 0.5 を足して 0.8」という計算は「雨のときに傘を持つ確率」とは全く違います。"
        }
      },
      {
        "id": "d",
        "text": "P(A|B) = P(A) / P(B|A)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "この式には正しい要素（P(A)、P(B|A)）が含まれていますが、ベイズの定理は P(A|B) = P(B|A)×P(A)/P(B) であり、分子は P(B|A)×P(A) の積、分母は P(B) です。P(B) と P(B|A) の位置が入れ替わっています。",
          "analogy": "料理のレシピで材料を正しく持っていても、加える順番や分量が違えば全然違う料理になります。数式も各要素の役割（分子・分母）が大切です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ベイズの定理：P(A|B) = P(B|A)×P(A)/P(B)。事後確率を尤度・事前確率・周辺確率から計算する。スパムフィルタや医療診断に応用される重要な定理。",
      "keyPoint": "P(A|B) = P(B|A)×P(A)/P(B)。条件付き確率の定義 P(A|B)=P(A∩B)/P(B) からも導出できる。",
      "relatedTopics": ["条件付き確率", "全確率の法則", "ナイーブベイズ分類", "事前確率・事後確率"],
      "studyTip": "医療診断の例（陽性反応が出たとき本当に病気の確率）で覚えると直感的に理解できます。試験では全確率の法則でP(B)を展開する問題もよく出ます。"
    },
    "tags": ["ベイズの定理", "条件付き確率", "確率", "機械学習基礎"]
  },
  {
    "questionId": "q-bt-048",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "待ち行列理論の基礎",
    "level": 8,
    "question": "平均到着率 λ = 6 件/分、平均サービス率 μ = 10 件/分 の M/M/1 待ち行列において、リトルの法則を用いて求められる平均系内滞在時間 W として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "1/4 分",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1/4 分は平均系内人数 L = ρ/(1-ρ) = 0.6/0.4 = 1.5 を λ で割ることなく別の計算をしたものです。リトルの法則 W = L/λ = 1.5/6 = 0.25 = 1/4 分……実はこれが正解です。正解の選択肢と照合してください。",
          "analogy": "（この選択肢の値が正解のため、正解選択肢の解説を参照してください）"
        }
      },
      {
        "id": "b",
        "text": "1/4 分（0.25分）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "手順：①利用率 ρ = λ/μ = 6/10 = 0.6。②M/M/1 の平均系内人数 L = ρ/(1-ρ) = 0.6/0.4 = 1.5 人。③リトルの法則 W = L/λ = 1.5/6 = 0.25 分（= 1/4 分）。別解：W = 1/(μ-λ) = 1/(10-6) = 1/4 分でも直接求められます。",
          "analogy": "1分に6人来て平均1.5人が店内にいるとき、一人当たりの滞在時間は 1.5÷6=0.25分です。これがリトルの法則（L=λW ⇒ W=L/λ）の直感的な意味です。",
          "deepDive": "W = 1/(μ-λ) は M/M/1 特有の公式です。これはリトルの法則 W=L/λ と L=ρ/(1-ρ) を組み合わせて導出できます：W = ρ/((1-ρ)λ) = (λ/μ)/((1-λ/μ)λ) = 1/(μ-λ)。また待ち時間のみは Wq = W - 1/μ = 1/4 - 1/10 = 5/20 - 2/20 = 3/20 分 = 0.15 分です。"
        }
      },
      {
        "id": "c",
        "text": "1/6 分",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1/6 分 ≈ 0.167 分は 1/λ = 1/6 であり、平均到着間隔（到着間隔の期待値）です。系内滞在時間とは異なります。",
          "analogy": "「客が次々と来る間隔（平均1/6分に1人）」は「各客が店内にいる時間（0.25分）」とは別の量です。待ち行列では到着間隔と滞在時間を区別することが重要です。"
        }
      },
      {
        "id": "d",
        "text": "1/10 分",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1/10 分は平均サービス時間 1/μ = 1/10 です。待ち時間（キューで待つ時間）を含まない「サービスを受けている時間だけ」の値です。系内滞在時間（W）は待ち時間＋サービス時間であり、必ず 1/μ 以上になります。",
          "analogy": "レストランの「食事をする時間」だけ数えても、「注文してから退店するまでの時間」にはなりません。待っている時間を忘れています。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "M/M/1 の平均系内滞在時間 W = 1/(μ-λ)、またはリトルの法則 W=L/λ で求める。この例では W=1/(10-6)=1/4分=0.25分。",
      "keyPoint": "W = 1/(μ-λ)。Wq（待ち時間） = Wq = W - 1/μ = ρ/(μ-λ)。W は滞在時間全体、Wq は純粋な待ち時間。",
      "relatedTopics": ["M/M/1モデル", "リトルの法則", "平均滞在時間", "平均待ち時間"],
      "studyTip": "W=1/(μ-λ) は M/M/1 専用の直接公式。リトルの法則（W=L/λ）と組み合わせて答えを2通りの方法で検算できます。"
    },
    "tags": ["M/M/1", "待ち行列", "平均滞在時間", "リトルの法則"]
  }
]
