[
  {
    "questionId": "q-db-011",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "SQL副問合せ",
    "level": 6,
    "question": "次のSQL文の説明として正しいものはどれか。\n\nSELECT 社員名 FROM 社員 WHERE 給与 > (SELECT AVG(給与) FROM 社員);",
    "choices": [
      {
        "id": "a",
        "text": "給与が最も高い社員の社員名を取得する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "給与が最も高い社員を取得するには MAX(給与) を使います。AVG(給与) は平均値を返すため、最高額とは異なります。",
          "analogy": "クラスで一番背が高い人を探すのに「平均身長より高い人」を調べても、全員の平均を超えた人が複数出てくるだけで、最背高者は特定できません。"
        }
      },
      {
        "id": "b",
        "text": "給与が社員全体の平均給与を上回る社員の社員名を取得する。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "副問合せ「SELECT AVG(給与) FROM 社員」が全社員の平均給与を計算し、外側のWHERE句でその平均を上回る社員を絞り込みます。これがスカラー副問合せ（単一値を返す副問合せ）の典型的な使い方です。",
          "analogy": "クラス全員の平均点を先に計算しておいて、それより高い点数を取った生徒の名前を一覧にするイメージです。「平均超え」をフィルターとして使っています。",
          "deepDive": "副問合せは実行順序が重要です。まず内側の SELECT AVG(給与) が実行されて平均値（例：300000）という単一の数値が求まり、その後外側の WHERE 給与 > 300000 という条件で絞り込みが行われます。このように単一値を返す副問合せをスカラー副問合せと呼び、比較演算子（>、<、=など）と組み合わせて使えます。"
        }
      },
      {
        "id": "c",
        "text": "給与が最も低い社員の社員名を取得する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "最も低い給与の社員を取得するには MIN(給与) を使います。AVG は平均値であり、最小値とは別物です。",
          "analogy": "学校の最低点を取った生徒を探すのに「平均点より低い人」を調べても、平均を下回る生徒が複数出てくるだけで最低点者の特定にはなりません。"
        }
      },
      {
        "id": "d",
        "text": "給与の平均値を社員名の一覧とともに取得する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "このSQL文はSELECT句に「社員名」のみを指定しており、平均給与は出力されません。副問合せ内のAVG(給与)はあくまでWHERE条件の計算に使われるだけです。",
          "analogy": "入場条件として「身長160cm以上」を設けたとき、その「160cm」という基準値自体は入場者リストに載りません。条件として使われるだけです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "副問合せ（サブクエリ）とは、SQL文の中に入れ子にして書くSELECT文のことです。内側のSELECTが先に実行され、その結果を外側のSQL文の条件として使います。",
      "keyPoint": "スカラー副問合せは単一の値を返し、WHERE句の比較演算子と組み合わせて使う。実行順は「内側から外側へ」。",
      "relatedTopics": ["相関副問合せ", "IN句との組み合わせ", "EXISTS句", "集約関数(AVG/MAX/MIN)"],
      "studyTip": "副問合せは「まず内側の結果を求め、その値を外側のWHERE条件に当てはめる」という2ステップで読み解くと理解しやすいです。試験では副問合せの実行結果が何件・何値になるかを問う問題が頻出です。"
    },
    "tags": ["SQL", "副問合せ", "スカラー副問合せ", "AVG", "WHERE句"]
  },
  {
    "questionId": "q-db-012",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "ビューとインデックス",
    "level": 6,
    "question": "データベースにおけるビュー（View）の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ビューはデータを物理的に格納する仮想テーブルであり、元のテーブルが削除されても独立して存在し続ける。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ビューはデータを物理的に格納しません。ビューはSELECT文の定義を保存したものであり、元のテーブルのデータを参照します。元テーブルが削除されるとビューも使用できなくなります。",
          "analogy": "ビューは鏡に映った姿であり、鏡そのものには実体がありません。映す対象（元テーブル）がなくなれば、鏡には何も映りません。"
        }
      },
      {
        "id": "b",
        "text": "ビューはSELECT文を名前付きで保存した仮想テーブルであり、必要なデータのみを見せるアクセス制御に活用できる。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ビューはSELECT文の定義（どの列・どの行を見せるか）を名前を付けて保存したものです。実データはベーステーブルにあり、ビューは参照のたびにSELECT文を実行します。特定の列や行のみ見せることで、アクセス制御や複雑なSQLの簡素化に役立ちます。",
          "analogy": "社内システムで、給与情報を含む社員テーブルがある場合、人事部向けには全列を見せ、一般社員向けには名前と部署だけを見せる「フィルター窓」を設けるようなものです。ビューが窓（フィルター）の役割を果たします。",
          "deepDive": "ビューの主な利点は3つです。①アクセス制御（機密列を隠せる）、②クエリの簡素化（複雑な結合をビューにまとめれば毎回書かなくて済む）、③論理的データ独立性（テーブル構造が変わってもビューの定義を修正するだけでアプリへの影響を最小化できる）。なお、更新可能なビューには制約があり、集約関数・GROUP BY・DISTINCTを含むビューは一般に更新できません。"
        }
      },
      {
        "id": "c",
        "text": "ビューを使用すると、元のテーブルより必ず高速にデータを検索できる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ビューは検索速度を保証するものではありません。ビューにアクセスするたびに内部のSELECT文が実行されるため、複雑なビューは逆にパフォーマンスが低下する場合があります。高速化にはインデックスの活用が有効です。",
          "analogy": "眼鏡をかけると見やすくなりますが、眼鏡自体が景色を近くに運んでくれるわけではありません。ビューは「見え方」を変えるだけで、裏側の処理量は変わらないのです。"
        }
      },
      {
        "id": "d",
        "text": "ビューには必ずインデックスが自動的に作成される。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "通常のビューにインデックスは自動作成されません。一部のDBMSでは「マテリアライズドビュー（実体化ビュー）」にインデックスを作成できますが、標準的なビューにはインデックスは存在しません。",
          "analogy": "本の目次（ビュー）は本の内容を整理して見せてくれますが、目次があるからといって本の索引（インデックス）が自動でできるわけではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ビューはSELECT文を名前付きで保存した仮想テーブルです。データの実体はベーステーブルにあり、ビューはその「見え方（フィルター）」を定義します。アクセス制御や複雑なSQLの簡素化に活用されます。",
      "keyPoint": "ビューはデータを持たない仮想テーブル。定義はSELECT文。アクセス制御・クエリ簡素化・論理的独立性の向上に役立つ。",
      "relatedTopics": ["マテリアライズドビュー", "インデックス", "アクセス制御", "データ独立性"],
      "studyTip": "「ビュー＝仮想テーブル、データを持たない、SELECT文の定義を保存」という3点を確実に押さえましょう。ビューとインデックスはどちらも「検索を助けるもの」に見えますが目的と仕組みが全く異なります。"
    },
    "tags": ["ビュー", "仮想テーブル", "アクセス制御", "SQL", "データベース設計"]
  },
  {
    "questionId": "q-db-013",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "トランザクションのACID特性",
    "level": 6,
    "question": "トランザクションのACID特性のうち、「一度コミットされたトランザクションの結果は、その後システム障害が発生しても失われない」という性質を指す用語はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "原子性（Atomicity）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "原子性とは「トランザクションに含まれる操作がすべて実行されるか、まったく実行されないかのどちらかになる」という性質です。コミット後の永続化とは異なります。",
          "analogy": "銀行振込で「送金」と「受取」は一体です。途中で失敗したら両方なかったことになる（全か無か）のが原子性です。コミット後に記録が残ることとは別の話です。"
        }
      },
      {
        "id": "b",
        "text": "一貫性（Consistency）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "一貫性とは「トランザクションの実行前後でデータベースの整合性制約が保たれる」という性質です。障害後のデータ保存とは別の概念です。",
          "analogy": "銀行口座の残高が常にマイナスにならないというルールが守られ続けることが一貫性です。障害があっても記録が残ることとは意味が違います。"
        }
      },
      {
        "id": "c",
        "text": "独立性（Isolation）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "独立性とは「複数のトランザクションが同時に実行されても、それぞれが他のトランザクションの影響を受けずに実行されたかのように見える」という性質です。",
          "analogy": "ATMを複数人が同時に使っても、自分の取引が他人の操作で邪魔されないことが独立性です。コミット後の記録保持とは異なります。"
        }
      },
      {
        "id": "d",
        "text": "永続性（Durability）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "永続性（Durability）は「コミットされたトランザクションの結果は、その後にシステム障害（電源断など）が発生しても永続的に保存される」という性質です。これはログ（ジャーナル）への書き込みやチェックポイント機能によって実現されます。",
          "analogy": "銀行で振込が完了（コミット）した後に停電が起きても、その振込記録は消えません。「完了した取引は永久に記録に残る」のが永続性です。",
          "deepDive": "永続性はデータベースのログ（ジャーナル）機能で実現されます。コミット時にはデータを直接ディスクに書く前にまずログに記録し、障害後の再起動時にはログを使ってコミット済みトランザクションをロールフォワード（再適用）します。ACIDの4文字：A=原子性、C=一貫性、I=独立性（分離性）、D=永続性（耐久性）と覚えましょう。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ACID特性とはトランザクションが守るべき4つの性質です。A（原子性：全か無か）、C（一貫性：整合性の維持）、I（独立性：並行実行の隔離）、D（永続性：コミット後の永続保存）。",
      "keyPoint": "永続性（Durability）＝コミット済みの結果は障害後も失われない。ログ（ジャーナル）機能で実現。",
      "relatedTopics": ["ロールバック", "ロールフォワード", "チェックポイント", "WAL(Write-Ahead Logging)"],
      "studyTip": "ACIDの各文字と意味をセットで暗記しましょう。「Atomicity=All or Nothing」「Consistency=整合性」「Isolation=隔離」「Durability=ディスクに残る」という英単語の意味から連想すると記憶に定着しやすいです。"
    },
    "tags": ["ACID特性", "トランザクション", "永続性", "Durability", "データベース障害回復"]
  },
  {
    "questionId": "q-db-014",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "排他制御（ロック）",
    "level": 6,
    "question": "データベースの排他制御におけるロックの説明として、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "共有ロック（読取りロック）を取得したトランザクションは、他のトランザクションからの読取りも書込みも一切禁止できる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "共有ロックは他のトランザクションの読取りは許可します。書込み（更新）のみを禁止します。すべてを禁止するのは占有ロック（排他ロック）です。",
          "analogy": "図書館で本を「閲覧中」にしても、他の人も同じ本を一緒に読めます（共有ロック）。でも書き込み（落書き）はできません。本を「貸出中」（占有ロック）にして初めて他の人は読むこともできなくなります。"
        }
      },
      {
        "id": "b",
        "text": "占有ロック（書込みロック）を取得したトランザクションがいる間、他のトランザクションは読取りも書込みもできない。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "占有ロック（排他ロック・書込みロック）を取得したトランザクションがデータを保持している間は、他のトランザクションはそのデータへの読取りも書込みも行えません。これにより更新中のデータの一貫性を保ちます。",
          "analogy": "トイレの個室（占有ロック）を使用中の間は、他の人は入ること（読取り）も使うこと（書込み）もできません。使用中の間は完全にアクセスを遮断します。",
          "deepDive": "ロックの種類と互換性を表で理解しましょう。共有ロック（S）同士は共存可能（複数人が同時に読める）。占有ロック（X）は共有ロックとも占有ロックとも共存不可（更新中は誰もアクセス不可）。ロックの粒度（行ロック・テーブルロック・ページロック）も重要で、粒度が細かいほど並行性は高いがオーバーヘッドも増えます。"
        }
      },
      {
        "id": "c",
        "text": "共有ロックと占有ロックは同じデータに対して同時に取得できる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "共有ロックと占有ロックは同じデータに対して同時に取得できません。占有ロックは他のすべてのロックと競合するため、既に共有ロックが取得されているデータへの占有ロック要求は待機させられます。",
          "analogy": "図書館で複数の人が本を閲覧中（共有ロック）のとき、その本に書き込みたい人（占有ロック希望者）は全員が読み終わるまで待たされます。読書中と書込みは同時にはできません。"
        }
      },
      {
        "id": "d",
        "text": "ロックは主キー列にのみ設定でき、その他の列には設定できない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ロックは主キー列に限らず、行全体・テーブル全体・ページ単位など様々な粒度で設定できます。主キーへの制限はありません。",
          "analogy": "部屋の鍵（ロック）は建物全体にかけることも、特定の部屋にかけることも、特定の引き出しにかけることもできます。特定の場所だけに限定されていません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "データベースのロックには「共有ロック（読取り用、他の読取りを許可）」と「占有ロック（書込み用、他の読取り・書込みを一切禁止）」があります。複数トランザクションの同時実行時にデータの整合性を保つために使用します。",
      "keyPoint": "共有ロック（S）：読取り可・書込み不可。占有ロック（X）：読取りも書込みも不可。共有ロック同士は共存可能、占有ロックは他と共存不可。",
      "relatedTopics": ["デッドロック", "2相ロッキングプロトコル", "楽観的ロック", "MVCC（多版型同時実行制御）"],
      "studyTip": "ロックの互換表（SとSは○、SとXは×、XとXは×）を暗記しましょう。「共有（Share）はシェア（共有）できる、占有（eXclusive）は排他的で誰も近寄れない」と覚えると混乱しません。"
    },
    "tags": ["排他制御", "ロック", "共有ロック", "占有ロック", "トランザクション"]
  },
  {
    "questionId": "q-db-015",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "データベース障害回復",
    "level": 6,
    "question": "データベースにおける「ロールフォワード（Roll Forward）」の説明として、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "障害発生前に正常終了（コミット）していたトランザクションの更新を取り消す処理。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはロールバックの説明です。ロールバックはトランザクションの更新を取り消してデータを元の状態に戻す処理です。ロールフォワードは逆に更新を再適用します。",
          "analogy": "ロールバックは映像を巻き戻すことです。ロールフォワードは映像を早送りで進めることです。方向が正反対です。"
        }
      },
      {
        "id": "b",
        "text": "障害発生直前にコミットされていたトランザクションの更新をログを用いて再適用し、データを最新状態に戻す処理。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ロールフォワードは、チェックポイント以降にコミット済みだったトランザクションの変更内容をログ（ジャーナル）から読み出して再実行し、データベースを障害直前の最新状態に復元する処理です。バックアップからの復元後にログを適用して最新化するために使います。",
          "analogy": "昨日の日記（バックアップ）を基点として、今日の日記（ログ）を読み直して昨日の夜から今朝までの出来事を記録し直すイメージです。日記の内容を「前に進む方向」に再適用しています。",
          "deepDive": "障害回復の手順は、①バックアップからデータベースを復元し、②ログを使ってコミット済みトランザクションをロールフォワード（再適用）し、③未コミットのトランザクションをロールバック（取消し）します。チェックポイントを設けることで、すべてのログを最初から読む必要がなくなり、復旧時間を短縮できます。"
        }
      },
      {
        "id": "c",
        "text": "障害発生時に進行中だったトランザクションを強制的に継続させ、完了まで処理する仕組み。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "障害発生時に進行中だったトランザクションは、通常ロールバックされて取り消されます。障害後に強制継続させる仕組みはありません。ロールフォワードはコミット済みの処理を再適用するものです。",
          "analogy": "停電で途中まで書いた書類は、再起動後に「途中から続き」を書くのではなく、新たに書き直します（ロールバック後に再送信）。途中からの強制継続とは異なります。"
        }
      },
      {
        "id": "d",
        "text": "データベースをバックアップ時点の状態に戻す処理で、その後の変更は反映されない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは単純なバックアップからの復元の説明です。ロールフォワードはバックアップ復元後にさらにログを用いて最新状態まで「前進させる」処理であり、バックアップ後の変更を反映させることが目的です。",
          "analogy": "バックアップからの復元だけでは昨日時点のデータしか戻りません。ロールフォワードは「昨日から今朝の間の変更履歴（ログ）」を読んで今朝の状態まで前進させる追加作業です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "データベース障害回復には「ロールバック（更新の取消し）」と「ロールフォワード（更新の再適用）」があります。ロールフォワードはバックアップ後にログを適用してデータを最新状態に復元する処理です。",
      "keyPoint": "ロールフォワード＝コミット済みトランザクションをログから再適用して最新化。ロールバック＝未コミットトランザクションを取り消し。",
      "relatedTopics": ["チェックポイント", "ジャーナル（ログ）", "バックアップ", "ACID特性の永続性"],
      "studyTip": "「ロールフォワード＝前に進む（Forward）＝ログを再実行」「ロールバック＝後ろに戻る（Back）＝更新を取消し」と方向性で区別しましょう。試験では「どちらの操作でどのトランザクションを処理するか」を問う問題が頻出です。"
    },
    "tags": ["障害回復", "ロールフォワード", "ロールバック", "ジャーナル", "チェックポイント"]
  },
  {
    "questionId": "q-db-016",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "正規化（第1〜第3正規形）",
    "level": 7,
    "question": "次の関係スキーマがある。\n\n注文明細（注文番号, 商品番号, 商品名, 数量, 単価）\n\n「商品番号 → 商品名」「商品番号 → 単価」という関数従属性があり、主キーは（注文番号, 商品番号）の複合キーである場合、この関係スキーマが抱える問題と、それを解消するための正規化の段階として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "推移的関数従属が存在するため、第2正規形から第3正規形への正規化が必要である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "この問題の従属関係は「商品番号（主キーの一部）→ 商品名・単価」であり、これは部分関数従属です。推移的関数従属（非キー属性が別の非キー属性に従属する）とは異なります。",
          "analogy": "Aさんの名前からBさんの情報がわかる（推移的）のとは違い、今回は「住所の一部（番地）だけで部屋名がわかる」という「キーの一部で情報が決まってしまう」問題です。"
        }
      },
      {
        "id": "b",
        "text": "繰り返しグループが存在するため、非正規形から第1正規形への正規化が必要である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "繰り返しグループ（一つのセルに複数の値が入っている）は問題文には記載されていません。問題のスキーマは既に原子値で構成されていると考えられるため、第1正規形は達成されています。",
          "analogy": "繰り返しグループとは、一つのマスに「りんご、みかん、バナナ」のように複数の値を詰め込んでいる状態です。問題のスキーマはそのような状態にはありません。"
        }
      },
      {
        "id": "c",
        "text": "部分関数従属が存在するため、第1正規形から第2正規形への正規化が必要である。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "複合主キー（注文番号, 商品番号）において「商品番号」だけで「商品名」と「単価」が決まってしまっています。これは主キーの一部にのみ従属する「部分関数従属」です。第2正規形はすべての非キー属性が主キー全体に完全関数従属することを要求するため、この部分関数従属を解消する（商品テーブルを分離する）ことが第1正規形→第2正規形への正規化です。",
          "analogy": "「クラス番号と生徒番号」が主キーのとき、「クラス番号だけで担任の先生がわかる」のが部分関数従属です。先生情報を別テーブルに分けることで解消します。",
          "deepDive": "正規化の段階：第1正規形（1NF）＝繰り返しグループを排除し、すべての属性が原子値。第2正規形（2NF）＝1NFに加え、部分関数従属を排除（複合キーの一部への従属を解消）。第3正規形（3NF）＝2NFに加え、推移的関数従属を排除（非キー属性間の従属を解消）。今回は注文明細テーブルから「商品（商品番号, 商品名, 単価）」テーブルを分離することで第2正規形になります。"
        }
      },
      {
        "id": "d",
        "text": "多値従属が存在するため、第3正規形から第4正規形への正規化が必要である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "多値従属はBCNF（ボイスコッドの正規形）から第4正規形への正規化で扱う概念です。今回の問題は部分関数従属であり、第4正規形の話ではありません。また試験範囲として第3正規形までが主な対象です。",
          "analogy": "多値従属は「一人の先生が複数の科目と複数のクラスを担当している」ような多対多の関係が原因で生じるより複雑な問題です。今回はそのような状況ではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "正規化は、データの冗長性や更新時異常を排除するためにテーブルを分解するプロセスです。複合主キーの一部にのみ従属する「部分関数従属」を解消するのが第2正規形（2NF）への正規化です。",
      "keyPoint": "部分関数従属＝複合主キーの一部だけで非キー属性が決まる→第2正規形違反。解消策は関連テーブルの分離。",
      "relatedTopics": ["完全関数従属", "推移的関数従属", "BCNF", "正規化と性能トレードオフ"],
      "studyTip": "正規形の違反パターンを整理しましょう。「繰り返しグループ→1NF違反」「部分関数従属（複合キーの一部への依存）→2NF違反」「推移的関数従属（非キー→非キー）→3NF違反」という対応を表で覚えると整理しやすいです。"
    },
    "tags": ["正規化", "第2正規形", "部分関数従属", "複合主キー", "関数従属性"]
  },
  {
    "questionId": "q-db-017",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "ER図の多対多",
    "level": 7,
    "question": "ER図において、「学生」エンティティと「授業」エンティティの間に多対多（M:N）の関係がある。関係データベースでこの多対多の関係を実装する正しい方法はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "学生テーブルに授業IDを複数格納できる繰り返し列を追加する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "関係データベースでは1つのセルに複数の値（繰り返し列）を格納することは第1正規形に違反します。複数の授業IDを1列に詰め込む方法は関係データベースの設計原則に反します。",
          "analogy": "棚のマスに「リンゴ、みかん、バナナ」をまとめて詰め込むと、後で取り出すとき・数えるとき・整理するときにひどく不便になります。1マス1アイテムが基本ルールです。"
        }
      },
      {
        "id": "b",
        "text": "授業テーブルに全学生の学生IDを格納するカラムを追加する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "授業テーブルに全学生の学生IDを詰め込む方法も繰り返し列の問題と同様に第1正規形違反であり、設計として不適切です。学生が増えるたびに列が増えるのも現実的ではありません。",
          "analogy": "授業の出席簿に全生徒の名前欄（150人分）を最初から印刷しておくようなものです。クラスの人数が変わるたびに出席簿の形式自体を作り直す必要があり、非常に非効率です。"
        }
      },
      {
        "id": "c",
        "text": "「履修」という中間テーブルを作成し、学生ID と授業ID を外部キーとして持たせる。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "多対多の関係は関係データベースでは直接表現できません。「履修（学生ID, 授業ID）」のような中間テーブル（関連エンティティ・交差テーブル）を作成し、両テーブルへの外部キーを持たせることで多対多を2つの1対多に分解して実装します。",
          "analogy": "「生徒と本の貸出関係」を「貸出記録（生徒ID, 本ID, 貸出日）」というノートで管理するイメージです。貸出ノートが中間テーブルの役割を果たし、一人の生徒が複数の本を、一冊の本が複数の生徒に貸し出された履歴を記録できます。",
          "deepDive": "中間テーブル（関連テーブル・交差テーブル）は多対多の分解だけでなく、追加の属性も持てます。例えば「履修（学生ID, 授業ID, 履修年度, 成績）」のように、関連自体に属性を付与できます。この中間テーブルの主キーは「学生ID + 授業ID」の複合キーとなることが多く、それぞれが各テーブルへの外部キーでもあります。"
        }
      },
      {
        "id": "d",
        "text": "学生テーブルと授業テーブルを一つのテーブルに統合する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "学生と授業は異なる実体（エンティティ）であり、一つのテーブルに統合すると多数のNULL値が発生し、データの管理が極めて複雑になります。エンティティの統合は多対多の解消方法ではありません。",
          "analogy": "生徒名簿と時間割を1枚の紙に合わせて書こうとすると、ほとんどのマスが空白（NULL）になって使い物になりません。別々に管理して「対応表」（中間テーブル）で結びつけるのが正解です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ER図の多対多（M:N）関係は、関係データベースでは中間テーブル（関連テーブル）を作成することで実装します。中間テーブルは両エンティティへの外部キーを持ち、多対多を2つの1対多関係に分解します。",
      "keyPoint": "多対多→中間テーブルで分解。中間テーブルは両エンティティのIDを外部キーとして持ち、追加属性も格納可能。",
      "relatedTopics": ["1対多の関係", "外部キー", "ER図（エンティティ関連図）", "正規化"],
      "studyTip": "「多対多は直接表現できない→必ず中間テーブルが必要」と覚えましょう。身近な例（注文と商品→注文明細、学生と授業→履修）で中間テーブルのパターンを把握しておくと試験でも応用できます。"
    },
    "tags": ["ER図", "多対多", "中間テーブル", "外部キー", "データベース設計"]
  },
  {
    "questionId": "q-db-018",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "B木インデックス",
    "level": 7,
    "question": "関係データベースでよく使われるB木（B-tree）インデックスの特徴として、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "B木インデックスは等値検索（＝）には有効だが、範囲検索（BETWEENや>、<）には使用できない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "B木インデックスは等値検索だけでなく、範囲検索（BETWEEN、>、<、>=、<=）にも有効です。B木の木構造はデータがソートされた順に格納されているため、範囲検索にも対応できます。等値検索にのみ特化しているのはハッシュインデックスです。",
          "analogy": "電話帳（あいうえお順に並んでいる）では「田中さんのページ」をピンポイントで開けるだけでなく、「た行からな行までの人」という範囲でも調べられます。これがB木（ソート済み）の強みです。"
        }
      },
      {
        "id": "b",
        "text": "B木インデックスはデータを常にバランスのとれた木構造で管理し、検索・挿入・削除の計算量はデータ量Nに対してO(log N)である。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "B木（バランス木）はその名の通り、挿入・削除時に自動的に再バランスを行い、木の高さを常に均一に保ちます。そのため根ノードから葉ノードまでの深さが一定になり、検索・挿入・削除の計算量はO(log N)で安定します。",
          "analogy": "大企業の組織図がバランスよく階層化されていれば（どの部署も同じ階層数）、どの社員も同じ段数の承認を経て情報が届きます。B木も同様に、どのデータも同じステップ数で到達できるよう常に形を整えています。",
          "deepDive": "B木とB+木の違いも重要です。B木はすべてのノード（内部ノードと葉ノード）にデータを持ちますが、B+木は実際のデータ（レコードポインタ）を葉ノードのみに持ち、葉ノードがリンクリストで繋がっています。関係データベースのインデックスにはB+木が多く採用されており、葉ノードの連結構造が範囲検索を特に高速にしています。"
        }
      },
      {
        "id": "c",
        "text": "B木インデックスはテーブル全体に対して1つしか作成できない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1つのテーブルに対して複数のインデックスを作成できます。ただし、インデックスを多数作成すると更新（INSERT/UPDATE/DELETE）時のインデックス更新コストが増加するため、適切な数のインデックスを選択することが重要です。",
          "analogy": "本には「人名索引」「地名索引」「用語索引」のように複数の索引を付けられます。ただし索引が増えるほど本が分厚くなり（ディスク使用量増加）、索引を更新する手間も増えます（更新コスト増加）。"
        }
      },
      {
        "id": "d",
        "text": "B木インデックスを作成すると、SELECT文の検索速度は必ず向上するが、INSERT文の速度は変わらない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "インデックスを作成するとINSERT・UPDATE・DELETE時にインデックスも更新する必要があるため、これらの処理は遅くなります。また、全件検索（テーブルスキャン）の方が効率的な場合もあり、SELECT文が常に速くなるわけでもありません。",
          "analogy": "索引が付いた電話帳は名前を探すのが速くなりますが、新しい人を登録するとき（INSERT）は本文だけでなく索引も更新しなければならず、手間が増えます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "B木インデックスはバランス木構造でデータをソートして管理し、検索・挿入・削除がO(log N)で実行できます。等値検索・範囲検索の両方に対応しており、関係データベースで最も広く使われるインデックス構造です。",
      "keyPoint": "B木インデックス＝バランス木・ソート済み・O(log N)・等値/範囲検索に対応。更新時のインデックス維持コストも考慮が必要。",
      "relatedTopics": ["B+木インデックス", "ハッシュインデックス", "クラスター化インデックス", "実行計画とインデックス"],
      "studyTip": "「B木のB＝Balanced（バランス）」と覚えましょう。常に高さが均一に保たれることで計算量がO(log N)に安定します。ハッシュインデックスと比較して「等値検索のみ対応のハッシュ」vs「等値・範囲両対応のB木」という違いを押さえましょう。"
    },
    "tags": ["B木インデックス", "B+木", "インデックス", "計算量", "検索性能"]
  },
  {
    "questionId": "q-db-019",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "デッドロック検出",
    "level": 7,
    "question": "データベースにおけるデッドロックの説明と、その対処法の組み合わせとして、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "デッドロックとは1つのトランザクションが長時間ロックを保持している状態であり、タイムアウトを設けることで解消できる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1つのトランザクションが長時間ロックを保持している状態は「ロック待ち」や「長時間トランザクション」と呼ばれますが、デッドロックではありません。デッドロックは複数のトランザクション間で発生する「お互い待ち合い」の状態です。",
          "analogy": "誰か1人がトイレに長時間こもっているのは「占領問題」です。デッドロックは「AさんがBさんの道を塞ぎ、BさんがAさんの道を塞いで、両者が動けなくなった」交通渋滞のような相互封鎖です。"
        }
      },
      {
        "id": "b",
        "text": "デッドロックとは複数のトランザクションが互いに相手の保持するロックを待ち合い、永遠に解放されない状態であり、どちらかのトランザクションを強制的に中断（ロールバック）させることで解消できる。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "デッドロックはトランザクションAがリソースXをロックしリソースYを待ち、同時にトランザクションBがリソースYをロックしリソースXを待つという、お互いが相手のロック解放を待ち続ける状態です。DBMSはこの循環待ちを検出し、一方のトランザクション（犠牲者）を強制ロールバックして解消します。",
          "analogy": "一本道を東向きに走る車Aと西向きに走る車Bが正面衝突してお互い動けない状態がデッドロックです。どちらかの車をバックさせる（ロールバック）ことで解消します。",
          "deepDive": "デッドロックの発生条件は4つ（コフマン条件）：①相互排除、②保有と待機、③非横取り、④循環待機。対策には「ロック順序の固定化（常に同じ順番でロック取得）」「タイムアウト設定」「デッドロック検出アルゴリズム（待ちグラフの循環検出）」があります。発生後は犠牲者を選んでロールバックし、もう一方のトランザクションを継続させます。"
        }
      },
      {
        "id": "c",
        "text": "デッドロックはインデックスを削除することで防止できる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "インデックスの有無はデッドロックの発生とは無関係です。デッドロックはロックの取得順序や並行実行制御の問題であり、インデックスの削除では解消できません。",
          "analogy": "交差点での交通渋滞（デッドロック）を解決するために、道路の標識（インデックス）を撤去しても渋滞は解消されません。渋滞の原因は道路の使い方の問題です。"
        }
      },
      {
        "id": "d",
        "text": "デッドロックが発生した場合、システムを再起動することが唯一の解決手段である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "現代のDBMSにはデッドロック検出機能が組み込まれており、システム再起動なしに自動的にデッドロックを検出して犠牲者トランザクションをロールバックすることで解消します。システム再起動は不要です。",
          "analogy": "交差点で渋滞（デッドロック）が発生したとき、街全体の電源を切る（再起動）必要はありません。交通整理員（DBMSのデッドロック検出機能）が1台の車をバックさせる（ロールバック）だけで解消できます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "デッドロックは複数のトランザクションが互いに相手のロック解放を待ち合う循環的な待機状態です。DBMSは待ちグラフの循環を検出して、一方のトランザクションを強制ロールバックして解消します。",
      "keyPoint": "デッドロック＝複数トランザクションの循環待機。解消法＝犠牲者トランザクションの強制ロールバック。予防法＝ロック取得順序の統一。",
      "relatedTopics": ["ロック", "2相ロッキングプロトコル", "待ちグラフ（Wait-for Graph）", "タイムアウト"],
      "studyTip": "デッドロックは「お互いが相手の持つリソースを待っている」という循環を必ず伴います。「AがXを持ってYを待ち、BがYを持ってXを待つ」という具体例でイメージしましょう。試験では「デッドロックの定義」と「解消方法（強制ロールバック）」の両方が問われます。"
    },
    "tags": ["デッドロック", "排他制御", "ロック", "ロールバック", "並行制御"]
  },
  {
    "questionId": "q-db-020",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "分散データベース",
    "level": 7,
    "question": "分散データベースにおける「2相コミットプロトコル（Two-Phase Commit Protocol）」の説明として、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "2相コミットは、単一サーバー内のトランザクションの原子性を保証するためのプロトコルである。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "2相コミットプロトコルは複数のデータベースサーバーにまたがる分散トランザクションで全サーバーの一貫性を保証するためのプロトコルです。単一サーバーのトランザクション管理とは用途が異なります。",
          "analogy": "2相コミットは「東京・大阪・福岡の3拠点が全員賛成したら同時に実行する」という多拠点間の合意プロトコルです。1拠点だけの話ではありません。"
        }
      },
      {
        "id": "b",
        "text": "第1フェーズで全参加者にコミット準備を確認し、全員から合意を得た場合のみ第2フェーズでコミットを実行する。一人でも否決すればロールバックする。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "2相コミットは調整者（コーディネータ）が主導する2段階の合意プロセスです。第1フェーズ（投票フェーズ）では全参加者にPREPARE要求を送り、全員からYESの応答を得ます。第2フェーズ（コミットフェーズ）では全員がYESなら全参加者にCOMMIT、一人でもNOなら全員にROLLBACKを指示します。これにより分散環境でも原子性が保たれます。",
          "analogy": "会議で「この案に全員賛成しないと採決しない」という全会一致ルールと同じです。幹事（コーディネータ）が「賛成？」と全員に聞き（第1フェーズ）、全員がOKなら「では実行！」と号令をかける（第2フェーズ）。一人でも反対があれば白紙に戻します。",
          "deepDive": "2相コミットの問題点はコーディネータが第2フェーズの途中でクラッシュした場合の「ブロッキング問題」です。参加者はコーディネータの復旧を待つ間ロックを解放できずに待機し続けます（ブロッキング状態）。この問題を改善したのが3相コミットプロトコルですが、オーバーヘッドが大きいため実際の採用は限定的です。"
        }
      },
      {
        "id": "c",
        "text": "2相コミットの第1フェーズでデータを書き込み、第2フェーズでデータを検証する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "2相コミットの第1フェーズは「書込み」ではなく「コミットできるか否かの確認（準備・投票）」です。第2フェーズが「実際のコミットまたはロールバック実行」です。",
          "analogy": "契約書の締結に例えると、第1フェーズは「全員がサインできますか？確認してください」という確認段階であり、書類を提出（書込み）するのは第2フェーズで全員がOKと答えた後です。"
        }
      },
      {
        "id": "d",
        "text": "2相コミットを使用すると、分散データベースでの処理速度が必ず2倍になる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "2相コミットは性能向上のためのプロトコルではなく、分散環境での一貫性（整合性）保証のためのプロトコルです。確認フェーズが追加されるため、単純なトランザクションよりもオーバーヘッドが発生します。",
          "analogy": "会議で全員の合意を確認する手続き（2相コミット）を追加すると、意思決定の確実性は増しますが、手続きが増える分だけ時間もかかります。速度向上とは逆の効果になります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "2相コミットプロトコルは分散データベースにおいて複数サーバーにまたがるトランザクションの原子性を保証します。第1フェーズ（全員に準備確認）、第2フェーズ（全員コミットまたは全員ロールバック）という2段階で分散トランザクションの一貫性を確保します。",
      "keyPoint": "2相コミット：第1フェーズ＝全参加者へPREPARE（準備確認）。第2フェーズ＝全員YESならCOMMIT、1人でもNOならROLLBACK。",
      "relatedTopics": ["分散データベース", "CAP定理", "3相コミット", "SAGA パターン"],
      "studyTip": "2相コミットは「全会一致で進む/諦める」という仕組みです。「1人でもNOなら全員がロールバック」という点を確実に覚えましょう。ブロッキング問題（コーディネータ障害時の待機）も頻出論点です。"
    },
    "tags": ["分散データベース", "2相コミット", "トランザクション", "原子性", "分散システム"]
  },
  {
    "questionId": "q-db-021",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "SQL結合（内部/外部/自然）",
    "level": 8,
    "question": "「社員（社員ID, 名前, 部署ID）」と「部署（部署ID, 部署名）」の2テーブルがある。一部の社員は部署に所属していない（部署IDがNULL）。すべての社員を漏れなく、かつ所属部署名も取得したい場合に使用すべき結合はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "INNER JOIN（内部結合）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "INNER JOINは結合条件が一致する行のみを返します。部署IDがNULLの社員は結合条件が一致しないため結果に含まれず、「すべての社員を漏れなく」という要件を満たせません。",
          "analogy": "ビンゴゲームで「両方のカードで番号が一致した人だけ立つ」ルールにすると、一方のカードしか持っていない人（部署なし社員）は立てません。"
        }
      },
      {
        "id": "b",
        "text": "社員テーブルを基準とした LEFT OUTER JOIN（左外部結合）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "LEFT OUTER JOINは左テーブル（社員）のすべての行を結果に含め、右テーブル（部署）に一致する行があれば部署名を取得し、一致しない場合はNULLを返します。これにより部署に所属していない社員も結果に含めながら、所属社員の部署名も取得できます。",
          "analogy": "出席簿（社員）に全生徒を載せておき、クラブ名簿（部署）と照合します。クラブに入っていない生徒もリストに残り、クラブ欄だけ空欄（NULL）になります。",
          "deepDive": "外部結合の種類：LEFT OUTER JOIN（左テーブルを全件保持）、RIGHT OUTER JOIN（右テーブルを全件保持）、FULL OUTER JOIN（両テーブルを全件保持）。「社員 LEFT JOIN 部署」とすれば、部署なし社員も含む全社員リストに部署名を付与できます。SELECT 社員.名前, 部署.部署名 FROM 社員 LEFT OUTER JOIN 部署 ON 社員.部署ID = 部署.部署ID がこのケースのSQL例です。"
        }
      },
      {
        "id": "c",
        "text": "NATURAL JOIN（自然結合）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "NATURAL JOINは同名の列（部署ID）を自動的に結合キーとして使いますが、内部的にはINNER JOINと同様に結合条件が一致する行のみを返します。部署IDがNULLの社員は含まれないため要件を満たせません。",
          "analogy": "「同じ名前の列で自動でくっつける」便利な仕組みですが、くっつかなかった行（部署なし社員）は捨てられてしまいます。「全員を残す」要件には向きません。"
        }
      },
      {
        "id": "d",
        "text": "CROSS JOIN（直積）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "CROSS JOINは2つのテーブルの全行の組み合わせ（直積）を返します。社員が100人、部署が10個なら1000行になります。目的の結合（社員と所属部署の対応）は得られず、意図しない大量のデータが生成されます。",
          "analogy": "全社員と全部署の組み合わせを全部並べる（100人×10部署=1000パターン）ような処理です。「自分の部署」を見つけるためにこんな方法は使いません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "SQL結合の種類と用途の使い分けが重要です。INNER JOIN（一致する行のみ）、LEFT OUTER JOIN（左テーブル全件＋一致する右テーブル）、FULL OUTER JOIN（両テーブル全件）。NULLを含む可能性があり全件取得したい場合は外部結合を選択します。",
      "keyPoint": "LEFT OUTER JOIN＝左テーブルのすべての行を保持。一致しない場合は右テーブル側がNULL。「漏れなく全件取得」にはOUTER JOINを選ぶ。",
      "relatedTopics": ["INNER JOIN", "FULL OUTER JOIN", "NULLの扱い", "ON句とUSING句"],
      "studyTip": "「LEFT JOINはLeftが全部残る」と覚えましょう。試験ではJOINの種類と「どちらのテーブルの行が保持されるか」を問う問題が頻出です。VENN図（ベン図）でLEFT/RIGHT/FULL/INNERの違いを視覚的に覚えると混乱しません。"
    },
    "tags": ["SQL結合", "LEFT OUTER JOIN", "INNER JOIN", "外部結合", "NULL"]
  },
  {
    "questionId": "q-db-022",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "問合せ最適化",
    "level": 8,
    "question": "データベースの問合せ最適化（クエリオプティマイザ）に関する説明として、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "クエリオプティマイザは、SQL文を書いた順番通りに処理することで、最も高速な実行を保証する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "クエリオプティマイザはSQL文の記述順ではなく、統計情報やインデックスの有無を基に最も効率的な実行計画を自動生成します。SQL文の記述順は論理的な意味を持ちますが、実行順序はオプティマイザが決定します。",
          "analogy": "カーナビは「出発地から目的地まで高速道路経由で行って」と指示されても、渋滞状況（統計情報）を見て最速ルートを計算し直します。言われた順番通りに進むとは限りません。"
        }
      },
      {
        "id": "b",
        "text": "クエリオプティマイザはインデックスが存在する場合は必ずインデックスを使用して検索する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "オプティマイザはコストベースで判断します。例えばテーブルの大部分の行を返すような検索（高選択率）では、インデックスよりもテーブル全体スキャン（フルスキャン）の方がコストが低いと判断してインデックスを使用しないことがあります。",
          "analogy": "本の索引（インデックス）は数ページを探すときは便利ですが、本の9割のページを参照するなら最初から全ページを順番に読んだ方が速いです。状況によって最善の方法は変わります。"
        }
      },
      {
        "id": "c",
        "text": "クエリオプティマイザはテーブルの統計情報（行数・列の分布など）を参考に複数の実行計画を評価し、最も低コストな計画を選択して実行する。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "コストベースオプティマイザ（CBO）は、テーブルの行数・列の値分布（ヒストグラム）・インデックスの有無などの統計情報を基に、同じSQL文に対して複数の実行計画候補（結合順序・インデックス使用の有無・結合アルゴリズムなど）のコストを見積もり、最も低コストな実行計画を選択します。",
          "analogy": "旅行の経路を決めるとき、カーナビはいくつかのルート候補（一般道/高速道/迂回路）の所要時間・料金・渋滞状況（統計情報）を比較し、最もコストが低いルートを提示します。クエリオプティマイザも同じように複数の実行計画を比較します。",
          "deepDive": "実行計画の確認方法：MySQLでは「EXPLAIN SELECT ...」、PostgreSQLでは「EXPLAIN ANALYZE SELECT ...」で実行計画を表示できます。実行計画には「テーブルスキャン」「インデックススキャン」「ネステッドループ結合」「ハッシュ結合」「マージ結合」などの操作が示されます。統計情報が古いとオプティマイザが誤った計画を選ぶことがあるため、ANALYZE（統計情報更新）の実行が重要です。"
        }
      },
      {
        "id": "d",
        "text": "クエリオプティマイザは一度生成した実行計画を永続的にキャッシュし、同じSQL文には常に同じ実行計画を使用する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "実行計画のキャッシュはDBMSによって異なります。多くのDBMSはプランキャッシュを持ちますが、統計情報の更新や条件値の変化によって異なる実行計画が選ばれることもあります。「常に同じ計画」という説明は正確ではありません。",
          "analogy": "カーナビが一度計算したルートを記憶していても、次回使うときに渋滞状況が変わっていれば別のルートを提案します。条件が変われば最適解も変わります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "クエリオプティマイザはSQL文の実行効率を最大化するため、統計情報を基に複数の実行計画のコストを見積もり、最低コストの計画を選択します。インデックスの利用有無・結合順序・結合アルゴリズムなどを自動決定します。",
      "keyPoint": "コストベースオプティマイザ＝統計情報（行数・分布）を参考に複数の実行計画を比較してコスト最小のものを選択。EXPLAINで計画確認。",
      "relatedTopics": ["実行計画（EXPLAIN）", "統計情報（ヒストグラム）", "インデックス選択", "ヒント句"],
      "studyTip": "「オプティマイザは書いた順に実行せず、コストが最小の計画を選ぶ」という点が重要です。インデックスがあっても使われないケース（高選択率・統計情報古い等）も出題されます。「コスト＝処理時間・I/O回数の見積もり」として理解しましょう。"
    },
    "tags": ["クエリオプティマイザ", "実行計画", "統計情報", "インデックス", "SQL性能"]
  },
  {
    "questionId": "q-db-023",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "NoSQLの種類",
    "level": 8,
    "question": "NoSQLデータベースの種類と特徴の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "キーバリュー型は複雑なリレーションシップを表現するのに最も適しており、ソーシャルネットワークの友人関係管理に向いている。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "複雑なリレーションシップ（友人関係・推薦経路など）の表現に最も適しているのはグラフ型データベース（Neo4jなど）です。キーバリュー型はシンプルなキーと値のペアで管理するため、リレーションシップの表現には不向きです。",
          "analogy": "キーバリュー型は「ロッカー番号→中身」という対応表です。「Aさん→Bさん→Cさんの繋がり（3ホップ先の友人）」のような網の目状の関係はロッカー管理では表現できません。"
        }
      },
      {
        "id": "b",
        "text": "ドキュメント型はJSONやBSONなどの形式でデータを格納し、スキーマレスで柔軟なデータ構造を扱えるため、ECサイトの商品カタログ管理に適している。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ドキュメント型（MongoDBなど）はJSON/BSONなどの形式でドキュメントを格納し、各ドキュメントが異なる構造（フィールド）を持てるスキーマレスな柔軟性が特徴です。ECサイトの商品カタログは商品によって属性が異なる（衣類はサイズ・色、電子機器はスペック・保証期間など）ため、固定スキーマのRDBより柔軟なドキュメント型が適しています。",
          "analogy": "商品の仕様書（ドキュメント）は商品ごとに書く項目が違います。服には「サイズ：M、色：青」、パソコンには「CPU：Core i7、RAM：16GB」と記載内容が異なります。Excelの表（RDB）だと全商品で同じ列にしないといけませんが、ドキュメント型ならそれぞれ好きなフォーマットで保存できます。",
          "deepDive": "NoSQLの4分類：①キーバリュー型（Redis, DynamoDB）＝単純なKey-Value、高速・キャッシュ用途。②ドキュメント型（MongoDB, Firestore）＝JSON形式・スキーマレス。③カラム指向型（Cassandra, HBase）＝列単位の格納・大規模集計に強い。④グラフ型（Neo4j）＝ノードとエッジでリレーションを表現。それぞれ適したユースケースが異なります。"
        }
      },
      {
        "id": "c",
        "text": "NoSQLはすべてのケースでRDBより高速かつ拡張性が高いため、RDBの完全な代替として使用できる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "NoSQLはスケールアウト（水平分散）に優れる場面では高速ですが、複雑なJOINやトランザクション管理はRDBの方が得意です。NoSQLとRDBは競合するものではなく、用途に応じて使い分けるものです。",
          "analogy": "バイクは渋滞をすり抜けるのが得意ですが、大家族の引越し荷物の運搬にはトラックの方が向いています。どちらが絶対優れているのではなく、用途次第です。"
        }
      },
      {
        "id": "d",
        "text": "カラム指向型データベースはリアルタイムの1件レコード更新・取得に特化しており、バッチ集計処理には不向きである。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "カラム指向型（Cassandra, HBase, Redshiftなど）は列単位でデータを格納するため、特定の列だけを大量に集計する処理（SUM, AVG, GROUP BYなど）を高速に行えます。1件のレコード取得（OLTP）に特化しているのはキーバリュー型やRDBです。",
          "analogy": "カラム指向型は「全社員の給与列だけ」をまとめてバサッと取り出して集計するのが得意です（1列をまるごと操作）。1人分の全情報（1行）をすばやく取り出すのはRDBが得意です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "NoSQLデータベースには「キーバリュー型・ドキュメント型・カラム指向型・グラフ型」の4種類があり、それぞれ得意なユースケースが異なります。スキーマレスで柔軟なデータ構造を扱うドキュメント型はECサイトや可変属性のコンテンツ管理に向いています。",
      "keyPoint": "ドキュメント型（MongoDB等）＝JSON形式・スキーマレス・属性が異なるデータに最適。NoSQLの4分類をユースケースとセットで覚える。",
      "relatedTopics": ["CAP定理", "BASE特性", "スケールアウト", "シャーディング"],
      "studyTip": "NoSQLの4分類（キーバリュー/ドキュメント/カラム指向/グラフ）とその代表的な製品・ユースケースをセットで暗記しましょう。「スキーマレス＝ドキュメント型」「関係管理＝グラフ型」「超高速キャッシュ＝キーバリュー型」「大規模集計＝カラム指向型」という紐付けが有効です。"
    },
    "tags": ["NoSQL", "ドキュメント型", "キーバリュー型", "グラフ型", "カラム指向型"]
  },
  {
    "questionId": "q-db-024",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "レプリケーション",
    "level": 8,
    "question": "データベースにおけるレプリケーション（Replication）の説明として、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "レプリケーションとは、データベースのバックアップを取得してオフラインで保管する仕組みである。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "バックアップはデータのスナップショットをオフラインに保管するものです。レプリケーションは複数のデータベースサーバー間でリアルタイムにデータを同期・複製する仕組みであり、バックアップとは目的も仕組みも異なります。",
          "analogy": "バックアップは「昨日の日記をコピーして金庫に保管する」ことです。レプリケーションは「東京の黒板に書いたことが大阪の黒板にもリアルタイムで複写される」ことです。"
        }
      },
      {
        "id": "b",
        "text": "マスター（Primary）スレーブ（Replica）構成のレプリケーションでは、書込みはマスターに集約し、スレーブで読取りを分散させることで読取り性能を向上できる。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "マスター・スレーブレプリケーションでは、更新（INSERT/UPDATE/DELETE）をマスターサーバーに集約し、マスターの変更がスレーブ（レプリカ）に自動的に反映されます。読取り（SELECT）はスレーブに分散できるため、Webサービスのように読取りが多い負荷分散に効果的です。",
          "analogy": "出版社（マスター）が原本を作成し、それを複数の印刷所（スレーブ）がコピーして配布するイメージです。読者は近くの印刷所から本を借りられるため、出版社への集中が緩和されます（読取り分散）。",
          "deepDive": "レプリケーションの同期方式：①同期レプリケーション＝マスターへの書込みとスレーブへの複製を同時に確認してからコミット（一貫性高・レイテンシ増）。②非同期レプリケーション＝マスターへの書込み後、非同期でスレーブに複製（低レイテンシ・複製遅延リスクあり）。複製遅延（レプリケーションラグ）が発生した場合、スレーブからの読取りが最新データを返さない「最終的一貫性（Eventual Consistency）」の状態になります。"
        }
      },
      {
        "id": "c",
        "text": "レプリケーションを使用すると、書込みの性能が必ず2倍に向上する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "レプリケーションは主に読取りの分散（読取り性能向上）と可用性の向上（フェイルオーバー）が目的です。書込みは通常マスター1台に集約されるため、書込み性能は単純には向上しません。むしろ同期レプリケーションでは確認のオーバーヘッドで書込みが遅くなることもあります。",
          "analogy": "本のコピーをたくさん作っても（スレーブ増加）、原稿を書く速さ（書込み性能）は変わりません。コピーが増えても作者の執筆速度は上がらないのと同じです。"
        }
      },
      {
        "id": "d",
        "text": "非同期レプリケーションはデータの一貫性を完全に保証するため、マスター障害時にデータ損失は発生しない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "非同期レプリケーションではマスターへの書込み後、スレーブへの複製が遅れる「レプリケーションラグ」が発生します。マスターがラグ中に障害を起こすと、未複製のデータがスレーブに反映されないまま失われる可能性があります（データ損失リスクあり）。完全な一貫性保証には同期レプリケーションが必要です。",
          "analogy": "東京で書いた手紙（データ）を大阪にFAXで送るとき（非同期複製）、送信完了前に東京オフィスが火事になれば、FAXが届かずに手紙の内容が失われます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "レプリケーションはデータベースのデータをリアルタイムで複数サーバーに複製する仕組みです。マスター・スレーブ構成では書込みをマスターに集約し、読取りをスレーブに分散することで可用性と読取り性能を向上させます。",
      "keyPoint": "レプリケーション＝リアルタイムのデータ複製。読取り分散・フェイルオーバー目的。非同期ではレプリケーションラグによるデータ損失リスクあり。",
      "relatedTopics": ["フェイルオーバー", "最終的一貫性", "シャーディング", "CAP定理"],
      "studyTip": "「同期レプリケーション＝一貫性高・遅延増」「非同期レプリケーション＝一貫性低（ラグあり）・低遅延」というトレードオフを理解しましょう。試験ではレプリケーションの目的（読取り分散・可用性向上）と非同期時のデータ損失リスクが頻出です。"
    },
    "tags": ["レプリケーション", "マスタースレーブ", "読取り分散", "フェイルオーバー", "データベース可用性"]
  },
  {
    "questionId": "q-db-025",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "シャーディング",
    "level": 8,
    "question": "データベースの「シャーディング（Sharding）」の説明として、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "シャーディングとは、1つのデータベースのデータを複数のサーバーにコピーして、読取り性能を向上させる手法である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはレプリケーションの説明です。シャーディングはデータを複数サーバーにコピーするのではなく、データを「分割」して複数サーバーに分散配置します。コピーと分割は根本的に異なります。",
          "analogy": "レプリケーションはコンビニ（データ）をそのまま同じ商品構成で複数店舗（サーバー）に展開することです。シャーディングは大型スーパーを「食品館」「衣類館」「家電館」に分けて別々のビルに入れるイメージです。"
        }
      },
      {
        "id": "b",
        "text": "シャーディングとは、大規模なデータを特定のキー（シャードキー）を基準に複数のサーバーに水平分割して分散保存する手法であり、書込み性能とストレージ容量の拡張（スケールアウト）に有効である。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "シャーディングはデータをシャードキー（例：ユーザーIDの範囲、ハッシュ値）に基づいて複数のサーバー（シャード）に水平分割します。各サーバーは全データではなく一部のデータのみを担当するため、書込み負荷とストレージが分散され、データ量に応じてサーバーを追加することでスケールアウトが可能です。",
          "analogy": "電話帳を「あ〜さ行」「た〜は行」「ま〜わ行」の3冊に分けて、それぞれ別の棚に置くイメージです。1冊が分厚くなりすぎたら分け方を変えてさらに分割（スケールアウト）できます。",
          "deepDive": "シャーディングのシャードキー選択は非常に重要です。良いシャードキー条件：①高カーディナリティ（値の種類が多い）、②均等分散（ホットスポットが生じない）、③書込みパターンに合致。シャーディングの課題：①クロスシャードクエリが複雑になる（複数シャードをまたぐJOIN等）、②シャード間のトランザクション管理が難しい、③再シャーディング（分割比率の変更）が困難。レプリケーションと組み合わせることで高可用性と高スケーラビリティの両立が可能です。"
        }
      },
      {
        "id": "c",
        "text": "シャーディングを採用すると、複数テーブルのJOIN処理が単一サーバーの場合より必ず高速になる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "複数シャードにまたがるJOIN処理（クロスシャードクエリ）はネットワーク通信が発生するため、単一サーバー内のJOINより遅くなることが多いです。シャーディングはJOINを高速化するためではなく、データ量と書込み負荷を分散するために使用します。",
          "analogy": "電話帳を3冊に分けた後、「た行と さ行にまたがる人を全員調べて」という作業は、3冊を引っ張り出して調べる必要があり、1冊の電話帳で調べるよりかえって手間がかかります。"
        }
      },
      {
        "id": "d",
        "text": "シャーディングはデータベースのバックアップを自動化する機能であり、シャードごとに独立したバックアップが作成される。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "シャーディングはバックアップ機能ではなく、データの水平分割・分散配置の手法です。シャードごとにバックアップを取ることは可能ですが、それはシャーディングの目的ではありません。",
          "analogy": "電話帳を複数冊に分けること（シャーディング）とバックアップをとること（コピーの保管）は全く別の行為です。分冊にしてもコピーは自動では作られません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "シャーディングはデータをシャードキーに基づいて複数サーバーに水平分割する手法です。書込み負荷とストレージを分散してスケールアウトを可能にしますが、クロスシャードクエリやトランザクション管理が複雑になります。レプリケーション（コピー）とは異なる概念です。",
      "keyPoint": "シャーディング＝データを水平分割して複数サーバーに分散。スケールアウトと書込み分散が目的。レプリケーション（複製）との混同に注意。",
      "relatedTopics": ["レプリケーション", "スケールアウト", "CAP定理", "一貫性ハッシュ（Consistent Hashing）"],
      "studyTip": "「シャーディング＝分割（データを切り分ける）」「レプリケーション＝複製（データをコピーする）」という根本的な違いを確実に押さえましょう。試験では両者を混同させる選択肢が頻出です。シャーディングの課題（クロスシャードクエリの困難さ）も重要論点です。"
    },
    "tags": ["シャーディング", "水平分割", "スケールアウト", "分散データベース", "シャードキー"]
  }
]
