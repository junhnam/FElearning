[
  {
    "questionId": "q-db-001",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "データベース基礎",
    "level": 1,
    "question": "関係データベースにおいて、データを格納する基本的な構造を何と呼ぶか。",
    "choices": [
      {
        "id": "a",
        "text": "テーブル（表）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "関係データベース（リレーショナルデータベース）では、データを行（レコード）と列（フィールド）で構成される「テーブル（表）」に格納します。テーブルは関係データベースの最も基本的なデータ構造です。",
          "analogy": "Excel の表（スプレッドシート）と同じようなイメージです。列が「名前」「年齢」「住所」などの項目で、行が一人ひとりのデータにあたります。",
          "deepDive": "関係データベースでは、テーブルのことを数学的には「リレーション（関係）」と呼びます。行を「タプル」、列を「属性（アトリビュート）」とも呼びます。テーブル同士は主キーと外部キーを使って関連付け（リレーションシップ）を持たせることができます。"
        }
      },
      {
        "id": "b",
        "text": "インデックス（索引）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "インデックスはデータの検索速度を向上させるための補助的な仕組みであり、データを格納する基本構造ではありません。",
          "analogy": "本の索引（巻末のあいうえお順リスト）のようなもので、本文そのもの（データ）ではなく、素早く探すための補助です。"
        }
      },
      {
        "id": "c",
        "text": "ビュー（視点）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ビューは既存のテーブルから必要なデータだけを取り出して表示する仮想的なテーブルです。データの格納構造ではなく、見せ方を定義するものです。",
          "analogy": "窓から外を見ると景色が見えますが、窓は景色そのものではありません。ビューはデータの「見方」を定義するものです。"
        }
      },
      {
        "id": "d",
        "text": "スキーマ（構造定義）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "スキーマはデータベース全体の構造や制約を定義するものですが、データを直接格納する構造ではありません。テーブルやビューなどの定義をまとめたものがスキーマです。",
          "analogy": "家の設計図（スキーマ）は建物の構造を示しますが、実際に人が住む部屋（テーブル）とは別物です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "関係データベースでは、データをテーブル（表）という構造に格納します。テーブルは行（レコード）と列（フィールド）で構成されます。",
      "keyPoint": "関係データベースの基本構造＝テーブル（行と列で構成される表）",
      "relatedTopics": ["主キー", "外部キー", "リレーションシップ", "SQL"],
      "studyTip": "関係データベースの用語には日常用語と数学用語の2種類があるので、対応関係を覚えましょう（テーブル＝リレーション、行＝タプル、列＝属性）。"
    },
    "tags": ["データベース基礎", "リレーショナルデータベース", "テーブル"]
  },
  {
    "questionId": "q-db-002",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "データベース基礎",
    "level": 1,
    "question": "関係データベースにおいて、各行を一意に識別するための列を何と呼ぶか。",
    "choices": [
      {
        "id": "a",
        "text": "外部キー",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "外部キーは他のテーブルの主キーを参照する列であり、テーブル間の関連を表現するためのものです。そのテーブル自体の行を一意に識別するためのものではありません。",
          "analogy": "外部キーは「友達の住所」を自分の住所録に書いておくようなもので、自分自身のID（主キー）とは別物です。"
        }
      },
      {
        "id": "b",
        "text": "主キー",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "主キー（プライマリキー）は、テーブル内の各行（レコード）を一意に識別するための列（または列の組み合わせ）です。主キーの値は一意で、NULL値は許可されません。",
          "analogy": "学校の出席番号のようなものです。クラスの中で同じ番号の人はいないので、番号を言えば誰のことかすぐわかります。出席番号が空（NULL）ということもありません。",
          "deepDive": "主キーの条件は①一意性（同じ値が存在しない）②非NULL（空値を許可しない）です。複数の列を組み合わせて主キーにすることを「複合主キー」と呼びます。また、主キーの候補となりうる列を「候補キー」と呼びます。"
        }
      },
      {
        "id": "c",
        "text": "候補キー",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "候補キーはテーブル内で一意性を持つ列の組み合わせですが、その中から実際に行の識別に使うとして選ばれたものが主キーになります。候補キーは複数存在し得ますが、主キーは1つだけ選ばれます。",
          "analogy": "社員番号もメールアドレスも候補キーになり得ますが、公式な識別番号として社員番号を主キーに選ぶようなイメージです。"
        }
      },
      {
        "id": "d",
        "text": "インデックスキー",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "インデックスキーはインデックス（索引）を作成するために指定する列です。検索を高速化するための仕組みであり、行の一意識別を目的としたものではありません。",
          "analogy": "辞書の見出し語のようなもので、素早く探すためのものですが、必ずしもページを一意に特定するものではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "主キーは関係データベースにおいてテーブルの各行を一意に識別するための列です。一意性の保証とNULL値の禁止が条件です。",
      "keyPoint": "主キー＝各行を一意に識別する列（一意・非NULL）",
      "relatedTopics": ["外部キー", "候補キー", "複合主キー", "正規化"],
      "studyTip": "主キー・外部キー・候補キーの違いを整理して覚えましょう。"
    },
    "tags": ["データベース基礎", "主キー", "キー制約"]
  },
  {
    "questionId": "q-db-003",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "正規化",
    "level": 2,
    "question": "第1正規形の条件として、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "すべての列が主キーに完全関数従属している",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "すべての非キー属性が主キーに完全関数従属していることは、第2正規形の条件です。第1正規形はそこまで求めません。",
          "analogy": "第1正規形は「部屋の荷物を全部棚に入れる」段階で、第2正規形は「同じ棚の中で種類別に分ける」段階です。"
        }
      },
      {
        "id": "b",
        "text": "すべての列の値が原子的（これ以上分割できない）である",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "第1正規形の条件は、テーブルのすべての列の値が原子的（スカラ値）であること、つまり1つのセルに1つの値だけが入っていることです。繰り返し項目や複数の値を含むセルがない状態です。",
          "analogy": "住所録で「電話番号」の欄に複数の電話番号をカンマ区切りで入れるのではなく、1つの欄に1つの電話番号だけを入れるということです。弁当箱の仕切りのように、1マスに1つのおかずだけ入れるイメージです。",
          "deepDive": "第1正規形にするには、繰り返し項目を別テーブルに分離します。例えば「注文テーブル」に複数の商品を入れている場合、「注文テーブル」と「注文明細テーブル」に分割します。正規化は第1→第2→第3正規形と段階的に進めます。"
        }
      },
      {
        "id": "c",
        "text": "推移的関数従属が存在しない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "推移的関数従属の排除は第3正規形の条件です。第1正規形はデータの原子性のみを求めます。",
          "analogy": "第3正規形は「直接の関係だけを残して、間接的な関係は別のテーブルに移す」段階で、第1正規形よりずっと進んだ整理です。"
        }
      },
      {
        "id": "d",
        "text": "テーブル間のリレーションシップが定義されている",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "テーブル間のリレーションシップの定義は正規化の条件ではなく、データベース設計の一部です。正規化はテーブル内のデータ構造を整理する作業です。",
          "analogy": "正規化は部屋の整理整頓であって、部屋と部屋をつなぐ廊下の設計とは別の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "第1正規形の条件は、すべての列の値が原子的（これ以上分割できない1つの値）であることです。繰り返し項目や複数値を含むセルがない状態にします。",
      "keyPoint": "第1正規形＝すべての列が原子的な値（1セル1データ）",
      "relatedTopics": ["第2正規形", "第3正規形", "関数従属", "正規化の手順"],
      "studyTip": "第1～第3正規形の条件を段階的に覚え、各段階で何を排除するかを整理しましょう。"
    },
    "tags": ["正規化", "第1正規形", "データベース設計"]
  },
  {
    "questionId": "q-db-004",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "SQL",
    "level": 2,
    "question": "SQL文において、テーブルからデータを取得するために使用するコマンドはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "INSERT",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "INSERTはテーブルに新しい行（レコード）を追加するためのコマンドです。データの取得には使用しません。",
          "analogy": "本棚に新しい本を入れる（追加する）操作であり、本を読む（取得する）操作ではありません。"
        }
      },
      {
        "id": "b",
        "text": "UPDATE",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "UPDATEはテーブル内の既存データを更新（書き換え）するためのコマンドです。データの取得には使用しません。",
          "analogy": "ノートの内容を書き換える操作であり、読む操作ではありません。"
        }
      },
      {
        "id": "c",
        "text": "SELECT",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "SELECTはテーブルからデータを検索・取得するためのSQL文です。WHERE句で条件を指定したり、ORDER BY句でソートしたり、GROUP BY句で集計したりすることもできます。",
          "analogy": "図書館で本を探して借りる（読む）操作のようなものです。「SELECT 書名 FROM 書棚 WHERE ジャンル = '小説'」のように、条件に合う本を選び出します。",
          "deepDive": "SELECT文の基本構文は「SELECT 列名 FROM テーブル名 WHERE 条件」です。主な句には、DISTINCT（重複排除）、JOIN（テーブル結合）、GROUP BY（グループ化）、HAVING（グループ条件）、ORDER BY（並び替え）、LIMIT（件数制限）などがあります。"
        }
      },
      {
        "id": "d",
        "text": "DELETE",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "DELETEはテーブルから行（レコード）を削除するためのコマンドです。データの取得には使用しません。",
          "analogy": "本棚から本を捨てる操作であり、本を読む操作ではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "SELECT文はテーブルからデータを検索・取得するためのSQL文です。INSERT（追加）、UPDATE（更新）、DELETE（削除）と合わせてSQLの基本4操作（CRUD）を構成します。",
      "keyPoint": "データ取得＝SELECT、追加＝INSERT、更新＝UPDATE、削除＝DELETE",
      "relatedTopics": ["WHERE句", "JOIN", "GROUP BY", "ORDER BY"],
      "studyTip": "SQLの基本4操作（CRUD: Create=INSERT, Read=SELECT, Update=UPDATE, Delete=DELETE）をセットで覚えましょう。"
    },
    "tags": ["SQL", "SELECT", "CRUD"]
  },
  {
    "questionId": "q-db-005",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "トランザクション",
    "level": 3,
    "question": "トランザクションのACID特性のうち、「一貫性（Consistency）」の説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "トランザクションの処理結果は、すべて実行されるか、すべて取り消されるかのどちらかである",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは原子性（Atomicity）の説明です。トランザクションが「全か無か」で処理されることを保証する特性です。",
          "analogy": "銀行振込で「送金」と「入金」が両方完了するか、両方キャンセルされるかのどちらかという性質は原子性です。"
        }
      },
      {
        "id": "b",
        "text": "トランザクションの実行前後でデータベースの整合性が保たれる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "一貫性（Consistency）は、トランザクションの実行によりデータベースが一貫した状態から別の一貫した状態に遷移することを保証する特性です。制約条件やビジネスルールに違反するデータ変更は許可されません。",
          "analogy": "家計簿で収入と支出を記録した後、合計金額が正しく計算されている状態です。「給料20万円入金」「家賃8万円支出」の後、残高が12万円増えているべきで、つじつまが合わない状態にはなりません。",
          "deepDive": "一貫性は、主キー制約、外部キー制約、チェック制約、一意制約などのデータベースの整合性制約が常に満たされることを意味します。例えば、外部キーが参照する先のレコードが存在しない状態は一貫性違反です。アプリケーション側のビジネスロジックによる一貫性の保証も重要です。"
        }
      },
      {
        "id": "c",
        "text": "複数のトランザクションが同時に実行されても、結果は逐次実行した場合と同じになる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは独立性（Isolation）の説明です。複数のトランザクションが互いに干渉しないことを保証する特性です。",
          "analogy": "ATMで同時に操作しても、順番に処理したのと同じ結果になるという性質は独立性です。"
        }
      },
      {
        "id": "d",
        "text": "トランザクションが正常に完了した結果は、障害が発生しても失われない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは耐久性（Durability）の説明です。コミットされたデータがシステム障害後も保持されることを保証する特性です。",
          "analogy": "銀行に預けたお金が停電しても消えないという性質は耐久性です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ACID特性のうち一貫性（Consistency）は、トランザクション実行前後でデータベースの整合性が保たれることを保証します。原子性（A）は全か無、独立性（I）は同時実行の正しさ、耐久性（D）は障害後の保持を保証します。",
      "keyPoint": "一貫性＝トランザクション前後でデータベースの整合性制約が常に満たされる",
      "relatedTopics": ["原子性", "独立性", "耐久性", "コミット", "ロールバック"],
      "studyTip": "ACID特性は頭文字と意味を対応させて覚え、それぞれの具体例を1つ用意しておくと効果的です。"
    },
    "tags": ["トランザクション", "ACID特性", "一貫性"]
  },
  {
    "questionId": "q-db-006",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "SQL",
    "level": 3,
    "question": "次のSQL文の実行結果として正しいものはどれか。\n\nSELECT COUNT(*) FROM 社員 WHERE 部門 = '営業' OR 部門 = '技術'\n\n※社員テーブルには以下のデータがある：\n社員番号 | 名前 | 部門\n001 | 田中 | 営業\n002 | 佐藤 | 技術\n003 | 鈴木 | 総務\n004 | 高橋 | 営業\n005 | 山田 | 技術",
    "choices": [
      {
        "id": "a",
        "text": "2",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "2は営業部門だけ、または技術部門だけのカウントです。OR条件により両方の部門が対象となるため、2では少なすぎます。",
          "analogy": "「りんご」と「みかん」の両方を数えるのに、片方だけ数えてしまっている状態です。"
        }
      },
      {
        "id": "b",
        "text": "4",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "WHERE句のOR条件により、部門が「営業」または「技術」の行が抽出されます。営業は田中・高橋の2名、技術は佐藤・山田の2名で、合計4名です。COUNT(*)は該当する行数をカウントします。",
          "analogy": "クラスで「サッカー部」または「野球部」の人数を数えるようなものです。どちらかに所属している人を全員数えると4人になります。",
          "deepDive": "COUNT(*)はNULL値を含むすべての行を数えます。COUNT(列名)を使うとNULLの行は除外されます。OR条件の代わりにIN句を使って「WHERE 部門 IN ('営業', '技術')」と書くこともできます。"
        }
      },
      {
        "id": "c",
        "text": "5",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "5はテーブル全体の行数です。WHERE句で条件を指定しているため、条件に合わない「総務」の鈴木は含まれません。",
          "analogy": "条件を無視してクラス全員を数えてしまっている状態です。"
        }
      },
      {
        "id": "d",
        "text": "3",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "3は総務を除いた部門数などの誤った解釈による結果です。COUNT(*)は行数をカウントするため、条件に合う行は4行です。",
          "analogy": "数え方を間違えて1人飛ばしてしまっている状態です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "COUNT(*)はWHERE句の条件に合致する行の数を返します。OR条件で「営業」と「技術」の両方が対象となり、4行が該当します。",
      "keyPoint": "COUNT(*)は条件に合う行の総数を返す。OR条件は「どちらかに該当」",
      "relatedTopics": ["集約関数", "WHERE句", "GROUP BY", "IN句"],
      "studyTip": "SQL文は実際にテーブルのデータを手で追って結果を確認する練習をすると理解が深まります。"
    },
    "tags": ["SQL", "COUNT", "WHERE", "集約関数"]
  },
  {
    "questionId": "q-db-007",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "正規化",
    "level": 4,
    "question": "第2正規形から第3正規形に変換する際に排除する関数従属はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "繰り返し項目",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "繰り返し項目の排除は、非正規形から第1正規形への変換で行います。第2正規形から第3正規形の変換とは関係ありません。",
          "analogy": "荷物を箱に詰める（第1正規化）段階の話であり、箱の中を整理する段階（第3正規化）の話ではありません。"
        }
      },
      {
        "id": "b",
        "text": "部分関数従属",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "部分関数従属の排除は、第1正規形から第2正規形への変換で行います。主キーの一部にだけ従属する非キー属性を別テーブルに分離する操作です。",
          "analogy": "教科書を科目別に分ける（第2正規化）段階の話で、さらに細かく分類する（第3正規化）段階ではありません。"
        }
      },
      {
        "id": "c",
        "text": "推移的関数従属",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "第3正規形への変換では推移的関数従属を排除します。推移的関数従属とは「A→B→C」のように、主キーAに従属するBを経由してCが間接的に従属している関係です。この場合、BとCの関係を別テーブルに分離します。",
          "analogy": "社員番号→部門コード→部門名という関係があるとき、「社員テーブル」に部門名を直接持たせるのではなく、「部門テーブル」を作って部門コードと部門名を管理します。住所で例えると、郵便番号→都道府県のように、間接的に決まる情報は別の表にまとめるイメージです。",
          "deepDive": "推移的関数従属を残しておくと、更新異常（部門名を変更する際に全社員レコードを更新する必要がある）、挿入異常（社員がいない部門を登録できない）、削除異常（最後の社員を削除すると部門情報も消える）が発生します。これらの異常を解消するのが第3正規化の目的です。"
        }
      },
      {
        "id": "d",
        "text": "多値従属",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "多値従属の排除は第4正規形の条件です。基本情報技術者試験では第3正規形までが主な出題範囲です。",
          "analogy": "第4正規形はさらに高度な整理整頓で、基本的な片付け（第3正規化）の先にある話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "第3正規形への変換では推移的関数従属を排除します。推移的関数従属とは、主キー以外の列を経由して間接的に決まる関係のことです。",
      "keyPoint": "第3正規化＝推移的関数従属の排除（A→B→Cの間接的な従属を分離）",
      "relatedTopics": ["第1正規形", "第2正規形", "関数従属", "更新異常"],
      "studyTip": "正規化の各段階で「何を排除するか」を整理しましょう。第1＝繰り返し、第2＝部分関数従属、第3＝推移的関数従属。"
    },
    "tags": ["正規化", "第3正規形", "推移的関数従属"]
  },
  {
    "questionId": "q-db-008",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "排他制御",
    "level": 4,
    "question": "データベースの排他制御で、デッドロックが発生する状況として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "1つのトランザクションが複数のテーブルを同時にロックすること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1つのトランザクションが複数のテーブルをロックすること自体はデッドロックではありません。複数のトランザクションが互いのロックを待ち合う状態がデッドロックです。",
          "analogy": "1人で複数の部屋の鍵を持つのは問題ありません。問題は2人が互いの部屋の鍵を持ち合って動けなくなることです。"
        }
      },
      {
        "id": "b",
        "text": "2つのトランザクションが互いに相手のロックしている資源の解放を待ち続けること",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "デッドロックは、2つ以上のトランザクションが互いに相手がロックしている資源を必要とし、お互いに相手のロック解放を永久に待ち続ける状態です。例えば、トランザクションAがテーブル1をロックしてテーブル2を要求し、トランザクションBがテーブル2をロックしてテーブル1を要求する場合に発生します。",
          "analogy": "狭い通路で2人が向かい合って「あなたが先にどいてください」と言い合って、どちらも動けなくなる状態です。AさんがBさんの持つ本を待ち、BさんがAさんの持つ本を待って、永遠に待ち続けてしまいます。",
          "deepDive": "デッドロックの対処方法には①予防（ロックの順序を統一する）②検出と回復（タイムアウトやデッドロック検出アルゴリズムで検出し、一方のトランザクションをロールバック）③回避（資源割り当てグラフで安全性を確認）があります。多くのDBMSはタイムアウトによるデッドロック検出機能を備えています。"
        }
      },
      {
        "id": "c",
        "text": "トランザクションが長時間実行されてタイムアウトすること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "タイムアウトは長時間実行による処理の中断であり、デッドロックとは異なります。ただし、タイムアウトはデッドロックの検出手段として使用されることがあります。",
          "analogy": "1人で作業に時間がかかりすぎて中断されるのと、2人で動けなくなるのとは別の問題です。"
        }
      },
      {
        "id": "d",
        "text": "ロックの粒度が大きすぎてパフォーマンスが低下すること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ロックの粒度の問題はパフォーマンスに関する問題であり、デッドロックとは直接関係ありません。粒度が大きいとロック競合は増えますが、必ずしもデッドロックにはなりません。",
          "analogy": "部屋全体を予約するのか席だけ予約するのかの話で、お互いに待ち合う状態とは別の問題です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "デッドロックは、複数のトランザクションが互いに相手のロックしている資源の解放を待ち続け、どちらも処理を進められなくなる状態です。",
      "keyPoint": "デッドロック＝複数のトランザクションが互いのロック解放を無限に待ち合う状態",
      "relatedTopics": ["排他制御", "ロック", "トランザクション", "ロールバック"],
      "studyTip": "デッドロックの具体例（AがX→Yの順、BがY→Xの順でロック）を図に描いて理解しましょう。"
    },
    "tags": ["排他制御", "デッドロック", "ロック", "トランザクション"]
  },
  {
    "questionId": "q-db-009",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "トランザクション",
    "level": 5,
    "question": "データベースの障害回復において、チェックポイント以降にコミットされたトランザクションに対して行う処理はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ロールバック（後退復帰）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ロールバックはコミットされていないトランザクションに対して行う処理です。コミット済みのトランザクションをロールバックすると、正常に完了した処理まで取り消してしまいます。",
          "analogy": "すでに提出して受理された書類（コミット済み）を取り消す必要はありません。取り消すのは未提出の書類（未コミット）です。"
        }
      },
      {
        "id": "b",
        "text": "ロールフォワード（前進復帰）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ロールフォワードは、チェックポイント時点のデータベースにトランザクションログ（ジャーナル）の更新後ログを順に適用して、コミット済みのトランザクションの結果を復元する処理です。障害発生直前のコミット済み状態まで復旧できます。",
          "analogy": "ゲームのセーブポイント（チェックポイント）から、記録しておいた操作メモ（ログ）を見ながら同じ操作を再現して、最後にセーブした状態まで戻す作業です。すでにクリアしたステージ（コミット済み）の結果は確実に復元します。",
          "deepDive": "障害回復の流れは①チェックポイント時点のデータベースをバックアップから復元 ②ログファイルからチェックポイント以降のコミット済みトランザクションの更新後ログを抽出 ③更新後ログを順に適用（ロールフォワード）④未コミットのトランザクションの更新前ログを使ってロールバック。WAL（Write-Ahead Logging）プロトコルにより、更新前にログが書き出されることが保証されています。"
        }
      },
      {
        "id": "c",
        "text": "リストア（バックアップからの復元）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "リストアはバックアップからデータベース全体を復元する処理です。チェックポイント以降の個別のトランザクションの復旧には、ログを使ったロールフォワードが必要です。",
          "analogy": "リストアはセーブポイントに戻るだけで、その後の進捗は反映されません。ロールフォワードでその後の操作を再現する必要があります。"
        }
      },
      {
        "id": "d",
        "text": "再実行（トランザクションの再投入）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "トランザクションを再投入する方法は、データベースの標準的な障害回復手法ではありません。ログベースの回復（ロールフォワード/ロールバック）が正しい手法です。",
          "analogy": "メモを見ながら正確に再現する（ロールフォワード）のではなく、もう一度最初からやり直すのは非効率で、結果が異なる可能性もあります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "障害回復において、チェックポイント以降にコミットされたトランザクションにはロールフォワード（前進復帰）を行います。ログの更新後情報を使って、コミット済みの結果を復元します。",
      "keyPoint": "コミット済み＝ロールフォワード（前進復帰）、未コミット＝ロールバック（後退復帰）",
      "relatedTopics": ["チェックポイント", "ジャーナルファイル", "WAL", "バックアップ"],
      "studyTip": "障害回復の図を描いて、チェックポイント・障害発生時点・各トランザクションの開始/コミット位置の関係を理解しましょう。"
    },
    "tags": ["障害回復", "ロールフォワード", "チェックポイント", "トランザクション"]
  },
  {
    "questionId": "q-db-010",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "排他制御",
    "level": 5,
    "question": "データベースの排他制御において、共有ロックと専有ロックの組み合わせとして正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "共有ロック同士は同時に設定でき、共有ロックと専有ロックは同時に設定できない",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "共有ロック（読み取りロック）同士は互いに競合しないため、複数のトランザクションが同時に設定できます。一方、専有ロック（書き込みロック）は他のあらゆるロックと競合するため、共有ロックとも専有ロックとも同時に設定できません。",
          "analogy": "図書館の閲覧室のようなものです。本を「読むだけ」（共有ロック）なら複数の人が同時に同じ本の写しを読めます。しかし「書き込む」（専有ロック）ときは、他の人が読んでいても書き込んでいても、原本を1人で独占する必要があります。",
          "deepDive": "ロックの互換性マトリクスは以下の通りです。共有-共有：○（同時設定可）、共有-専有：×（競合）、専有-共有：×（競合）、専有-専有：×（競合）。この仕組みにより、読み取り操作の並行性を確保しつつ、書き込み操作の一貫性を保証します。2相ロックプロトコルでは、ロックの獲得フェーズと解放フェーズを分離して直列化可能性を保証します。"
        }
      },
      {
        "id": "b",
        "text": "共有ロック同士も専有ロック同士も同時に設定できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "専有ロック同士は同時に設定できません。2つのトランザクションが同じデータに同時に書き込むと、データの一貫性が失われる可能性があるためです。",
          "analogy": "2人が同時に同じノートに書き込むと内容がぐちゃぐちゃになるので、書き込み（専有ロック）同士は同時にできません。"
        }
      },
      {
        "id": "c",
        "text": "共有ロックも専有ロックも、他のロックとは同時に設定できない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "共有ロック同士は同時に設定可能です。読み取り操作は他の読み取り操作と競合しないため、並行して実行できます。",
          "analogy": "同じ本を複数の人が同時に読むことは問題ないので、読み取り（共有ロック）同士まで禁止する必要はありません。"
        }
      },
      {
        "id": "d",
        "text": "専有ロック同士は同時に設定でき、共有ロックと専有ロックは同時に設定できない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "専有ロック同士は同時に設定できません。書き込み操作同士が競合するのは直感的にも理解できます。一方、この選択肢は共有-専有の関係は正しく述べています。",
          "analogy": "2人が同時に同じ壁にペンキを塗ったら色が混ざってしまいます。書き込み同士は同時にできません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "共有ロック（読み取り）同士は同時に設定可能ですが、専有ロック（書き込み）は他のすべてのロックと競合します。これにより読み取りの並行性と書き込みの一貫性を両立します。",
      "keyPoint": "共有-共有＝同時OK、共有-専有＝競合、専有-専有＝競合",
      "relatedTopics": ["デッドロック", "2相ロック", "楽観的排他制御", "トランザクション分離レベル"],
      "studyTip": "ロックの互換性を2×2のマトリクス表にして覚えると、試験で迷わず解答できます。"
    },
    "tags": ["排他制御", "共有ロック", "専有ロック", "ロック互換性"]
  }
]