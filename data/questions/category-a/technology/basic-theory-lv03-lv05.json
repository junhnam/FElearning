[
  {
    "questionId": "q-bt-013",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "集合と論理演算",
    "level": 3,
    "question": "全体集合Uの要素数が20、集合Aの要素数が12、集合Bの要素数が10、A∩Bの要素数が4のとき、A∪Bの要素数はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "16",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "16は12+10-4=18を誤って計算したか、別の値を参照した結果です。和集合の公式 |A∪B| = |A| + |B| - |A∩B| を正しく適用すると18になります。",
          "analogy": "クラスで「数学が得意な人12人」と「英語が得意な人10人」がいて、両方得意な人が4人いるとき、どちらか得意な人の総数は12+10-4=18人です。4人を2回数えているので引きます。"
        }
      },
      {
        "id": "b",
        "text": "18",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "和集合の公式 |A∪B| = |A| + |B| - |A∩B| を使います。12 + 10 - 4 = 18 となります。A∩B（積集合）の要素はAにもBにも属するため、単純に足すと2重に数えてしまうので1回分を引きます。",
          "analogy": "「犬を飼っている家庭12軒」と「猫を飼っている家庭10軒」があり、両方飼っている家庭が4軒の場合、ペットを飼っている家庭の総数は12+10-4=18軒です。",
          "deepDive": "集合の包除原理（Inclusion-Exclusion Principle）です。2つの集合の場合：|A∪B| = |A| + |B| - |A∩B|。3つの集合になると |A∪B∪C| = |A|+|B|+|C| - |A∩B| - |B∩C| - |A∩C| + |A∩B∩C| と拡張されます。"
        }
      },
      {
        "id": "c",
        "text": "20",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "20は全体集合Uの要素数です。A∪BはUと等しくなるとは限りません。A∪B = Uとなるのは、U内のすべての要素がAまたはBに属する場合だけです。",
          "analogy": "学校全体が20人でも、数学か英語が得意な人が全員とは限りません。苦手な人もいる可能性があります。"
        }
      },
      {
        "id": "d",
        "text": "22",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "22は12+10=22と単純に足した結果です。A∩Bの要素がAとBの両方に含まれているため、重複分の4を引く必要があります。引き忘れると22になってしまいます。",
          "analogy": "「数学クラブ12人と英語クラブ10人を合わせると22人」と言うのは、両方に所属している4人を2回数えているため間違いです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "和集合の要素数は |A∪B| = |A| + |B| - |A∩B| という公式で求めます。積集合（重複部分）を引かないと二重計算になります。",
      "keyPoint": "包除原理：|A∪B| = |A| + |B| - |A∩B|。積集合を引くのは「重複を1回分だけ数えるため」。",
      "relatedTopics": [
        "ベン図",
        "補集合",
        "差集合",
        "包除原理"
      ],
      "studyTip": "ベン図を描いて視覚化するのが一番わかりやすいです。円の重なり部分がA∩B、全体の塗られた部分がA∪Bです。"
    },
    "tags": [
      "集合",
      "和集合",
      "積集合",
      "包除原理",
      "論理演算"
    ]
  },
  {
    "questionId": "q-bt-014",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "ビット演算",
    "level": 3,
    "question": "8ビットの2進数「10110100」に対して、マスク「00001111」でAND演算を行った結果はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "00000100",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "AND演算は両方のビットが1のときだけ1になります。上位4ビット（1011）はマスクの上位4ビット（0000）とANDをとるとすべて0になります。下位4ビット（0100）はマスクの下位4ビット（1111）とANDをとると（0100）になります。結果は00000100です。",
          "analogy": "「窓から外を見る」ようなものです。マスク（カーテン）の穴が開いている部分（1111）だけ元の景色（0100）が見え、カーテンで覆われた部分（0000）は何も見えません（0000）。",
          "deepDive": "AND演算はビットマスキングの基本技術です。特定のビットだけを取り出したい場合に使います。取り出したいビット位置を1、隠したいビット位置を0にしたマスクでAND演算することで、特定ビットのみ抽出できます。これをビット抽出（マスキング）と呼びます。"
        }
      },
      {
        "id": "b",
        "text": "10110000",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはAND演算ではなく、上位ビットをそのまま残した結果です。AND演算では、マスクが0のビット位置は必ず0になります。マスクの下位4ビットが1111なので、下位4ビットは元のデータがそのまま残ります。",
          "analogy": "カーテンで覆われた部分（0000）が消えるのはわかっていても、穴の開いた部分（1111）で何が見えるかを間違えています。"
        }
      },
      {
        "id": "c",
        "text": "10111111",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはAND演算ではなくOR演算に近い結果です。AND演算では両方が1のときだけ1になります。マスクの0のビット位置は、元データが何であっても結果は0になります。",
          "analogy": "AND演算は「両方がOKの場合だけOK」というルールです。どちらか一方がOKならOKというOR演算とは違います。"
        }
      },
      {
        "id": "d",
        "text": "00001011",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは元データの上位4ビット（1011）を下位に移動させた値ですが、AND演算ではそのような操作は行われません。下位4ビットは元データの下位4ビット（0100）とマスク（1111）のANDなので0100になります。",
          "analogy": "AND演算はビットを移動させる操作ではありません。各ビットの位置はそのままで、値が0か1かが決まります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "AND演算は両方のビットが1のときだけ1になります。マスクの0ビット位置は必ず0、マスクの1ビット位置は元データのビットがそのまま残ります。",
      "keyPoint": "ANDマスキング：取り出したいビット位置を1にしたマスクでANDをとると、そのビットだけを抽出できる。",
      "relatedTopics": [
        "OR演算",
        "XOR演算",
        "NOT演算",
        "シフト演算",
        "ビットマスク"
      ],
      "studyTip": "AND=「かつ（両方1）」、OR=「または（どちらか1）」、XOR=「排他的OR（一方だけ1）」と覚えましょう。真理値表を書いて確認する習慣をつけるとよいです。"
    },
    "tags": [
      "ビット演算",
      "AND演算",
      "マスキング",
      "2進数"
    ]
  },
  {
    "questionId": "q-bt-015",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "基数変換（小数）",
    "level": 3,
    "question": "10進数の「0.625」を2進数に変換した値はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "0.101",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "小数の2進数変換は、2を繰り返しかけて整数部分を取り出します。0.625×2=1.25（1を取り出す）→ 0.25×2=0.5（0を取り出す）→ 0.5×2=1.0（1を取り出す）。取り出した順に並べると0.101となります。確認：1×2⁻¹ + 0×2⁻² + 1×2⁻³ = 0.5 + 0 + 0.125 = 0.625。",
          "analogy": "お釣りを出すように考えます。0.625円を「0.5円・0.25円・0.125円」の硬貨で払います。まず0.5円（1枚必要=1）、残り0.125円。次に0.25円（不要=0）、最後に0.125円（1枚必要=1）。結果は0.101です。",
          "deepDive": "2進小数への変換は「×2して整数部分を取り出す」を繰り返します。2⁻¹=0.5、2⁻²=0.25、2⁻³=0.125 という重みを使って表現します。10進小数のすべてが有限の2進小数に変換できるわけではなく、0.1（10進）は2進数では無限小数になります。"
        }
      },
      {
        "id": "b",
        "text": "0.110",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.110（2進）= 0.5 + 0.25 + 0 = 0.75（10進）です。0.625とは異なります。計算過程で×2した結果を間違えた可能性があります。",
          "analogy": "0.5円と0.25円を使うと0.75円になります。0.625円とは0.125円分違います。"
        }
      },
      {
        "id": "c",
        "text": "0.011",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.011（2進）= 0 + 0.25 + 0.125 = 0.375（10進）です。0.625とは異なります。最初のステップで0.625×2=1.25から「1」を取り出すのを忘れた場合にこのような結果になります。",
          "analogy": "最初に0.5円の硬貨（最大の硬貨）を使い忘れると、残りの金額が合わなくなります。"
        }
      },
      {
        "id": "d",
        "text": "0.111",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.111（2進）= 0.5 + 0.25 + 0.125 = 0.875（10進）です。0.625とは異なります。すべてのビットを1にしてしまっています。",
          "analogy": "0.5円・0.25円・0.125円の硬貨を全部使うと0.875円になります。0.625円には0.25円は使いません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "10進小数を2進小数に変換するには、×2を繰り返して整数部分（0または1）を順番に取り出します。",
      "keyPoint": "小数の変換手順：①×2 ②整数部分を記録 ③残りの小数部分を使って①に戻る。取り出した整数部分を左から順に並べると2進小数になる。",
      "relatedTopics": [
        "2進数と10進数の変換",
        "16進数への変換",
        "浮動小数点"
      ],
      "studyTip": "2⁻¹=0.5、2⁻²=0.25、2⁻³=0.125、2⁻⁴=0.0625 を覚えておくと、変換結果の検算に役立ちます。"
    },
    "tags": [
      "基数変換",
      "小数変換",
      "2進数",
      "10進数"
    ]
  },
  {
    "questionId": "q-bt-016",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "確率・統計基礎",
    "level": 3,
    "question": "1から6の目が出るサイコロを1回振ったとき、偶数または3の倍数の目が出る確率はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "1/2",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1/2は偶数（2,4,6）だけの確率です。3の倍数（3,6）も含めて考える必要があります。「または」は和集合なので、重複を除いた該当する目の数を数えます。",
          "analogy": "「偶数のお客さん」と「3の倍数のお客さん」両方を合わせた人数を求めるとき、偶数だけのお客さんを数えると漏れが出ます。"
        }
      },
      {
        "id": "b",
        "text": "2/3",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "偶数の目：{2, 4, 6}（3個）、3の倍数の目：{3, 6}（2個）、重複（偶数かつ3の倍数）：{6}（1個）。和集合の公式より、3+2-1=4個の目が該当します。確率は4/6=2/3です。",
          "analogy": "クラスで「背が高い人3人」と「足が速い人2人」がいて、1人が両方に該当する場合、どちらかに該当する人は3+2-1=4人です。",
          "deepDive": "確率の和の法則：P(A∪B) = P(A) + P(B) - P(A∩B)。偶数の確率P(A)=3/6、3の倍数の確率P(B)=2/6、両方の確率P(A∩B)=1/6（6のみ）。3/6 + 2/6 - 1/6 = 4/6 = 2/3。"
        }
      },
      {
        "id": "c",
        "text": "5/6",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "5/6は1以外の目（2,3,4,5,6）の確率ですが、5（偶数でも3の倍数でもない）を含めてしまっています。偶数（2,4,6）と3の倍数（3,6）に該当するのは{2,3,4,6}の4つです。5は該当しません。",
          "analogy": "「1以外は全部OK」と「偶数または3の倍数」は違うルールです。5は偶数でも3の倍数でもないので含まれません。"
        }
      },
      {
        "id": "d",
        "text": "1/6",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1/6は偶数かつ3の倍数（積集合、つまり6だけ）の確率です。「または」（和集合）ではなく「かつ」（積集合）の確率を計算してしまっています。",
          "analogy": "「背が高い、かつ足が速い人」は1人だけでも、「背が高い、または足が速い人」は4人います。「または」と「かつ」を混同しないようにしましょう。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "「AまたはB」の確率は P(A∪B) = P(A) + P(B) - P(A∩B)。重複している要素を1回だけ数えるために積集合の確率を引きます。",
      "keyPoint": "P(A∪B) = P(A) + P(B) - P(A∩B)。「または」は引き算で調整が必要。",
      "relatedTopics": [
        "集合の包除原理",
        "条件付き確率",
        "余事象の確率",
        "独立事象"
      ],
      "studyTip": "集合論と確率は対応しています。A∪B=「または」、A∩B=「かつ」、Aの補集合=「Aでない」と対応させて覚えましょう。"
    },
    "tags": [
      "確率",
      "統計",
      "和事象",
      "包除原理",
      "集合"
    ]
  },
  {
    "questionId": "q-bt-017",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "情報量の単位",
    "level": 3,
    "question": "1GBのストレージに1KBのファイルは最大何個格納できるか。ただし、1KB=1024B、1MB=1024KB、1GB=1024MBとする。",
    "choices": [
      {
        "id": "a",
        "text": "約100万個",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1GBをKBに変換すると1024×1024=1,048,576KBです。約100万は1,000,000であり、正確な値（約104万8576個）に比べて少し少ない概算です。厳密には約104万個が正しいです。",
          "analogy": "1GBの倉庫に1KB分の箱を詰めるとき、「だいたい100万個」は少し少なく見積もっています。"
        }
      },
      {
        "id": "b",
        "text": "約104万個",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "1GBをKBに変換します。1GB = 1024MB = 1024×1024KB = 1,048,576KB。よって1KBのファイルは最大1,048,576個≒約104万個格納できます。1024×1024=2¹⁰×2¹⁰=2²⁰=1,048,576です。",
          "analogy": "1GBの倉庫（1024個の棚があり、それぞれに1024個の箱が入る）に1KBサイズの荷物を詰めると、最大1024×1024=約104万個入ります。",
          "deepDive": "コンピュータの単位はすべて2の累乗です。1KB=2¹⁰B=1024B、1MB=2²⁰B、1GB=2³⁰B。1GB÷1KB=2³⁰÷2¹⁰=2²⁰=1,048,576となります。2¹⁰≈10³=1000（千）なので、2²⁰≈10⁶=100万と概算できます。"
        }
      },
      {
        "id": "c",
        "text": "約1億個",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1億（100,000,000）は正しい答え（約1,048,576個）の約100倍です。1GBをBに変換せず、単位の関係を誤って計算した場合にこのような結果になります。",
          "analogy": "1GBの倉庫に1KBの荷物を詰める計算で、単位を混同すると実際より多い数字が出てしまいます。"
        }
      },
      {
        "id": "d",
        "text": "約1024個",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1024個は1MBに1KBのファイルを格納した場合の数です（1MB=1024KB）。1GBはさらに1024倍の容量があるので、1GBには1024×1024=約104万個格納できます。",
          "analogy": "小さな箱（1MB）に1024個入るとき、大きな箱（1GB）には1024個の小さな箱が入るので、合計1024×1024個入ります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "記憶容量の単位換算：1KB=1024B、1MB=1024KB、1GB=1024MB。1GBは1KBの2²⁰=1,048,576倍です。",
      "keyPoint": "1GB ÷ 1KB = 1024 × 1024 = 1,048,576 ≒ 約104万。コンピュータの単位は1000倍ではなく1024倍（2¹⁰倍）。",
      "relatedTopics": [
        "2進数",
        "ビットとバイト",
        "TB・PBへの拡張",
        "伝送速度の計算"
      ],
      "studyTip": "KB・MB・GB・TBはすべて1024倍ずつ増えます。2¹⁰=1024≈1000（キロ）、2²⁰≈100万（メガ）、2³⁰≈10億（ギガ）と覚えると便利です。"
    },
    "tags": [
      "情報量",
      "単位",
      "KB",
      "MB",
      "GB",
      "基数変換"
    ]
  },
  {
    "questionId": "q-bt-018",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "文字コード",
    "level": 3,
    "question": "Shift_JISコードとUTF-8について説明した記述のうち、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "Shift_JISは世界中のすべての文字を1〜2バイトで表現できる国際規格である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "Shift_JISは主に日本語文字（ひらがな・カタカナ・漢字・英数字）を対象とした文字コードです。世界中のすべての文字を表現することはできません。国際規格として世界の文字を扱うのはUnicodeです。",
          "analogy": "Shift_JISは「日本語専用辞書」のようなものです。日本語は引けますが、中国語や韓国語のすべての文字は載っていません。"
        }
      },
      {
        "id": "b",
        "text": "UTF-8はASCII文字を1バイト、日本語などの多バイト文字を3〜4バイトで表現し、ASCIIと互換性がある。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "UTF-8はUnicode符号化方式の一つで、ASCII文字（英数字・記号）は1バイト、ひらがな・カタカナ・漢字などは3バイト、絵文字などは4バイトで表現します。ASCII文字のビットパターンはASCIIコードと同じなので後方互換性があります。",
          "analogy": "UTF-8は「多機能辞書」です。英語のページは旧来の辞書と同じページ番号（ASCIIと互換）で、日本語は3ページ、珍しい文字は4ページ使います。",
          "deepDive": "UTF-8の符号化規則：U+0000〜U+007F（ASCII）は1バイト（0xxxxxxx）、U+0080〜U+07FFは2バイト（110xxxxx 10xxxxxx）、U+0800〜U+FFFFは3バイト（1110xxxx 10xxxxxx 10xxxxxx）、U+10000〜U+10FFFFは4バイト。日本語のひらがな・漢字はU+3000台なので3バイトになります。"
        }
      },
      {
        "id": "c",
        "text": "UTF-8はすべての文字を固定長の2バイトで表現するため、文字数のカウントが容易である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "固定長2バイトで文字を表現するのはUTF-16（または古いUCS-2）です。UTF-8は可変長符号化方式で、1〜4バイトを使います。UTF-8はバイト数が可変なので、バイト列から文字数を数えるには少し注意が必要です。",
          "analogy": "UTF-8は「文字によってページ数が違う辞書」です。英字は1ページ、漢字は3ページ使うので、総ページ数÷1では文字数が出ません。"
        }
      },
      {
        "id": "d",
        "text": "Shift_JISとUTF-8は同じ文字コード体系であり、バイト列を変換せずに相互利用できる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "Shift_JISとUTF-8は異なる文字コード体系です。日本語文字のバイト列が全く異なるため、変換せずに相互利用するとテキストが文字化けします。文字コード変換（エンコーディング変換）が必要です。",
          "analogy": "Shift_JISは「日本式ナンバリング」、UTF-8は「国際式ナンバリング」です。同じ「あ」でも番号が違うので、変換なしに使うと「あ」が全く別の文字に見えてしまいます（文字化け）。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "Shift_JISは日本語向けの文字コード。UTF-8はUnicodeを可変長（1〜4バイト）で符号化し、ASCII互換性を持ちます。Webの標準文字コードはUTF-8です。",
      "keyPoint": "UTF-8：ASCII=1バイト、日本語=3バイト、ASCII互換。Shift_JIS：日本語専用、1〜2バイト。両者は別物でバイト変換が必要。",
      "relatedTopics": [
        "Unicode",
        "ASCII",
        "文字化け",
        "BOM（バイトオーダーマーク）",
        "UTF-16"
      ],
      "studyTip": "現在のWebはほぼすべてUTF-8が標準です。Shift_JISは古い日本語システムに残っています。「文字化け」はコードが合っていないことで起きると覚えましょう。"
    },
    "tags": [
      "文字コード",
      "Shift_JIS",
      "UTF-8",
      "Unicode",
      "ASCII"
    ]
  },
  {
    "questionId": "q-bt-019",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "論理回路（AND/OR/NOT/XOR）",
    "level": 4,
    "question": "2入力1出力の論理回路で、入力Aと入力Bが異なるときだけ出力が1になる回路はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "AND回路",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "AND回路はA=1かつB=1のときだけ出力1になります。A=0,B=0のとき出力は0、A=1,B=0またはA=0,B=1のとき出力は0です。入力が「異なるとき」に1になるわけではありません。",
          "analogy": "AND回路は「両方のスイッチをONにしたときだけ電灯が点く」回路です。片方だけONでは点きません。"
        }
      },
      {
        "id": "b",
        "text": "OR回路",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "OR回路はA=1またはB=1（どちらか一方でも1）のとき出力1になります。A=1,B=1のときも出力1になるため、「入力が異なるときだけ」という条件を満たしません。",
          "analogy": "OR回路は「どちらかのスイッチをONにしたら電灯が点く」回路です。両方ONでも点くので、「異なるときだけ」という条件とは違います。"
        }
      },
      {
        "id": "c",
        "text": "XOR回路（排他的論理和）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "XOR（排他的論理和）は入力が異なるとき（A=0,B=1 または A=1,B=0）に出力1、入力が同じとき（A=0,B=0 または A=1,B=1）に出力0になります。真理値表：A=0,B=0→0 / A=0,B=1→1 / A=1,B=0→1 / A=1,B=1→0。",
          "analogy": "「違う意見の人だけ手を挙げる」ルールです。二人とも賛成（1,1）や二人とも反対（0,0）では手を挙げない、どちらかが違う意見（0,1または1,0）のときだけ手を挙げます。",
          "deepDive": "XOR（eXclusive OR）の式：A⊕B = A'B + AB'（AとBの一方だけが1）。XORは加算回路（半加算器）の基本要素であり、暗号技術（簡単な暗号化・復号化）にも使われます。A⊕B⊕B=Aとなる性質（同じ値でXORすると元に戻る）がポイントです。"
        }
      },
      {
        "id": "d",
        "text": "NAND回路",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "NAND回路はAND回路の出力をNOT（反転）したもので、A=1かつB=1のときだけ出力0、それ以外は出力1になります。A=0,B=0のときも出力1になるため、「入力が異なるときだけ」という条件を満たしません。",
          "analogy": "NAND回路は「両方ONのときだけ電灯が消える」回路です。両方OFFのときも電灯は点いており、「異なるときだけ」という動作とは違います。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "XOR（排他的論理和）は入力が「排他的」、つまり「どちらか一方だけが1」のとき出力1になります。「不一致検出回路」とも呼ばれます。",
      "keyPoint": "XOR真理値表：(0,0)→0、(0,1)→1、(1,0)→1、(1,1)→0。「違うとき1、同じとき0」。",
      "relatedTopics": [
        "XNOR回路",
        "半加算器",
        "全加算器",
        "ブール代数",
        "論理式"
      ],
      "studyTip": "各論理回路の真理値表をしっかり暗記しましょう。AND=「両方1なら1」、OR=「どちらか1なら1」、XOR=「異なれば1」、NOT=「反転」がキーワードです。"
    },
    "tags": [
      "論理回路",
      "XOR",
      "排他的論理和",
      "AND",
      "OR",
      "真理値表"
    ]
  },
  {
    "questionId": "q-bt-020",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "ブール代数",
    "level": 4,
    "question": "ド・モルガンの法則を正しく表したものはどれか。ここで「'」はNOT（補元）、「+」はOR、「·」はANDを表す。",
    "choices": [
      {
        "id": "a",
        "text": "(A + B)' = A' + B'",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ド・モルガンの法則では (A + B)' = A' · B' です。ORの否定はANDになります。右辺がA' + B'（OR）ではなくA' · B'（AND）になる点が誤りです。",
          "analogy": "「AもしくはBのどちらでもない」を考えます。「犬か猫を飼っていない人」は「犬を飼っていない」かつ「猫も飼っていない」人です。「または」ではなく「かつ」になります。"
        }
      },
      {
        "id": "b",
        "text": "(A · B)' = A' · B'",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ド・モルガンの法則では (A · B)' = A' + B' です。ANDの否定はORになります。右辺がA' · B'（AND）ではなくA' + B'（OR）になる点が誤りです。",
          "analogy": "「AとBが両方そろっていない」状態は「Aがない、またはBがない」のどちらかです。両方同時にない必要はありません。"
        }
      },
      {
        "id": "c",
        "text": "(A + B)' = A' · B'",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ド・モルガンの法則の一つで、「ORの否定はそれぞれの否定のAND」を表します。(A + B)' = A' · B'。もう一つの法則は (A · B)' = A' + B'（ANDの否定はそれぞれの否定のOR）です。真理値表で確認：A=0,B=0→(0+0)'=1、A'·B'=1·1=1 ✓。A=0,B=1→(0+1)'=0、A'·B'=1·0=0 ✓。",
          "analogy": "「AまたはBのどちらかに当てはまる」の否定は「AにもBにも当てはまらない」、すなわち「Aでない、かつBでない」です。犬か猫を飼っている人の否定は「犬を飼っていない、かつ猫も飼っていない」人です。",
          "deepDive": "ド・モルガンの法則はブール代数の基本定理です。①(A + B)' = A' · B'（ORの否定→ANDで結ぶ）②(A · B)' = A' + B'（ANDの否定→ORで結ぶ）。これを使うとNAND/NOR回路をAND/OR/NOT回路の組合せで実現できます。デジタル回路設計の基礎です。"
        }
      },
      {
        "id": "d",
        "text": "(A · B)' = A + B",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "正しくは (A · B)' = A' + B' です。A' + B'のようにNOT（否定）を各変数に付ける必要があります。A + B（否定なし）はド・モルガンの法則ではありません。",
          "analogy": "「AとBが両方ある」の否定を表すには、それぞれ「ない（否定）」にする必要があります。否定を忘れると全く別の意味になります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ド・モルガンの法則：①(A+B)'=A'·B'（ORの否定→各々の否定のAND）②(A·B)'=A'+B'（ANDの否定→各々の否定のOR）。否定をとるとORとANDが入れ替わります。",
      "keyPoint": "ド・モルガン：「全体の否定をとると、OR↔ANDが入れ替わり、各変数も否定になる」。",
      "relatedTopics": [
        "ブール代数の基本定理",
        "NANDとNOR",
        "論理式の簡略化",
        "カルノー図"
      ],
      "studyTip": "ド・モルガンの法則は「（否定）を分配したら演算子が反転する」と覚えましょう。(A+B)'のカッコを外すと各変数に'が付き、+が·に変わります。"
    },
    "tags": [
      "ブール代数",
      "ド・モルガン",
      "論理演算",
      "AND",
      "OR",
      "NOT"
    ]
  },
  {
    "questionId": "q-bt-021",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "状態遷移図",
    "level": 4,
    "question": "自動改札機の状態遷移について考える。状態は「待機中」「切符検証中」「通過可能」「エラー」の4つがあり、「待機中」で切符を挿入すると「切符検証中」へ遷移し、切符が有効なら「通過可能」、無効なら「エラー」へ遷移する。この状態遷移図の説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "状態遷移図は、システムのある時点における静的な構造（データの関係）を表す図である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "状態遷移図は静的な構造ではなく、時間の経過とともにシステムの状態がどのように変化するかという動的な振る舞いを表す図です。静的な構造を表すのはER図やクラス図などです。",
          "analogy": "状態遷移図は「旅行のルートマップ」です。どこからどこへ移動できるかを示す動的な経路図であり、建物の間取り（静的な構造図）ではありません。"
        }
      },
      {
        "id": "b",
        "text": "「通過可能」状態から「待機中」状態へ直接遷移できるかどうかは、この図の記述からは判断できない。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "問題文には「通過可能」から「待機中」への遷移について明示的な記述がありません。状態遷移図では、矢印（遷移）として明記されていない遷移は「できない」か「定義されていない」と判断します。問題文に記載のない遷移の可否は判断できないというのが正しい解釈です。",
          "analogy": "地図に「A市からB市への道路」が書かれていない場合、その道があるかどうかは地図だけからは判断できません。直接道があるかもしれないし、ないかもしれません。",
          "deepDive": "状態遷移図（State Transition Diagram）の要素：①状態（ノード）、②遷移（有向エッジ）、③遷移条件（ラベル）、④初期状態、⑤最終状態。UMLではステートマシン図とも呼ばれます。状態遷移表（マトリクス形式）と合わせて理解すると設計に役立ちます。"
        }
      },
      {
        "id": "c",
        "text": "状態遷移図では、一つの状態から複数の状態へ同時に遷移することができる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "通常の（決定性）状態遷移図では、ある状態である条件の下で遷移する先は唯一の状態です。切符が有効なら「通過可能」、無効なら「エラー」というように、一度に複数の状態に同時に移ることはできません。",
          "analogy": "改札機は一度に「通過可能」と「エラー」を両方表示することはできません。判定結果に基づいて、どちらか一方の状態に移ります。"
        }
      },
      {
        "id": "d",
        "text": "「エラー」状態は最終状態であるため、そこから他の状態へ遷移することは絶対にできない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "問題文では「エラー」が最終状態だとは述べていません。実際の改札機では、エラー後にリセットして「待機中」に戻る遷移があるはずです。状態遷移図における最終状態は明示的に定義されるものであり、「エラー」が自動的に最終状態になるわけではありません。",
          "analogy": "ATMのエラー画面から「最初の画面に戻る」ことができるように、エラー状態は必ずしも終端ではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "状態遷移図はシステムの動的な振る舞い（状態の変化）を表します。遷移は明示的に定義された矢印のみが有効で、記載のない遷移はデフォルトでは存在しません。",
      "keyPoint": "状態遷移図：①状態はノード②遷移はエッジ（有向）③条件で遷移先が決まる④記述のない遷移の有無は不明。",
      "relatedTopics": [
        "ステートマシン図（UML）",
        "オートマトン",
        "状態遷移表",
        "フローチャート"
      ],
      "studyTip": "状態遷移図を読むときは、①全状態のリスト②各状態からの遷移条件と遷移先③初期状態・最終状態の3点を確認しましょう。"
    },
    "tags": [
      "状態遷移図",
      "有限オートマトン",
      "システム設計",
      "UML",
      "動的振る舞い"
    ]
  },
  {
    "questionId": "q-bt-022",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "正規表現",
    "level": 4,
    "question": "正規表現「[0-9]{3}-[0-9]{4}」にマッチする文字列はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "12-3456",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「[0-9]{3}」は数字3桁、「-」はハイフン、「[0-9]{4}」は数字4桁を表します。「12-3456」はハイフン前が2桁（「12」）であり、3桁の条件を満たしません。",
          "analogy": "郵便番号の形式「〒123-4567」を確認するルールを作ったとします。「〒12-3456」はハイフン前が2桁なので形式違反です。"
        }
      },
      {
        "id": "b",
        "text": "123-4567",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "「[0-9]{3}」は数字（0〜9のいずれか）が3文字、「-」はハイフン、「[0-9]{4}」は数字が4文字を表します。「123-4567」はちょうど数字3桁+ハイフン+数字4桁なのでマッチします。",
          "analogy": "この正規表現は「日本の郵便番号形式（123-4567形式）」のチェックルールです。「123-4567」はそのルールに完全に合致します。",
          "deepDive": "正規表現の主要メタ文字：[0-9]は任意の数字1文字、{n}は直前のパターンをn回繰り返す、-は文字クラス内では範囲指定（[0-9]は0から9）、文字クラス外ではそのまま「-」文字。よく使うパターン：\\d=[0-9]（数字）、\\w=[a-zA-Z0-9_]（単語文字）、\\s（空白）など。"
        }
      },
      {
        "id": "c",
        "text": "1234-567",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「[0-9]{3}」は数字3桁、「-」はハイフン、「[0-9]{4}」は数字4桁を表します。「1234-567」はハイフン前が4桁、ハイフン後が3桁であり、どちらの条件も逆になっています。",
          "analogy": "「123-4567」と「1234-567」は数字の桁数が逆になっています。郵便番号のルールで言えば前後が入れ違いです。"
        }
      },
      {
        "id": "d",
        "text": "abc-1234",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「[0-9]{3}」は0〜9の数字3桁を表します。「abc」はアルファベットであり[0-9]にマッチしません。数字のみが許可されている部分にアルファベットは使用できません。",
          "analogy": "「数字3桁のみ」というルールにアルファベット「abc」は合いません。郵便番号の欄に「abc」を入れようとしても受け付けてもらえないのと同じです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "正規表現は文字列のパターンを表現する記法です。[0-9]{3}-[0-9]{4}は「数字3桁＋ハイフン＋数字4桁」を意味します（郵便番号形式）。",
      "keyPoint": "[文字クラス]{n}：文字クラスのいずれかの文字がn回。[0-9]は0〜9の数字1文字。{3}は3回繰り返し。",
      "relatedTopics": [
        "形式言語",
        "有限オートマトン",
        "文字列検索",
        "バリデーション"
      ],
      "studyTip": "正規表現は検索・置換・バリデーションで広く使われます。主要なメタ文字（.、*、+、?、[]、{}、^、$）を一つずつ覚えていきましょう。"
    },
    "tags": [
      "正規表現",
      "パターンマッチング",
      "形式言語",
      "文字列"
    ]
  },
  {
    "questionId": "q-bt-023",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "形式言語",
    "level": 4,
    "question": "文脈自由文法（CFG）とチョムスキー階層について説明した記述のうち、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "正規言語は文脈自由言語よりも表現能力が高く、すべての文脈自由言語は正規言語でもある。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "チョムスキー階層では、正規言語は文脈自由言語の部分集合（真部分集合）です。つまり文脈自由言語の方が表現能力が高く、すべての正規言語は文脈自由言語ですが、逆は成り立ちません。",
          "analogy": "正規言語は「軽自動車」、文脈自由言語は「普通車」です。軽自動車は普通車の一種ですが、普通車すべてが軽自動車ではありません。"
        }
      },
      {
        "id": "b",
        "text": "文脈自由言語は、プッシュダウンオートマトン（PDA）によって認識できる言語クラスである。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "チョムスキー階層において、文脈自由言語（Type-2）と対応する計算モデルはプッシュダウンオートマトン（PDA）です。正規言語（Type-3）は有限オートマトン（FA）で認識でき、文脈依存言語（Type-1）は線形有界オートマトン（LBA）、句構造言語（Type-0）はチューリングマシン（TM）に対応します。",
          "analogy": "プッシュダウンオートマトンはスタック（積み重ね可能なメモ）付きの有限オートマトンです。括弧の対応（((()))のような構造）をスタックで管理するのが文脈自由言語の典型例です。",
          "deepDive": "チョムスキー階層：Type-0（句構造言語/チューリングマシン）⊃ Type-1（文脈依存言語/LBA）⊃ Type-2（文脈自由言語/PDA）⊃ Type-3（正規言語/FA）。プログラミング言語の構文解析には主にCFGが使われ、構文解析器（パーサー）はPDA相当の仕組みで動作します。"
        }
      },
      {
        "id": "c",
        "text": "正規言語はスタックを使う有限オートマトンでのみ認識できる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "正規言語は（スタックなしの）有限オートマトン（FA）で認識できます。スタックを使うのはプッシュダウンオートマトン（PDA）で、これは文脈自由言語を認識します。正規言語にスタックは不要です。",
          "analogy": "正規言語のチェックは「単純な交通信号（信号の状態だけ記憶）」で対応できます。スタック（メモ帳）は必要ありません。"
        }
      },
      {
        "id": "d",
        "text": "すべての自然言語（日本語・英語など）は正規言語に分類される。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "自然言語は正規言語よりもはるかに複雑な構造を持ちます。一般的に自然言語は文脈依存言語（Type-1）以上と考えられており、有限オートマトンだけでは扱えません。",
          "analogy": "日本語の文章は複雑な入れ子構造（「彼が彼女が好きな人が好きな人」など）があり、単純な信号機（有限オートマトン）では処理しきれません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "チョムスキー階層：正規言語（FA対応）⊂ 文脈自由言語（PDA対応）⊂ 文脈依存言語（LBA対応）⊂ 句構造言語（TM対応）。文脈自由言語はプログラミング言語の構文定義に使われます。",
      "keyPoint": "文脈自由言語 ⟺ プッシュダウンオートマトン（PDA）。正規言語 ⟺ 有限オートマトン（FA）。上位の言語クラスほど表現能力が高い。",
      "relatedTopics": [
        "チューリングマシン",
        "有限オートマトン",
        "正規表現",
        "BNF記法",
        "構文解析"
      ],
      "studyTip": "チョムスキー階層は「言語の複雑さのランク」です。ランクが上がるほど複雑な構造を表現でき、より強力な計算モデルが必要になります。"
    },
    "tags": [
      "形式言語",
      "チョムスキー階層",
      "文脈自由言語",
      "オートマトン",
      "プッシュダウンオートマトン"
    ]
  },
  {
    "questionId": "q-bt-024",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "オートマトン基礎",
    "level": 4,
    "question": "決定性有限オートマトン（DFA）について正しく説明しているものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "DFAは各状態と入力記号の組合せに対して、遷移先の状態が複数存在することができる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「決定性（Deterministic）」という名の通り、DFAでは各状態と入力記号の組合せに対して遷移先の状態は高々1つに決まります。複数の遷移先があるのは非決定性有限オートマトン（NFA）の特徴です。",
          "analogy": "DFAは「分岐のない一方通行の道」です。ある地点でどちらに進むかは、今の場所と信号（入力）で一意に決まります。"
        }
      },
      {
        "id": "b",
        "text": "DFAは入力文字列を1文字ずつ読み込み、各状態での遷移先が一意に決まる計算モデルである。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "DFA（Deterministic Finite Automaton：決定性有限オートマトン）は、現在の状態と入力記号の組合せによって、次の状態が唯一に決まる有限オートマトンです。入力文字列を左から1文字ずつ読み、すべて読み終えたときに受理状態にあれば、その文字列を受理します。",
          "analogy": "DFAは自動改札機のようなものです。現在の状態（改札の設定）と切符の情報（入力）によって、次の状態（開く/閉まる）が一意に決まります。",
          "deepDive": "DFAの定式化：5タプル(Q, Σ, δ, q0, F)。Q=状態の有限集合、Σ=入力アルファベット、δ:Q×Σ→Q=遷移関数、q0∈Q=初期状態、F⊆Q=受理状態集合。DFAとNFAは受理する言語クラス（正規言語）が同じであることが証明されています（サブセット構成法でNFA→DFA変換可能）。"
        }
      },
      {
        "id": "c",
        "text": "DFAはスタックを内部メモリとして使用することで、文脈自由言語を認識できる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "DFAはスタックを持ちません。スタックを持つのはプッシュダウンオートマトン（PDA）です。DFAは有限個の状態のみを内部メモリとして使用し、正規言語のみを認識できます。",
          "analogy": "DFAは「メモ帳なしで状態だけ記憶する機械」です。メモ帳（スタック）を追加するとPDA（より強力な機械）になります。"
        }
      },
      {
        "id": "d",
        "text": "DFAでは空文字（ε）遷移を使って、入力を読まずに状態を変えることができる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ε遷移（空遷移）は非決定性有限オートマトン（NFA）の特徴です。DFAにはε遷移がありません。DFAでは必ず入力記号を1つ消費して遷移します。ε遷移を持つNFAは、DFAに等価変換できることが知られています。",
          "analogy": "DFAは「入力なしでは動かない機械」です。必ず何か入力（スイッチを押す）がないと状態は変わりません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "DFA（決定性有限オートマトン）は、現在の状態と入力記号の組合せで次の状態が唯一に決まる計算モデルです。スタックなし・ε遷移なしが特徴で、正規言語を認識します。",
      "keyPoint": "DFA：①状態数有限②入力記号で遷移先が一意に決まる③スタックなし・ε遷移なし④認識するのは正規言語。",
      "relatedTopics": [
        "NFA（非決定性有限オートマトン）",
        "正規言語",
        "正規表現",
        "プッシュダウンオートマトン"
      ],
      "studyTip": "DFAとNFAの違いは「遷移先が1つ（決定性）か複数可能（非決定性）か」です。能力（認識できる言語クラス）は同じですが、DFAの方が実装しやすいという特徴があります。"
    },
    "tags": [
      "オートマトン",
      "DFA",
      "有限オートマトン",
      "形式言語",
      "正規言語"
    ]
  },
  {
    "questionId": "q-bt-025",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "浮動小数点の仕組み",
    "level": 5,
    "question": "IEEE 754の単精度浮動小数点数（32ビット）の構造について正しく説明しているものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "符号部1ビット・仮数部8ビット・指数部23ビットで構成される。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "IEEE 754単精度は符号部1ビット・指数部8ビット・仮数部23ビットです。仮数部と指数部のビット数が逆になっています。指数部が8ビット、仮数部が23ビットが正しい配置です。",
          "analogy": "「3.14×10²」という数字で「10²」の部分（指数）と「3.14」の部分（仮数）を正しい桁数で区別することが大切です。"
        }
      },
      {
        "id": "b",
        "text": "符号部1ビット・指数部8ビット・仮数部23ビットで構成され、合計32ビットである。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "IEEE 754単精度浮動小数点数は、符号部（sign）1ビット + 指数部（exponent）8ビット + 仮数部（fraction/mantissa）23ビット = 合計32ビットで構成されます。指数部はバイアス表現（バイアス値127を足した値を格納）を使い、仮数部は正規化された値の小数点以下の部分を格納します。",
          "analogy": "科学的記数法「1.23456×10⁵」と同じ仕組みです。符号（＋か−）、指数（10の何乗か）、仮数（1.23456の小数部分）の3要素で数を表します。",
          "deepDive": "IEEE 754単精度：符号1bit（0=正、1=負）、指数8bit（バイアス127、実際の指数e=格納値-127）、仮数23bit（整数部の1を省略した正規化表現）。表現できる範囲：約±1.18×10⁻³⁸〜±3.40×10³⁸。特殊値として±0、±無限大、NaN（Not a Number）も定義されています。"
        }
      },
      {
        "id": "c",
        "text": "浮動小数点数は固定小数点数よりも常に精度が高く、誤差が生じることはない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "浮動小数点数は広い範囲の数を表現できますが、仮数部のビット数が有限であるため精度に限界があり、誤差が生じます。0.1のような10進小数が2進数で正確に表現できない場合があり、丸め誤差が発生します。",
          "analogy": "電卓で「0.1+0.2」を計算すると「0.30000000000000004」のような結果になることがあります。これが浮動小数点の誤差です。"
        }
      },
      {
        "id": "d",
        "text": "IEEE 754の倍精度浮動小数点数は単精度と同じ32ビットで表現される。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "倍精度（double precision）は64ビットです。単精度（single precision）が32ビット、倍精度が64ビットです。倍精度は指数部11ビット・仮数部52ビットで、単精度よりも精度と表現範囲が大きくなります。",
          "analogy": "単精度は「標準版の物差し」（32cm）、倍精度は「大型の物差し」（64cm）と考えましょう。長い物差しのほうが細かく正確に測れます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "IEEE 754単精度浮動小数点数：符号1ビット + 指数部8ビット + 仮数部23ビット = 32ビット。広い範囲の数を表現できますが、有限ビットによる丸め誤差が生じます。",
      "keyPoint": "単精度32bit：符号1+指数8+仮数23。倍精度64bit：符号1+指数11+仮数52。浮動小数点は誤差が必ず存在する。",
      "relatedTopics": [
        "丸め誤差",
        "桁落ち",
        "情報落ち",
        "固定小数点数",
        "NaN・無限大"
      ],
      "studyTip": "「1（符号）＋8（指数）＋23（仮数）＝32ビット」をしっかり暗記しましょう。試験では単精度と倍精度の違いも頻出です。"
    },
    "tags": [
      "浮動小数点",
      "IEEE754",
      "単精度",
      "倍精度",
      "数値表現"
    ]
  },
  {
    "questionId": "q-bt-026",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "誤差（丸め・桁落ち・情報落ち）",
    "level": 5,
    "question": "浮動小数点演算における「桁落ち」を最もよく説明しているものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "計算結果の絶対値が非常に大きくなり、浮動小数点数で表現できる最大値を超えてしまう現象。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはオーバーフロー（桁あふれ）の説明です。桁落ちは大きな数が生じる問題ではなく、値がほぼ等しい数同士の引き算で有効桁数が減少する現象です。",
          "analogy": "ダムの水があふれてしまう現象（オーバーフロー）と、コップの水が少しこぼれて正確な量が分からなくなる現象（桁落ち）は別の問題です。"
        }
      },
      {
        "id": "b",
        "text": "値がほぼ等しい二つの浮動小数点数を引き算したとき、有効桁数が大幅に減少する現象。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "桁落ち（catastrophic cancellation）は、値が非常に近い数同士の引き算で発生します。例えば、1.2345678と1.2345679（差は0.0000001）を6桁精度で計算する場合、有効な桁がほとんど消えてしまい、相対誤差が非常に大きくなります。上位の有効桁が「消えて（cancel）」しまう現象です。",
          "analogy": "100万円の貯金から999,999円使ったとき、残りは1円ですが、「約100万円から約100万円を引く」という計算では「約0円」というあいまいな答えになってしまいます。細かい違いが消えてしまうイメージです。",
          "deepDive": "桁落ちの具体例：x=1.000001、y=1.000000のとき、x-y=0.000001。しかし6桁精度の浮動小数点では x≒y≒1.00000（最下位桁が消える）となり、x-y≒0（本来は1×10⁻⁶）。相対誤差が100%になります。対策：計算式の変形（例：二次方程式の解の公式の変形）が有効です。"
        }
      },
      {
        "id": "c",
        "text": "絶対値の非常に大きい数と非常に小さい数を加算したとき、小さい数が無視されてしまう現象。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「情報落ち（absorption）」の説明です。桁落ちは「ほぼ等しい数の引き算で有効桁が消える」現象であり、「大きい数に小さい数が吸収される」情報落ちとは異なります。",
          "analogy": "太平洋（1,000,000トン）に1グラムの水を加えても変化が分からないのが「情報落ち」です。「ほぼ同じ量の水を引いて誤差が増幅する」のが「桁落ち」です。"
        }
      },
      {
        "id": "d",
        "text": "計算の途中で無限に繰り返す循環小数が発生し、計算が終わらなくなる現象。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "浮動小数点演算では循環小数は有限ビットで打ち切られ（丸め誤差が発生）、計算が終わらなくなることはありません。説明している現象は桁落ちとは無関係です。",
          "analogy": "1/3を電卓で計算すると0.333...と表示されますが、電卓は途中で打ち切ります（丸め誤差）。計算が止まらなくなることはありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "主な浮動小数点誤差：①丸め誤差（有限ビットによる打ち切り）②桁落ち（ほぼ等しい数の引き算で有効桁が消える）③情報落ち（大きい数と小さい数の加算で小さい数が無視される）④オーバーフロー（最大値超過）。",
      "keyPoint": "桁落ち：ほぼ等しい数の引き算→有効桁数が激減。情報落ち：絶対値差が大きい数の加算→小さい数が吸収。",
      "relatedTopics": [
        "浮動小数点の仕組み",
        "IEEE 754",
        "丸め誤差",
        "数値安定性"
      ],
      "studyTip": "誤差の種類を混同しやすいので、それぞれの発生条件を明確に区別しましょう。「桁落ち=引き算で桁が消える」「情報落ち=小さい数が吸収される」と紐付けて覚えると良いです。"
    },
    "tags": [
      "誤差",
      "桁落ち",
      "情報落ち",
      "丸め誤差",
      "浮動小数点"
    ]
  },
  {
    "questionId": "q-bt-027",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "逆ポーランド記法",
    "level": 5,
    "question": "逆ポーランド記法（後置記法）の式「3 4 + 2 × 5 -」を評価した結果はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "3",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "3は元の式の最初の数字です。逆ポーランド記法はスタックを使って左から順に評価します。「3 4 + 2 × 5 -」を正しく評価すると (3+4)×2-5 = 9 になります。途中の計算を行わず最初の値だけを返してしまっています。",
          "analogy": "レジで「3円と4円を足す」「その結果を2倍する」「5円引く」という手順を無視して最初の3円だけを答えにしてしまっています。"
        }
      },
      {
        "id": "b",
        "text": "9",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "スタックを使って左から順に評価します。①3→push→[3] ②4→push→[3,4] ③+→pop(4),pop(3),3+4=7,push→[7] ④2→push→[7,2] ⑤×→pop(2),pop(7),7×2=14,push→[14] ⑥5→push→[14,5] ⑦-→pop(5),pop(14),14-5=9,push→[9]。結果は9。対応する中置記法：(3+4)×2-5=9。",
          "analogy": "逆ポーランド記法はレジの計算のようなものです。数字が来たら「皿に乗せ（スタックにプッシュ）」、演算子が来たら「上の2枚を取り出して計算し（ポップして演算）、結果を乗せ直します（プッシュ）」。3と4を乗せ→足して7→2を乗せ→掛けて14→5を乗せ→引いて9。",
          "deepDive": "逆ポーランド記法（Reverse Polish Notation：RPN）の対応する中置記法：(3+4)×2-5 = 7×2-5 = 14-5 = 9。RPNの利点：①括弧が不要②スタックで機械的に評価できる③コンパイラの中間コード生成に使われる。中置記法→RPNへの変換には「シャンティングヤードアルゴリズム」が使われます。"
        }
      },
      {
        "id": "c",
        "text": "11",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "11は演算の優先順位を誤った場合に出やすい値です。中置記法として「3+4×2-5=3+8-5=6」や別の誤った解釈では11になることがあります。逆ポーランド記法は演算子が来た時点で直前の2数に対して演算を行うという規則に厳密に従う必要があります。",
          "analogy": "レジで皿から取り出す順番を間違えると計算が変わります。スタックは「後入れ先出し（LIFO）」なので、最後に乗せた数を先に取り出します。"
        }
      },
      {
        "id": "d",
        "text": "14",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "14は「3 4 + 2 ×」まで正しく計算した中間結果です。最後の「5 -」（5を引く操作）を忘れた場合に14が残ります。式全体をすべて評価し終えることが必要で、途中で止めてはいけません。",
          "analogy": "料理のレシピ途中でやめてしまったようなものです。「材料を混ぜて（+）、2倍の量にして（×）」までやったが、「5グラム取り除く（-）」という最後のステップを忘れています。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "逆ポーランド記法（RPN）はスタックを使って左から順に評価します。数字はスタックにプッシュ、演算子はスタックから2つポップして演算し結果をプッシュします。「3 4 + 2 × 5 -」= (3+4)×2-5 = 9。",
      "keyPoint": "RPN評価手順：数字→push、演算子→pop×2して演算→pushを繰り返す。対応中置記法で確認：(3+4)×2-5=9。",
      "relatedTopics": [
        "スタック",
        "中置記法",
        "前置記法（ポーランド記法）",
        "構文木",
        "コンパイラ"
      ],
      "studyTip": "RPNの評価は必ずスタックの状態を手順として書き出しながら解きましょう。頭の中だけで計算しようとすると間違えやすいです。"
    },
    "tags": [
      "逆ポーランド記法",
      "後置記法",
      "スタック",
      "式の評価",
      "アルゴリズム"
    ]
  },
  {
    "questionId": "q-bt-028",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "BNF記法",
    "level": 5,
    "question": "以下のBNF（バッカスナウア記法）で定義された規則に従うとき、有効な文字列はどれか。\n\n<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n<number> ::= <digit> | <digit> <number>",
    "choices": [
      {
        "id": "a",
        "text": "12A3",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「A」は<digit>で定義されていません。<digit>は0から9の数字のみです。アルファベットを含む文字列は<number>の定義に合致しません。",
          "analogy": "「数字だけ使って良い」というルールブックに「A」という文字は載っていません。ルール違反です。"
        }
      },
      {
        "id": "b",
        "text": "456",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "<number>は<digit>単体か<digit><number>の再帰的な定義です。「456」は「4」（<digit>）+「56」（<number>→「5」（<digit>）+「6」（<number>→<digit>））として解析できます。すべての文字が<digit>に合致する1文字以上の数字列は<number>に該当します。",
          "analogy": "このBNFは「数字（0〜9）を1個以上並べた文字列」を定義しています。456はまさに「4、5、6の3つの数字」を並べたものなのでルールに合致します。",
          "deepDive": "BNF（Backus-Naur Form）は文脈自由文法を記述するメタ言語です。<number> ::= <digit> | <digit> <number>は再帰的定義で、「1個の数字」または「1個の数字の後ろにさらに<number>が続く」ことを意味します。これにより1桁以上の任意の長さの数値を定義できます。EBNF（拡張BNF）では繰り返しを{...}や*で表現できます。"
        }
      },
      {
        "id": "c",
        "text": "",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "空文字列（長さ0の文字列）は<number>の定義に含まれていません。<number>は必ず1つ以上の<digit>を含む必要があります。空文字列を許容するにはεを使って定義する必要があります。",
          "analogy": "「数字を1個以上使って良い」というルールで、「何も書かない」はルール違反です。最低でも1文字の数字が必要です。"
        }
      },
      {
        "id": "d",
        "text": "12.34",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「.」（小数点）は<digit>で定義されていません。<digit>は0〜9の整数の数字のみです。小数点を含む数値を扱うには別途定義が必要です。",
          "analogy": "このルールブックには「0〜9の数字」しか載っていません。小数点「.」はルールにないので使えません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "BNF（バッカスナウア記法）は文法規則を形式的に記述する方法です。<term> ::= 定義で読み方は「<term>は右辺の形で定義される」、「|」は「または」を意味します。",
      "keyPoint": "BNFの読み方：::=は「定義」、|は「選択肢（または）」、<>は非終端記号。再帰的定義で繰り返し構造を表現できる。",
      "relatedTopics": [
        "文脈自由文法",
        "EBNF",
        "形式言語",
        "構文解析",
        "プログラミング言語の構文定義"
      ],
      "studyTip": "BNFで定義された文法の問題では、文字列を左から1文字ずつ当てはめていき、すべての部分が規則に合致するか確認します。再帰的定義はスタックを使って追いかけましょう。"
    },
    "tags": [
      "BNF記法",
      "バッカスナウア記法",
      "形式文法",
      "構文定義",
      "形式言語"
    ]
  },
  {
    "questionId": "q-bt-029",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "グラフ理論基礎",
    "level": 5,
    "question": "頂点数5、辺数7の無向グラフが連結であるとき、このグラフの全域木（スパニングツリー）の辺数はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "4",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "n個の頂点を持つ連結グラフの全域木（スパニングツリー）の辺数は、必ずn-1本になります。頂点数が5なので、全域木の辺数は5-1=4本です。全域木は元のグラフのすべての頂点を含み、閉路（サイクル）がなく連結である部分グラフです。",
          "analogy": "5つの島を橋で繋いで全島を行き来できるようにするとき、最低限必要な橋の数は5-1=4本です。4本より少ないと孤立する島が出て、4本より多いと橋が余分（閉路）になります。",
          "deepDive": "全域木（Spanning Tree）の性質：①グラフのすべての頂点を含む②閉路がない（木構造）③連結（全頂点が1つの連結成分）④辺数=頂点数-1（n-1本）。全域木を求めるアルゴリズム：プリム法・クルスカル法（最小全域木）。連結グラフで「辺数<頂点数-1」は非連結、「辺数=頂点数-1かつ連結」は木、「辺数>頂点数-1かつ連結」は閉路あり。"
        }
      },
      {
        "id": "b",
        "text": "5",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "5は元のグラフの頂点数と同じです。全域木の辺数は頂点数-1=4本です。「頂点数=辺数」と混同しないようにしましょう。",
          "analogy": "5つの島に5本の橋を架けると、必ずどこかに不要な橋（閉路）ができます。4本が最小限で十分です。"
        }
      },
      {
        "id": "c",
        "text": "6",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "6は元のグラフの辺数7から1引いた値ですが、全域木の辺数の計算は「辺数-1」ではなく「頂点数-1」です。全域木の辺数は頂点数のみに依存します。",
          "analogy": "島を繋ぐ橋の最小数は、橋の総数から決まるのではなく、島の数（頂点数）から決まります。5島なら常に4本が最小です。"
        }
      },
      {
        "id": "d",
        "text": "7",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "7は元のグラフの辺数です。全域木は元のグラフのすべての辺を使うわけではなく、閉路を除去して頂点数-1本の辺のみを残した部分グラフです。",
          "analogy": "7本の橋がある島々で、全島を繋ぐ最小限の橋だけを残す（全域木）と4本になります。7本全部残すと閉路（不要な迂回路）ができます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "n頂点の連結グラフの全域木（スパニングツリー）の辺数は常にn-1本です。全域木はすべての頂点を含み、閉路がない連結部分グラフです。",
      "keyPoint": "全域木の辺数 = 頂点数 - 1（n-1本）。元のグラフの辺数には依存しない。",
      "relatedTopics": [
        "最小全域木",
        "プリム法",
        "クルスカル法",
        "有向グラフ",
        "閉路・サイクル"
      ],
      "studyTip": "「木（Tree）」の性質：n頂点のとき辺数はn-1、連結、閉路なし、の3条件のうち2つが成り立つと残り1つも自動的に成り立ちます。"
    },
    "tags": [
      "グラフ理論",
      "全域木",
      "スパニングツリー",
      "頂点",
      "辺",
      "木構造"
    ]
  },
  {
    "questionId": "q-bt-030",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "basic-theory",
    "topic": "待ち行列理論基礎",
    "level": 5,
    "question": "M/M/1待ち行列モデルにおいて、到着率λ=4（件/分）、サービス率μ=6（件/分）のとき、システム（待ち行列とサービス中）にいる平均顧客数はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "0.5人",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.5人は誤りです。M/M/1の平均システム滞在顧客数はL = λ/(μ-λ) = 4/(6-4) = 4/2 = 2人です。0.5は利用率ρ=λ/μ=4/6≒0.67の誤りか、別の計算をした結果です。",
          "analogy": "銀行の窓口に平均して何人並んでいるかを求めるとき、0.5人は少なすぎます。実際の混雑具合を公式で正しく計算する必要があります。"
        }
      },
      {
        "id": "b",
        "text": "2人",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "M/M/1待ち行列の平均システム滞在顧客数 L = λ/(μ-λ) で計算します。λ=4、μ=6なので、L = 4/(6-4) = 4/2 = 2人。また利用率ρ=λ/μ=4/6≒0.667。安定条件ρ<1を満たしており、システムは定常状態にあります。",
          "analogy": "銀行窓口に毎分4人来て、毎分6人処理できる場合、窓口前後（待っている人＋処理中の人）の平均人数は2人です。窓口がオーバーしていないので行列が安定しています。",
          "deepDive": "M/M/1モデルの主要公式：①利用率ρ=λ/μ（<1で安定）②平均システム滞在顧客数 L=λ/(μ-λ)=ρ/(1-ρ)③平均待ち顧客数 Lq=λ²/(μ(μ-λ))=ρ²/(1-ρ)④平均システム滞在時間 W=1/(μ-λ)⑤平均待ち時間 Wq=λ/(μ(μ-λ))。リトルの法則：L=λW（平均顧客数=到着率×平均滞在時間）がすべての待ち行列モデルで成立します。"
        }
      },
      {
        "id": "c",
        "text": "4人",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "4人は到着率λの値そのものです。平均システム滞在顧客数はL=λ/(μ-λ)=4/(6-4)=2人です。λをそのまま答えとしてしまった誤りです。",
          "analogy": "「毎分4人来る」という到着率と「平均して何人いるか」という平均顧客数は別の概念です。待ち行列の公式を使って正しく計算しましょう。"
        }
      },
      {
        "id": "d",
        "text": "6人",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "6人はサービス率μの値そのものです。平均システム滞在顧客数はL=λ/(μ-λ)=4/(6-4)=2人です。μをそのまま答えとしてしまった誤りです。",
          "analogy": "「毎分6人処理できる」というサービス率と「平均して何人いるか」という平均顧客数は別の概念です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "M/M/1待ち行列の平均システム滞在顧客数 L = λ/(μ-λ)。まず安定条件 ρ=λ/μ<1 を確認してから計算します。ρ≧1の場合は行列が際限なく伸び定常状態にならない。",
      "keyPoint": "M/M/1の公式：L=λ/(μ-λ)（平均システム滞在人数）、Lq=λ²/(μ(μ-λ))（平均待ち人数）、W=1/(μ-λ)（平均滞在時間）。リトルの法則：L=λW。",
      "relatedTopics": [
        "リトルの法則",
        "マルコフ連鎖",
        "誕生死滅過程",
        "利用率",
        "応答時間"
      ],
      "studyTip": "待ち行列問題では①まず安定条件ρ=λ/μ<1を確認②L=λ/(μ-λ)で平均顧客数を計算③W=L/λで平均滞在時間を計算、という手順を習慣化しましょう。"
    },
    "tags": [
      "待ち行列",
      "M/M/1",
      "到着率",
      "サービス率",
      "リトルの法則",
      "確率モデル"
    ]
  }
]