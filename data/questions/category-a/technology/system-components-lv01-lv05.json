[
  {
    "questionId": "q-sc-001",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "クライアントサーバシステム",
    "level": 1,
    "question": "クライアントサーバシステムにおける「サーバ」の役割として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ユーザが直接操作し、データ入力や画面表示を行う端末",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはクライアントの役割です。クライアントはユーザが直接操作する端末であり、サーバに対してサービスの提供を要求する側です。",
          "analogy": "レストランでいえば、注文する「お客さん（クライアント）」の説明であり、料理を作る「厨房（サーバ）」の説明ではありません。"
        }
      },
      {
        "id": "b",
        "text": "クライアントからの要求を受け付け、データ処理やサービスを提供する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "サーバはクライアントからのリクエスト（要求）を受け取り、データベースアクセス・ファイル共有・メール配信などのサービスを提供します。クライアントとサーバはネットワークを介して通信します。",
          "analogy": "レストランでいえばサーバは「厨房」です。お客さん（クライアント）から注文（リクエスト）を受け取り、料理（サービス）を提供します。厨房はお客さんが来るのを待ち、注文が来たら対応します。",
          "deepDive": "クライアントサーバシステムは、処理を「要求する側（クライアント）」と「提供する側（サーバ）」に分離したアーキテクチャです。サーバはWeb サーバ・DBサーバ・ファイルサーバ・メールサーバなど用途別に存在します。1台のサーバが複数のクライアントに同時にサービスを提供できる点が特徴です。"
        }
      },
      {
        "id": "c",
        "text": "ネットワーク上のデータを中継し、異なるネットワークを接続する機器",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはルータの説明です。ルータはIPアドレスを基に異なるネットワーク間でパケットを転送する機器であり、クライアントサーバシステムのサーバとは異なります。",
          "analogy": "レストランでいえば、これは「配達員」や「道案内係」の説明です。厨房（サーバ）の役割とは異なります。"
        }
      },
      {
        "id": "d",
        "text": "複数のコンピュータを物理的に接続し、通信速度を向上させる機器",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはスイッチングハブ（スイッチ）の説明です。ネットワーク機器の一種であり、クライアントサーバシステムにおけるサーバの役割とは異なります。",
          "analogy": "レストランでいえば、これは「テーブルと厨房をつなぐ配膳レーン」の説明です。厨房（サーバ）そのものではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "クライアントサーバシステムでは、サービスを要求する「クライアント」と、サービスを提供する「サーバ」に役割を分離します。サーバはクライアントからのリクエストに応じてデータ処理やサービス提供を行います。",
      "keyPoint": "クライアント＝要求する側、サーバ＝提供する側。サーバは複数のクライアントに同時にサービスを提供できます。",
      "relatedTopics": ["3層アーキテクチャ", "Webシステム", "負荷分散", "ピアツーピア"],
      "studyTip": "「クライアント」は英語で「顧客」の意味です。顧客がサービスを要求し、サーバ（提供者）がそれに応答するという関係を覚えましょう。"
    },
    "tags": ["クライアントサーバ", "システム構成", "ネットワーク基礎"]
  },
  {
    "questionId": "q-sc-002",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "バッチ処理とリアルタイム処理",
    "level": 1,
    "question": "バッチ処理の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ユーザからの要求が発生するたびに即座に処理を実行する方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはリアルタイム処理（オンライン処理）の説明です。リアルタイム処理は要求が発生した都度、即座に応答します。ATMや航空券予約システムなどに使われます。",
          "analogy": "コンビニのレジのようなもので、お客さんが来るたびに都度対応します。バッチ処理とは逆の考え方です。"
        }
      },
      {
        "id": "b",
        "text": "一定期間または一定量のデータをまとめて一括処理する方式",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "バッチ処理は、データを一定期間（例：1日分）または一定量まとめて蓄積しておき、決まったタイミングでまとめて処理する方式です。給与計算・請求書発行・日次の集計処理などに利用されます。",
          "analogy": "洗濯機にたとえると分かりやすいです。服が汚れるたびに1枚ずつ洗うのではなく、一定量たまったら（または週末など決まった時間に）まとめて洗います。これがバッチ処理の考え方です。",
          "deepDive": "バッチ処理の特徴は「処理の遅延許容」と「効率性」です。夜間など負荷の低い時間帯に大量データをまとめて処理することで、システムリソースを効率的に使えます。デメリットは処理結果がすぐに得られないことです。月次の売上集計や銀行の夜間一括処理などが典型例です。"
        }
      },
      {
        "id": "c",
        "text": "複数のプロセッサが同時並行で処理を実行する方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは並列処理の説明です。複数のプロセッサやコアが同時に異なる処理を実行することで全体の処理速度を向上させる方式であり、バッチ処理とは別の概念です。",
          "analogy": "工場で複数の生産ラインが同時に動く様子に相当します。バッチ処理は「まとめて処理する時期」に関する概念で、並列処理は「同時に何本の作業ラインを動かすか」に関する概念です。"
        }
      },
      {
        "id": "d",
        "text": "処理の優先度を設定し、重要な処理を優先して実行する方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは優先度付きスケジューリング（プリエンプティブスケジューリング）の説明です。OSのプロセス管理に関する概念であり、バッチ処理の定義とは異なります。",
          "analogy": "病院の救急対応のように、重篤な患者を優先する仕組みです。バッチ処理は優先度よりも「まとめて処理する」点が本質です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "バッチ処理はデータを一定量・一定期間まとめて蓄積し、決まったタイミングで一括処理する方式です。効率的ですが即時性はありません。リアルタイム処理と対になる概念です。",
      "keyPoint": "バッチ＝まとめて処理。即時性は低いが効率が高い。給与計算・月次集計・夜間一括処理が典型例。",
      "relatedTopics": ["リアルタイム処理", "オンライン処理", "トランザクション処理", "ジョブスケジューリング"],
      "studyTip": "「バッチ（Batch）」は英語で「一束・一まとまり」の意味です。まとめて処理するイメージを持ちましょう。"
    },
    "tags": ["バッチ処理", "リアルタイム処理", "処理方式"]
  },
  {
    "questionId": "q-sc-003",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "冗長化の概念",
    "level": 1,
    "question": "システムの冗長化を行う主な目的はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "処理速度を向上させ、応答時間を短縮する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "処理速度向上は冗長化の主目的ではありません。速度向上のためには性能の高いハードウェアへの交換（スケールアップ）や負荷分散が適切な手段です。冗長化は主に信頼性向上のために行います。",
          "analogy": "予備のタイヤ（スペアタイヤ）を積むのは、走行速度を上げるためではなく、パンクしたときでも走り続けられるようにするためです。"
        }
      },
      {
        "id": "b",
        "text": "ストレージ容量を増やし、大量のデータを保存できるようにする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ストレージ容量の増加はストレージ拡張の目的であり、冗長化の主目的ではありません。冗長化はシステムの継続稼働を目的とします。",
          "analogy": "スペアタイヤは荷物を多く積むための工夫ではなく、いざというときの備えです。"
        }
      },
      {
        "id": "c",
        "text": "一部のコンポーネントが故障しても、システム全体の稼働を継続できるようにする",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "冗長化の主目的は「信頼性の向上」と「可用性の確保」です。予備のコンポーネントを用意しておくことで、一部が故障してもシステム全体がダウンしないようにします。サーバ・電源・ネットワーク機器・ストレージなど様々な箇所で冗長化が行われます。",
          "analogy": "飛行機のエンジンが複数搭載されているのと同じです。エンジンが1基故障しても残りのエンジンで飛び続けられるよう、あえて余分に備えています。システムの冗長化も同じ発想です。",
          "deepDive": "冗長化には「アクティブ-アクティブ（全てのコンポーネントが稼働中）」と「アクティブ-スタンバイ（待機系が控えている）」の2方式があります。前者は負荷分散も兼ねますが、後者はコスト効率が高い方式です。冗長化の度合いは稼働率の計算式で表現でき、並列に接続するほど全体の稼働率が向上します。"
        }
      },
      {
        "id": "d",
        "text": "コストを削減し、システム運用費用を低減する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "冗長化は予備のコンポーネントを追加するため、通常はコストが増加します。コスト削減のために冗長化を行うわけではありません。冗長化はコストをかけても信頼性を確保したい場合に採用します。",
          "analogy": "スペアタイヤを積むとその分のコストと重量が増えます。コスト削減のためではなく、安全のために積んでいます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "冗長化は、予備のコンポーネントを用意することで一部の故障時でもシステム全体の稼働を継続できるようにする設計手法です。信頼性（可用性）の向上が主目的です。",
      "keyPoint": "冗長化＝予備を用意して故障に備える。目的は「可用性（稼働継続性）」の向上。コストは増加する。",
      "relatedTopics": ["RAID", "デュアルシステム", "デュプレックスシステム", "フォールトトレラント", "稼働率"],
      "studyTip": "「冗長（じょうちょう）」は「余分・無駄」という意味ですが、IT では意図的に「余分なコンポーネントを持つ」ことで信頼性を高める手法を指します。"
    },
    "tags": ["冗長化", "可用性", "信頼性", "フォールトトレランス"]
  },
  {
    "questionId": "q-sc-004",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "バックアップ（フル・差分・増分）",
    "level": 1,
    "question": "増分バックアップの説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "全データを毎回バックアップする方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはフルバックアップの説明です。フルバックアップは全データを毎回バックアップするため、バックアップ時間は長くかかりますが、復元が最も簡単です。",
          "analogy": "毎日、家の中の全ての荷物を倉庫に移す作業に相当します。確実ですが時間と手間がかかります。"
        }
      },
      {
        "id": "b",
        "text": "最後にフルバックアップを行った時点からの変更分をバックアップする方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは差分バックアップの説明です。差分バックアップは常に最後のフルバックアップからの変更分を保存するため、増分バックアップより復元が簡単ですが、バックアップサイズが日々増えます。",
          "analogy": "引越し後に増えた荷物を、引越し当日（フルバックアップ時点）と比べた差分を毎回全て記録する方式です。"
        }
      },
      {
        "id": "c",
        "text": "前回のバックアップ（フル・差分・増分を問わず）以降に変更されたデータだけをバックアップする方式",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "増分バックアップは、前回のバックアップ実施時点（フル・差分・増分のいずれか）以降に変更・追加されたデータだけをバックアップします。1回あたりのバックアップ量が最小で済みますが、復元時はフルバックアップ＋複数の増分バックアップを順番に適用する必要があります。",
          "analogy": "日記に例えると分かりやすいです。月曜日に全ての出来事（フル）を書き、火曜日は月曜以降の新しい出来事だけ、水曜日は火曜以降の新しい出来事だけを書きます。毎回の記録量は少なくて済みますが、全体を把握するには全ての日記を読む必要があります。",
          "deepDive": "3つのバックアップ方式の比較：フルバックアップは時間がかかるが復元が簡単、差分バックアップはフルバックアップ＋最新1回の差分で復元可能、増分バックアップはバックアップ量最小だが復元にフルバックアップ＋全増分ファイルが必要で時間がかかります。実務では夜間に増分、週末にフルバックアップを組み合わせるケースが多いです。"
        }
      },
      {
        "id": "d",
        "text": "ランダムに選んだファイルのみをバックアップする方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "このような方式は存在しません。ランダムなバックアップではデータの整合性が保てず、実用的ではありません。バックアップは体系的に計画されたルールに従って行います。",
          "analogy": "家の中をランダムに選んだものだけ倉庫に入れるのでは、必要なときに重要なものが見つからないかもしれません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "増分バックアップは前回のバックアップ以降に変更されたデータだけを保存する方式です。バックアップ量は最小ですが、復元にはフルバックアップ＋全増分ファイルが必要です。",
      "keyPoint": "フル＝全データ、差分＝フル以降の変更分、増分＝前回以降の変更分。バックアップ量：フル＞差分＞増分。復元の手間：フル＜差分＜増分。",
      "relatedTopics": ["フルバックアップ", "差分バックアップ", "バックアップ戦略", "RTO・RPO"],
      "studyTip": "「増分」の「増」は「増えた分」と覚えましょう。前回からの増加分だけを保存します。"
    },
    "tags": ["バックアップ", "増分バックアップ", "差分バックアップ", "フルバックアップ", "データ保護"]
  },
  {
    "questionId": "q-sc-005",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "デュアルシステムとデュプレックスシステム",
    "level": 2,
    "question": "デュプレックスシステムの説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "2台のコンピュータが全く同一の処理を同時に行い、両方の結果を照合して正確性を確保するシステム",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはデュアルシステムの説明です。デュアルシステムは2台が常に同じ処理を並行して行い、結果を照合することで高い信頼性を確保しますが、コストが高くなります。",
          "analogy": "2人の計算係が同じ問題を別々に解いて答えを照合するイメージです。確実ですが、2倍のリソースが必要です。"
        }
      },
      {
        "id": "b",
        "text": "通常は主系が稼働し、故障時に待機中の従系に切り替えて処理を継続するシステム",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "デュプレックスシステムは「主系（現用系）」と「従系（待機系・スタンバイ系）」の2台で構成されます。通常は主系のみが稼働し、従系は待機状態にあります。主系が故障した場合に従系に切り替えて処理を継続します。デュアルシステムに比べてコスト効率が高い方式です。",
          "analogy": "新幹線の運転士と車掌の関係に似ています。通常は運転士（主系）が運転し、車掌（従系）は補助的な役割で待機しています。運転士が体調不良になった場合に交代できる体制です。",
          "deepDive": "デュプレックスシステムには2種類あります。「ホットスタンバイ」は従系が主系と同じ状態で即座に切り替え可能な方式、「コールドスタンバイ」は従系は電源が入っておらず切り替えに時間がかかる方式です。ホットスタンバイは切り替え時間が短い分コストが高く、コールドスタンバイはコストが低い分切り替えに時間がかかります。"
        }
      },
      {
        "id": "c",
        "text": "複数のコンピュータで処理を分散させ、全体の処理能力を向上させるシステム",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは負荷分散システム（クラスタリング）の説明です。処理を複数のコンピュータに分けることで全体のスループットを向上させますが、デュプレックスシステムの主目的は可用性確保です。",
          "analogy": "これは複数の窓口を開けて行列を分散させるイメージです。デュプレックスは1つの窓口が閉まったときの予備の窓口を用意するイメージです。"
        }
      },
      {
        "id": "d",
        "text": "1台のコンピュータで複数の仮想マシンを動作させるシステム",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは仮想化技術（仮想マシン・ハイパーバイザ）の説明です。1台の物理マシン上で複数の独立した環境を動作させる技術であり、デュプレックスシステムとは異なります。",
          "analogy": "1つの建物を複数の部屋（仮想マシン）に仕切るイメージです。デュプレックスは複数の建物（物理マシン）を用意して万一に備えます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "デュプレックスシステムは主系と従系の2台構成で、通常は主系が稼働し、障害時に従系に切り替えます。デュアルシステム（常時2台が同一処理）との違いを押さえましょう。",
      "keyPoint": "デュアル＝2台が常に同時稼働・結果照合。デュプレックス＝主系が稼働し従系が待機、障害時に切り替え。",
      "relatedTopics": ["ホットスタンバイ", "コールドスタンバイ", "フォールトトレラント", "稼働率", "冗長化"],
      "studyTip": "「デュプレックス」は「二重」の意味です。2台あるが役割が異なる（主系と従系）と覚えましょう。デュアルは2台が同じ役割で並行稼働します。"
    },
    "tags": ["デュプレックスシステム", "デュアルシステム", "ホットスタンバイ", "冗長化", "可用性"]
  },
  {
    "questionId": "q-sc-006",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "負荷分散",
    "level": 2,
    "question": "ロードバランサ（負荷分散装置）を使用する主な目的として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "データを暗号化し、通信の安全性を確保する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "データの暗号化はSSL/TLSや暗号化プロキシの役割です。ロードバランサも SSL オフロード機能を持つ場合がありますが、主目的は負荷分散です。",
          "analogy": "警備員（セキュリティ）と交通整理係（ロードバランサ）は別の役割です。交通整理係の主目的は車の流れを管理することです。"
        }
      },
      {
        "id": "b",
        "text": "複数のサーバに処理を振り分け、特定のサーバへの集中を防ぐ",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ロードバランサはクライアントからのリクエストを複数のバックエンドサーバに均等または条件に応じて振り分け、特定のサーバへの負荷集中を防ぎます。これにより処理能力（スループット）の向上と、1台が障害になっても他のサーバが処理を継続できる可用性の向上も実現します。",
          "analogy": "複数レジが並んでいるスーパーの「案内係」のようなものです。案内係はお客さんを空いているレジに誘導し、特定のレジだけに行列が集中しないよう調整します。",
          "deepDive": "ロードバランサの振り分けアルゴリズムには、順番に振り分ける「ラウンドロビン」、処理中のリクエスト数が少ないサーバに振り分ける「最小コネクション」、サーバの処理能力に応じて振り分ける「重み付きラウンドロビン」などがあります。Webサービスでは、スケールアウト（サーバ台数を増やす）とセットでロードバランサが使われます。"
        }
      },
      {
        "id": "c",
        "text": "ネットワークのトラフィックを監視し、不正アクセスを検知する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "不正アクセスの検知はIDS（侵入検知システム）やIPS（侵入防止システム）、Webアプリケーションファイアウォール（WAF）の役割です。ロードバランサの主目的は負荷分散です。",
          "analogy": "セキュリティカメラ（IDS）と交通整理係（ロードバランサ）は別の役割です。"
        }
      },
      {
        "id": "d",
        "text": "バックアップデータを自動的に別のストレージに保存する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "バックアップデータの自動保存はバックアップソフトウェアやストレージ管理システムの役割です。ロードバランサはネットワーク上のリクエスト振り分けを担当します。",
          "analogy": "荷物の保管係（バックアップ）と交通整理係（ロードバランサ）は全く別の仕事です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ロードバランサは複数のサーバにリクエストを振り分け、負荷を均等に分散させる装置です。スループットの向上と可用性の確保が主な効果です。",
      "keyPoint": "ロードバランサ＝リクエストを複数サーバに振り分け。アルゴリズムにはラウンドロビン・最小コネクションなどがある。",
      "relatedTopics": ["スケールアウト", "クラスタリング", "Webサーバ", "スループット", "可用性"],
      "studyTip": "「ロードバランサ」のロード（Load）は「負荷」、バランサ（Balancer）は「均等にする機器」です。複数サーバへの交通整理役と覚えましょう。"
    },
    "tags": ["負荷分散", "ロードバランサ", "スケールアウト", "可用性", "スループット"]
  },
  {
    "questionId": "q-sc-007",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "RAIDの基本",
    "level": 2,
    "question": "RAID 1 の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "複数のディスクにデータを分散して書き込み、読み書き速度を向上させる方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはRAID 0（ストライピング）の説明です。RAID 0はデータを複数ディスクに分散書き込みすることで高速化しますが、1台でも故障するとデータが失われるため冗長性はありません。",
          "analogy": "荷物を複数の配達員に分けて同時に配送するので速いですが、1人が迷子になると荷物が届きません。"
        }
      },
      {
        "id": "b",
        "text": "全く同じデータを複数のディスクに同時に書き込み、耐障害性を高める方式",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "RAID 1（ミラーリング）は、全く同じデータを2台以上のディスクに同時に書き込む方式です。1台のディスクが故障しても、もう1台に完全なコピーが残っているためデータを失わずに継続稼働できます。耐障害性は高いですが、使用可能容量は実際の合計容量の半分になります。",
          "analogy": "大切な書類を2部コピーして別々の引き出しに保管するようなイメージです。1つの引き出しが開かなくなっても、もう一方に同じ書類があります。ただし保管スペースは2倍必要です。",
          "deepDive": "RAIDのまとめ：RAID 0（ストライピング）＝速度向上・冗長性なし、RAID 1（ミラーリング）＝冗長性最高・容量効率50%、RAID 5（分散パリティ）＝速度と冗長性のバランス・最低3台必要、RAID 6（二重パリティ）＝2台まで同時故障に耐える。基本情報ではRAID 1とRAID 5が頻出です。"
        }
      },
      {
        "id": "c",
        "text": "データとパリティ情報を複数のディスクに分散して書き込み、1台の故障に耐える方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはRAID 5（分散パリティ）の説明です。RAID 5はデータとパリティ（誤り訂正情報）を複数ディスクに分散して書き込み、1台が故障しても残りのディスクとパリティからデータを復元できます。最低3台のディスクが必要です。",
          "analogy": "グループで分担してメモを取り、誰か1人が欠席してもメモを復元できるようにした仕組みです。"
        }
      },
      {
        "id": "d",
        "text": "2台のディスクにデータを分散し、別の1台にパリティを書き込む方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはRAID 3またはRAID 4に近い説明です。これらはパリティ専用ディスクを持つ方式ですが、RAID 1の説明ではありません。RAID 1はミラーリングによる冗長化が特徴です。",
          "analogy": "この説明は「1人が専用でメモの写しを作る係」に相当し、RAID 1（全員が同じメモを持つ）とは異なります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "RAID 1（ミラーリング）は同じデータを複数ディスクに書き込む方式です。1台故障してもデータが保持されますが、使用できる容量は半分になります。",
      "keyPoint": "RAID 0＝ストライピング（速度重視）、RAID 1＝ミラーリング（耐障害性重視）、RAID 5＝分散パリティ（バランス型）。",
      "relatedTopics": ["RAID 0", "RAID 5", "RAID 6", "ストレージ", "冗長化", "パリティ"],
      "studyTip": "RAID 1の「1」は「1対1でコピー」と覚えましょう。ミラーリング（mirror）は鏡のようにそっくりコピーするという意味です。"
    },
    "tags": ["RAID", "RAID1", "ミラーリング", "ストレージ", "冗長化"]
  },
  {
    "questionId": "q-sc-008",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "仮想化の概念",
    "level": 2,
    "question": "サーバ仮想化技術の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "物理サーバを複数の論理的なサーバとして動作させ、1台の物理サーバで複数の独立した環境を実現する技術",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "サーバ仮想化は、1台の物理サーバ上でハイパーバイザ（仮想化ソフトウェア）を使用して複数の仮想マシン（VM）を動作させる技術です。各仮想マシンは独立したOSとアプリケーションを持ち、互いに影響を与えません。物理サーバの台数削減によるコスト削減・電力削減・スペース節約が実現できます。",
          "analogy": "1つのマンション（物理サーバ）を複数の部屋（仮想マシン）に仕切るようなイメージです。各部屋（仮想マシン）は独立していて、隣の部屋の人がうるさくしても自分の部屋には影響しません。",
          "deepDive": "サーバ仮想化の主要な方式：ハイパーバイザ型（物理ハードウェア上に直接ハイパーバイザを導入するタイプ1と、OS上にハイパーバイザを導入するタイプ2）、コンテナ型（Dockerなど、OSカーネルを共有しプロセスを分離する軽量な仮想化）。仮想化のメリットは、サーバ統合・リソース効率化・災害対策・テスト環境の迅速な構築です。"
        }
      },
      {
        "id": "b",
        "text": "複数の物理サーバを1台の高性能サーバとして見せかける技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "複数の物理サーバを1つに見せる技術はクラスタリングに近い概念ですが、サーバ仮想化の説明ではありません。仮想化は1台の物理サーバを複数の論理サーバに分ける（1→多）方向です。",
          "analogy": "これは複数の部屋を1つの大きな部屋に見せかける仕組みで、仮想化（1つの部屋を複数に仕切る）とは逆方向です。"
        }
      },
      {
        "id": "c",
        "text": "サーバをクラウド上に移行し、インターネット経由でサービスを提供する技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはクラウドコンピューティングの説明です。クラウドは仮想化技術を活用していますが、「サーバ仮想化技術」そのものの説明ではありません。仮想化はクラウドを支える技術の1つですが、オンプレミスでも利用されます。",
          "analogy": "クラウドはサービスの提供形態（場所・契約モデル）であり、仮想化はその実現手段（技術）です。「電気」と「電球」ほど違う概念です。"
        }
      },
      {
        "id": "d",
        "text": "ネットワークを通じて遠隔地のサーバを操作し、管理する技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはリモートアクセスやリモート管理（VNCやSSHなど）の説明です。仮想化とは異なります。リモート管理はサーバを遠隔から操作する技術であり、1台の物理マシンを複数の論理マシンに分ける仮想化とは本質的に異なります。",
          "analogy": "遠隔操作はどこからでも部屋に入れる技術で、仮想化は1つの建物を複数の部屋に仕切る技術です。全く別の概念です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "サーバ仮想化は1台の物理サーバ上で複数の独立した仮想マシンを動作させる技術です。コスト削減・効率化・柔軟な環境構築が主なメリットです。",
      "keyPoint": "仮想化＝1台の物理サーバを複数の論理サーバに分割。ハイパーバイザが仮想化を管理。クラウドの基盤技術でもある。",
      "relatedTopics": ["ハイパーバイザ", "仮想マシン", "コンテナ", "クラウドコンピューティング", "シンクライアント"],
      "studyTip": "仮想化は「1→多」（1台を複数に分ける）と覚えましょう。Dockerなどのコンテナ技術も仮想化の一種ですが、OSカーネルを共有するため軽量です。"
    },
    "tags": ["仮想化", "仮想マシン", "ハイパーバイザ", "サーバ統合", "クラウド"]
  },
  {
    "questionId": "q-sc-009",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "稼働率計算（直列・並列）",
    "level": 3,
    "question": "稼働率が 0.9 のシステム A と稼働率が 0.8 のシステム B を並列に接続した場合、全体の稼働率はいくらか。",
    "choices": [
      {
        "id": "a",
        "text": "0.72",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.72 は直列接続の場合の稼働率です。直列接続では全体の稼働率＝A×B＝0.9×0.8＝0.72 となります。並列接続では計算方法が異なります。",
          "analogy": "電球が直列につながった場合は1つが切れると全体が消えます。並列は1つが切れても残りが点灯し続けるので、全体が消える確率はずっと低くなります。"
        }
      },
      {
        "id": "b",
        "text": "0.98",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "並列接続の稼働率は「1－（両方が故障する確率）」で計算します。システムAの故障率＝1－0.9＝0.1、システムBの故障率＝1－0.8＝0.2。両方同時に故障する確率＝0.1×0.2＝0.02。したがって全体の稼働率＝1－0.02＝0.98 となります。",
          "analogy": "2本の道路が並列につながっている場合、全体が通行止めになるのは両方同時に工事中になった場合だけです。道路Aが通行止めになる確率10%、道路Bが10%→20%の場合、両方同時に工事中は2%だけ。だから全体が使える確率は98%です。",
          "deepDive": "並列接続の公式：全体の稼働率＝1－（1－R1）×（1－R2）。一般化すると1－∏(1－Ri)。直列接続の公式：全体の稼働率＝R1×R2×…×Rn。並列接続は稼働率が上がり、直列は下がります。3台以上の並列や混在構成でも同じ考え方を繰り返し適用します。"
        }
      },
      {
        "id": "c",
        "text": "0.85",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.85 は（0.9＋0.8）÷2＝0.85 という単純平均です。稼働率の並列計算は平均ではなく「両方同時に止まる確率」から計算します。",
          "analogy": "2本の道路の使いやすさを「両方の長さを足して2で割る」のは正しい計算ではありません。「どちらかが使えれば通れる」という正しい考え方で計算しましょう。"
        }
      },
      {
        "id": "d",
        "text": "0.90",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.90 はシステムAの稼働率のみを見た値です。並列接続ではシステムAとBの両方が故障しないと全体は止まらないため、全体の稼働率は個々のどちらよりも高くなります。",
          "analogy": "2本の道路があれば、どちらか1本が通れれば通行できます。1本しかない場合より確実に通れる確率が上がります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "並列接続の稼働率は 1－（1－R1）×（1－R2）で計算します。並列接続は稼働率が向上し、直列接続（R1×R2）は稼働率が低下します。",
      "keyPoint": "直列＝R1×R2（全て稼働が必要）。並列＝1－(1－R1)×(1－R2)（両方止まらなければOK）。並列は稼働率が上がる。",
      "relatedTopics": ["MTBF", "MTTR", "冗長化", "デュプレックスシステム", "フォールトトレラント"],
      "studyTip": "並列の計算は「両方が同時に故障する確率＝(1－R1)×(1－R2)」を求め、それを1から引きます。「故障の確率同士を掛ける」と覚えましょう。"
    },
    "tags": ["稼働率", "並列接続", "直列接続", "信頼性", "計算問題"]
  },
  {
    "questionId": "q-sc-010",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "スケールアップ/スケールアウト",
    "level": 3,
    "question": "スケールアウトの説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "既存のサーバをより高性能なサーバに交換し、処理能力を向上させる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはスケールアップ（垂直スケーリング）の説明です。CPUをより高性能なものに交換したり、メモリを増設したりすることで1台のサーバの性能を向上させます。",
          "analogy": "古い車を新しい高性能な車に買い替えるイメージです。台数は変わらずに1台あたりの性能を上げます。"
        }
      },
      {
        "id": "b",
        "text": "サーバの台数を増やし、処理を分散させることで全体の処理能力を向上させる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "スケールアウト（水平スケーリング）は、サーバの台数を増やすことで全体の処理能力を向上させる方式です。1台のサーバに限界が来たとき、同等のサーバを追加して負荷を分散します。クラウド環境ではトラフィックに応じてサーバを自動的に増減できます。",
          "analogy": "コンビニのレジが混雑してきたら、レジを増設（スケールアウト）するか、より速いレジに交換（スケールアップ）するかの選択に例えられます。スケールアウトはレジの台数を増やす方法です。",
          "deepDive": "スケールアップとスケールアウトの比較：スケールアップは設定変更が少なく導入が簡単ですが、サーバ性能の上限や費用の問題があります。スケールアウトは理論上は無限に台数を増やせますが、負荷分散の仕組みが必要でシステムが複雑になります。クラウド（AWS Auto Scalingなど）との相性はスケールアウトが優れています。"
        }
      },
      {
        "id": "c",
        "text": "サーバの設置場所を物理的に分散させ、災害対策を強化する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは地理的冗長化（ジオ冗長・マルチリージョン構成）の説明です。スケールアウトは主に性能向上のためにサーバ台数を増やすことを指します。",
          "analogy": "本社と支社を遠くに置いて災害対策をするのは地理的分散です。スケールアウトは同じ場所にレジを増設するイメージです。"
        }
      },
      {
        "id": "d",
        "text": "不要なプロセスを停止させ、サーバのリソースを最適化する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはリソース最適化やチューニングの説明です。既存のサーバ内部を効率化する作業であり、スケールアウト（台数を増やす）とは異なります。",
          "analogy": "今あるレジの動きを効率化するのはチューニングです。スケールアウトはレジの台数そのものを増やします。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "スケールアウトはサーバ台数を増やして処理能力を向上させる方式（水平スケーリング）です。スケールアップは1台のサーバを高性能化する方式（垂直スケーリング）です。",
      "keyPoint": "スケールアップ＝1台を強化（縦方向）。スケールアウト＝台数を増やす（横方向）。クラウドとの相性はスケールアウトが優れる。",
      "relatedTopics": ["ロードバランサ", "クラスタリング", "クラウドコンピューティング", "負荷分散", "Auto Scaling"],
      "studyTip": "「アウト（Out）」は「外に広げる」イメージ。台数を横に広げるのがスケールアウト。「アップ（Up）」は「上に積み上げる」イメージ。性能を縦に上げるのがスケールアップ。"
    },
    "tags": ["スケールアウト", "スケールアップ", "水平スケーリング", "垂直スケーリング", "負荷分散"]
  },
  {
    "questionId": "q-sc-011",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "NASとSAN",
    "level": 3,
    "question": "NAS（Network Attached Storage）の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "高速な専用ネットワーク（ストレージ専用ネットワーク）を介してサーバにブロックレベルのストレージを提供する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはSAN（Storage Area Network）の説明です。SANはファイバーチャネルなどの専用高速ネットワークでブロックデバイスを提供します。NASとSANは接続方式とデータアクセス方式が異なります。",
          "analogy": "SANはサーバとストレージを太い専用パイプ（専用ネットワーク）でつないだシステムです。NASは既存のLANに共有ドライブを置いたイメージです。"
        }
      },
      {
        "id": "b",
        "text": "通常のLAN（TCP/IP ネットワーク）に接続し、ファイルシステムレベルでストレージを共有する専用機器",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "NASは既存のLAN（イーサネット）に直接接続し、NFS（Unix/Linux向け）やSMB/CIFS（Windows向け）などのプロトコルでファイル共有を提供します。導入が容易で、複数のクライアントやサーバからファイル共有ができます。中小規模のファイルサーバとして広く使われます。",
          "analogy": "NASは「会社の共有ドライブ（ファイルサーバ）」のようなものです。普通のネットワークにつないで、誰でもアクセスできるファイル置き場になります。USB外付けHDDをネットワーク共有できるようにした機器と思えば分かりやすいです。",
          "deepDive": "NAS vs SANの比較：NASは既存のLANに接続・導入コスト低・ファイルレベルアクセス・中小規模向け。SANはファイバーチャネル等の専用ネットワーク・高コスト・ブロックレベルアクセス・大規模エンタープライズ向け。近年はiSCSI（IP-SAN）の普及でIPネットワーク上でブロックアクセスも可能になっています。"
        }
      },
      {
        "id": "c",
        "text": "1台のサーバ内部にインストールし、サーバの内蔵ディスクとして機能するストレージ",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは内蔵ストレージ（DAS：Direct Attached Storage）の説明です。DASはサーバに直接接続されたストレージで、他のサーバとは共有できません。NASはネットワーク経由で複数のサーバ・クライアントから共有できます。",
          "analogy": "DASはあなただけが使える個人の机の引き出し、NASはオフィス全員が使える共有の棚です。"
        }
      },
      {
        "id": "d",
        "text": "データをクラウド上に保存し、インターネット経由でアクセスする仕組み",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはクラウドストレージ（S3やDropboxなど）の説明です。NASはオンプレミス（社内）のネットワークに設置する機器です。クラウドストレージはインターネット経由ですが、NASは通常LANの範囲で使われます。",
          "analogy": "NASは自宅や会社の中に置いた共有の棚、クラウドストレージはインターネットのどこかにある倉庫です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "NASはLANに接続してファイル共有を提供する専用機器です。NFS・SMBなどのプロトコルでファイルシステムレベルのアクセスを提供します。SANは専用ネットワークでブロックレベルのストレージを提供する別の仕組みです。",
      "keyPoint": "NAS＝LAN経由でファイル共有、SANは専用ネットワークでブロックストレージ。NASは導入容易・コスト低。SANは高速・高コスト。",
      "relatedTopics": ["SAN", "DAS", "ファイルサーバ", "iSCSI", "ストレージ"],
      "studyTip": "NASは「Network Attached Storage＝ネットワークに取り付けたストレージ」。SANは「Storage Area Network＝ストレージ専用のネットワーク」。名前の意味から役割を覚えましょう。"
    },
    "tags": ["NAS", "SAN", "DAS", "ストレージ", "ファイル共有"]
  },
  {
    "questionId": "q-sc-012",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "3層アーキテクチャ",
    "level": 3,
    "question": "Webシステムにおける3層アーキテクチャの「ビジネスロジック層」の役割として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ユーザのブラウザに画面を表示し、入力を受け付ける",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはプレゼンテーション層（クライアント層・表示層）の役割です。3層アーキテクチャではプレゼンテーション層がユーザインタフェースを担当し、HTMLやJavaScriptで画面を描画します。",
          "analogy": "レストランの「接客担当（ホール）」が表示層です。ビジネスロジック層は「調理を管理するマネージャ」に相当します。"
        }
      },
      {
        "id": "b",
        "text": "データベースにアクセスしてデータの読み書きを行う",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはデータ層（データベース層）の役割です。RDBMSやNoSQLデータベースがデータの永続化と管理を担当します。ビジネスロジック層はデータ層に処理を依頼する側です。",
          "analogy": "レストランの「食材倉庫係（データ層）」が食材の保管を担当します。ビジネスロジック層はどの食材をどう調理するかを決める「厨房」です。"
        }
      },
      {
        "id": "c",
        "text": "システムのビジネスルールや処理ロジックを実装し、プレゼンテーション層とデータ層の仲介を行う",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ビジネスロジック層（アプリケーション層）は3層アーキテクチャの中間層です。注文処理・在庫管理・割引計算など業務固有のルール（ビジネスロジック）を実装し、プレゼンテーション層からのリクエストを受け取ってデータ層に対してデータの操作を指示します。WebサーバやAPサーバが担当します。",
          "analogy": "レストランの「厨房（コック）」に例えられます。接客係（プレゼンテーション層）から注文を受け取り、どの料理をどう作るか（ビジネスロジック）を判断し、食材倉庫（データ層）から材料を引き出して調理します。",
          "deepDive": "3層アーキテクチャの各層：①プレゼンテーション層（クライアント）＝画面表示・入力受付、②ビジネスロジック層（APサーバ）＝業務処理・ルール実装、③データ層（DBサーバ）＝データ保存・管理。各層を分離することでシステムの保守性・変更容易性・スケーラビリティが向上します。"
        }
      },
      {
        "id": "d",
        "text": "ネットワークの負荷を監視し、通信を最適化する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ネットワーク負荷の監視と最適化はネットワーク管理システムやロードバランサの役割です。ビジネスロジック層は業務処理ロジックの実装を担当します。",
          "analogy": "交通整理係（ネットワーク管理）とレストランの厨房（ビジネスロジック層）は全く別の仕事です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "3層アーキテクチャはプレゼンテーション層（表示）、ビジネスロジック層（業務処理）、データ層（データ管理）の3層構成です。各層の役割分担を押さえましょう。",
      "keyPoint": "プレゼンテーション層＝画面、ビジネスロジック層＝業務処理、データ層＝データ保存。中間の「ビジネスロジック層」が業務ルールを担当。",
      "relatedTopics": ["クライアントサーバシステム", "Webシステム", "APサーバ", "DBサーバ", "MVC"],
      "studyTip": "「3層」は上から「見せる層→処理する層→保存する層」と覚えましょう。ビジネスロジック層は業務の「頭脳」です。"
    },
    "tags": ["3層アーキテクチャ", "ビジネスロジック層", "プレゼンテーション層", "データ層", "Webシステム"]
  },
  {
    "questionId": "q-sc-013",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "フェールセーフ/フェールソフト/フールプルーフ",
    "level": 4,
    "question": "フェールセーフの説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "システムの一部が故障しても、縮退運転などで処理を継続できるように設計する考え方",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはフェールソフト（Fail Soft）の説明です。フェールソフトは一部機能が停止しても残りの機能でサービスを継続する設計です。フェールセーフとは異なります。",
          "analogy": "エンジンが1つ故障しても他のエンジンで飛行を継続できる飛行機はフェールソフトの例です。フェールセーフは安全な状態に「止まる」設計です。"
        }
      },
      {
        "id": "b",
        "text": "故障や誤操作が発生したときに、被害が最小となる安全な状態に移行するよう設計する考え方",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "フェールセーフ（Fail Safe）は、故障や異常が発生した場合にシステムを安全な状態に移行・停止させる設計思想です。「止まることが安全」というケースに適用されます。例：鉄道の信号機は電源が切れると自動的に赤信号になる、エレベータはケーブル切断時にブレーキが作動して停止する。",
          "analogy": "鉄道の踏切を例に考えます。踏切の電源が突然切れたとき、遮断機が「開いた状態（通れる）」で止まると危険です。そのため電源が切れると遮断機が「閉じた状態（通れない）」になるよう設計されています。これがフェールセーフです。",
          "deepDive": "信頼性設計の3つの概念の整理：フェールセーフ＝障害時に安全側に動作（停止・制限）、フェールソフト＝障害時に性能低下しつつも継続動作、フールプルーフ＝そもそも人間が誤操作できないように設計。工業製品・医療機器・交通システムなどではフェールセーフが特に重要視されます。"
        }
      },
      {
        "id": "c",
        "text": "人間が誤操作をしても、システムが正常に動作するよう設計する考え方",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはフールプルーフ（Fool Proof）の説明です。フールプルーフは「馬鹿でも安全（誤操作防止）」という意味で、誤った操作そのものができないよう設計します。例：洗濯機のドアが閉まらないと動作しない、USB端子の向きが決まっている。",
          "analogy": "洗濯機の蓋が空いていると動かない設計がフールプルーフです。フェールセーフは動いている最中に異常が起きたときの安全確保です。"
        }
      },
      {
        "id": "d",
        "text": "コンポーネントを多重化し、障害が発生しても処理を継続できるよう設計する考え方",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはフォールトトレランス（耐障害性）または冗長化の説明です。コンポーネントを二重化・多重化して単一障害点をなくす設計です。フェールセーフは「安全な状態へ移行する」設計であり、継続稼働を目的とするフォールトトレランスとは異なります。",
          "analogy": "スペアタイヤを積んで走り続けられるのはフォールトトレランス（継続稼働）です。フェールセーフは問題発生時に安全に「止まる」ための設計です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "フェールセーフは障害発生時にシステムを安全な状態へ移行・停止させる設計思想です。鉄道信号やエレベータなど安全性が最優先のシステムで採用されます。",
      "keyPoint": "フェールセーフ＝障害時に安全側へ（停止）。フェールソフト＝障害時でも継続（縮退運転）。フールプルーフ＝誤操作できない設計。",
      "relatedTopics": ["フェールソフト", "フールプルーフ", "フォールトトレランス", "冗長化", "信頼性設計"],
      "studyTip": "フェールセーフの「セーフ（Safe）」は「安全」。障害時に「安全に止まる」設計。信号機・エレベータ・医療機器が典型例です。"
    },
    "tags": ["フェールセーフ", "フェールソフト", "フールプルーフ", "信頼性設計", "安全設計"]
  },
  {
    "questionId": "q-sc-014",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "ホットスタンバイ/コールドスタンバイ",
    "level": 4,
    "question": "ホットスタンバイとコールドスタンバイの違いを説明したものとして、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ホットスタンバイは従系が電源オフで待機し、障害時に起動に時間がかかる。コールドスタンバイは従系が常に電源オンで即座に切り替えられる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "説明が逆になっています。ホットスタンバイが「常時稼働・即座に切り替え」、コールドスタンバイが「電源オフまたは低電力状態で待機・切り替えに時間がかかる」です。",
          "analogy": "「ホット（熱い）」はエンジンがかかっている状態、「コールド（冷たい）」はエンジンが止まっている状態で覚えましょう。"
        }
      },
      {
        "id": "b",
        "text": "ホットスタンバイは従系が常時稼働状態で待機し障害時に即座に切り替えられる。コールドスタンバイは従系が停止状態で待機し切り替えに時間がかかる。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ホットスタンバイは従系（待機系）が主系と同様に起動した状態で待機しており、主系で障害が発生した場合に短時間（数秒以内）で切り替えられます。コールドスタンバイは従系が電源オフや最小限の状態で待機しており、切り替え時にOSやアプリの起動が必要なため数分かかります。ホットスタンバイはコストが高いがダウンタイムが少なく、コールドスタンバイはコストが低いが切り替え時間が長い。",
          "analogy": "救急車で考えます。ホットスタンバイは救急車がエンジンをかけたまま駐車場で待機している状態で、いつでも即出動できます。コールドスタンバイは救急車のエンジンを切って待機している状態で、出動命令が来てからエンジンをかける時間が必要です。",
          "deepDive": "スタンバイ方式の比較：ホットスタンバイは切り替え時間が数秒程度と短く、データの同期も行われるためデータ損失が少ないですが、コストが高い。コールドスタンバイは切り替え時間が数分以上かかりますが、コストは低い。ウォームスタンバイはその中間で、OSは起動済みだがアプリは停止状態で待機します。銀行システムや24時間稼働が必要なシステムではホットスタンバイが選ばれます。"
        }
      },
      {
        "id": "c",
        "text": "ホットスタンバイは2台が同時に同じ処理を行い結果を照合する。コールドスタンバイは1台が稼働し別の1台が待機する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "前半の説明はデュアルシステムの説明です。ホットスタンバイは2台が同じ処理を同時に行うのではなく、主系が稼働し従系は待機（同期状態で）しています。デュアルシステムとホットスタンバイは別の概念です。",
          "analogy": "デュアルシステムは2人のパイロットが両方同時に操縦するイメージ。ホットスタンバイは1人が操縦し、もう1人がエンジン全開でいつでも交代できる状態です。"
        }
      },
      {
        "id": "d",
        "text": "ホットスタンバイは主系と従系が異なるデータセンタに設置される。コールドスタンバイは同じデータセンタ内に設置される。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "設置場所の違いではありません。ホット/コールドの違いは「従系が稼働状態にあるかどうか（切り替え時間の差）」です。どちらも同じデータセンタ内にも別々の場所にも設置できます。",
          "analogy": "救急車がどこに駐車しているかではなく、エンジンがかかっているかどうかの違いがホット/コールドの本質です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ホットスタンバイは従系が常時起動状態で即座に切り替え可能です。コールドスタンバイは従系が停止状態で待機し切り替えに時間がかかります。コストとダウンタイムのトレードオフです。",
      "keyPoint": "ホット＝常時起動・即切り替え・高コスト。コールド＝停止状態・切り替えに時間・低コスト。ウォームはその中間。",
      "relatedTopics": ["デュプレックスシステム", "デュアルシステム", "冗長化", "RTO", "可用性"],
      "studyTip": "「ホット（Hot）」は車のエンジンがかかって「温まっている」状態。「コールド（Cold）」はエンジンが止まって「冷えている」状態。エンジンがかかっていればすぐ出発できる、というイメージです。"
    },
    "tags": ["ホットスタンバイ", "コールドスタンバイ", "デュプレックスシステム", "可用性", "冗長化"]
  },
  {
    "questionId": "q-sc-015",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "クラスタリング",
    "level": 4,
    "question": "クラスタリングの説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "1台の高性能サーバを複数の仮想マシンに分割して利用する技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはサーバ仮想化の説明です。1台の物理サーバをハイパーバイザで複数の仮想環境に分割する技術であり、クラスタリング（複数台を1つのように見せる）とは逆方向の考え方です。",
          "analogy": "1軒の家を複数の部屋に仕切るのが仮想化。クラスタリングは複数の家を一軒の大きな家のように使う技術です。"
        }
      },
      {
        "id": "b",
        "text": "複数のコンピュータを相互接続し、全体として1台の高性能コンピュータのように動作させる技術",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "クラスタリングは複数の独立したコンピュータ（ノード）をネットワークで接続し、外部からは単一の大きなシステムとして見せる技術です。目的によって「HAクラスタ（高可用性クラスタ）」と「HPCクラスタ（高性能計算クラスタ）」に分けられます。HAクラスタは可用性向上（ノード障害時の自動切り替え）、HPCクラスタは計算能力向上（処理を分散）を目的とします。",
          "analogy": "複数台の電卓を並べて「スーパーコンピュータ」として使うイメージです。または複数の個人商店が「ショッピングモール」としてまとめて運営されることにも例えられます。外から見ると1つのモールですが、中には複数の独立したお店があります。",
          "deepDive": "クラスタリングの種類：①HAクラスタ（高可用性）＝現用系と待機系のノードをクラスタ化し、障害時に自動フェイルオーバー、②HPCクラスタ（高性能計算）＝多数のノードで処理を分散して大規模計算を実現（スーパーコンピュータ）、③負荷分散クラスタ＝複数ノードにリクエストを分散してスループット向上。Webサーバのクラスタ＝負荷分散クラスタが一般的。"
        }
      },
      {
        "id": "c",
        "text": "データを複数の記憶媒体に分散して保存し、読み書き速度と耐障害性を向上させる技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはRAIDの説明です。RAIDは複数のディスクにデータを分散・冗長化してストレージの性能と信頼性を向上させる技術です。クラスタリングはコンピュータノード単位の技術です。",
          "analogy": "RAIDは「ディスク（引き出し）」を複数使う仕組み、クラスタリングは「コンピュータ（机ごと）」を複数使う仕組みです。スケールが異なります。"
        }
      },
      {
        "id": "d",
        "text": "ネットワーク上のトラフィックを暗号化して安全な通信を実現する技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはVPN（仮想プライベートネットワーク）やTLS/SSLの説明です。クラスタリングはコンピュータを束ねる技術であり、暗号化通信とは全く異なります。",
          "analogy": "セキュリティのためのカーテン（暗号化）と、家を増築して大きくする工事（クラスタリング）は全然別の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "クラスタリングは複数のコンピュータをネットワークで接続し、全体として1台の高性能なシステムとして動作させる技術です。高可用性クラスタと高性能計算クラスタが主な種類です。",
      "keyPoint": "クラスタリング＝複数ノードを束ねて1つに見せる。HA型（可用性向上）とHPC型（計算性能向上）がある。仮想化とは逆方向（多→1）。",
      "relatedTopics": ["ロードバランサ", "フェイルオーバー", "スケールアウト", "仮想化", "負荷分散"],
      "studyTip": "「クラスタ（Cluster）」は「房・群れ」の意味です。複数のコンピュータが「群れ」をなして1つのシステムを構成するイメージを持ちましょう。"
    },
    "tags": ["クラスタリング", "HAクラスタ", "フェイルオーバー", "高可用性", "負荷分散"]
  },
  {
    "questionId": "q-sc-016",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "性能評価指標（ターンアラウンドタイム/レスポンスタイム）",
    "level": 4,
    "question": "バッチ処理における「ターンアラウンドタイム」の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ユーザが入力してからシステムが最初の応答を返すまでの時間",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはレスポンスタイム（応答時間）の説明です。オンライン処理やWebシステムで重要な指標で、ユーザが操作してから画面に反応が出るまでの時間を指します。",
          "analogy": "Webページを開いたときに、ページが表示され始めるまでの待ち時間がレスポンスタイムです。ターンアラウンドタイムは「全て完了するまでの時間」です。"
        }
      },
      {
        "id": "b",
        "text": "ジョブを投入してから、全ての処理が完了して結果を受け取るまでの時間",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ターンアラウンドタイムはバッチ処理などでジョブを投入してから処理が全て完了し結果を受け取るまでの総時間です。待ち時間（キュー待機）＋実際の処理時間＋出力時間の合計です。バッチシステムの性能評価に使われます。",
          "analogy": "クリーニング店でスーツを預けて、完成して受け取るまでの日数がターンアラウンドタイムです。「作業を始める前の待ち時間」も含めた総合的な時間です。レスポンスタイムは「最初に店員に声をかけてから受付完了するまでの時間」です。",
          "deepDive": "性能評価の主要指標：ターンアラウンドタイム＝ジョブ投入から完全完了まで（バッチ処理で重要）、レスポンスタイム＝入力から最初の応答まで（オンライン処理で重要）、スループット＝単位時間あたりの処理件数。スループット＝1/ターンアラウンドタイム（単純な場合）。Webシステムでは「レイテンシ」もレスポンスタイムに近い概念で使われます。"
        }
      },
      {
        "id": "c",
        "text": "単位時間あたりに処理できるジョブの件数",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはスループット（処理能力）の説明です。スループットは単位時間（例：1時間あたり）に処理できるトランザクション数やジョブ数を表す指標です。ターンアラウンドタイムと相互に関連する指標です。",
          "analogy": "クリーニング店が1日に何着のスーツを処理できるかがスループットです。1着を受け取って返すまでの日数がターンアラウンドタイムです。"
        }
      },
      {
        "id": "d",
        "text": "システムが故障してから修理が完了するまでの平均時間",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはMTTR（Mean Time To Repair：平均修復時間）の説明です。MTTRは信頼性の指標であり、ターンアラウンドタイムとは全く異なる概念です。",
          "analogy": "車が故障してから修理完了するまでの時間がMTTRです。ターンアラウンドタイムはジョブの処理完了時間であり、故障・修理とは無関係です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ターンアラウンドタイムはジョブ投入から全処理完了・結果受け取りまでの総時間です。バッチ処理で重要な指標です。レスポンスタイム（最初の応答まで）・スループット（単位時間の処理件数）との違いを押さえましょう。",
      "keyPoint": "ターンアラウンドタイム＝投入から完了まで（バッチ）。レスポンスタイム＝入力から最初の応答まで（オンライン）。スループット＝単位時間の処理件数。",
      "relatedTopics": ["レスポンスタイム", "スループット", "MTBF", "MTTR", "バッチ処理", "性能管理"],
      "studyTip": "「ターンアラウンド（Turn Around）」は「一周して戻る」の意味。仕事を出して、完成して戻ってくるまでの一周の時間と覚えましょう。"
    },
    "tags": ["ターンアラウンドタイム", "レスポンスタイム", "スループット", "性能指標", "バッチ処理"]
  },
  {
    "questionId": "q-sc-017",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "アムダールの法則",
    "level": 5,
    "question": "アムダールの法則に関する説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "プロセッサの数を増やすほど処理速度は比例して向上し、理論上は無限に高速化できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "アムダールの法則はこれを否定しています。並列化できない部分（直列部分）が存在する限り、いくらプロセッサを増やしても高速化には上限があります。無限に高速化できるという考え方は誤りです。",
          "analogy": "料理でいえば、スープを10人で作っても、最後に全員が同じ鍋で一緒に食べるという工程（直列部分）があれば、10人でも1人でも食べ終わる時間は同じです。"
        }
      },
      {
        "id": "b",
        "text": "並列化できない部分の割合により、並列処理による高速化の上限が決まる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "アムダールの法則は「プログラム全体の高速化の上限は並列化できない部分（直列部分）によって決まる」という法則です。プログラムの並列化できない部分の割合をaとすると、最大高速化率＝1/aとなります。例：並列化できない部分が20%（a=0.2）の場合、いくらプロセッサを増やしても最大5倍（1/0.2）にしかなりません。",
          "analogy": "高速道路の渋滞に例えます。高速道路の区間を100レーンにしても、出口が1車線だけなら出口での渋滞が解消されず全体のスループットは出口の処理能力以上にはなりません。この「出口（直列部分）」がボトルネックになります。",
          "deepDive": "アムダールの法則の公式：高速化率＝1 / (a + (1-a)/n)。aは直列部分の割合、nはプロセッサ数。nを無限大にすると高速化率は最大1/aに収束します。グスタフソンの法則は「問題サイズを増やせばスケールアップできる」という視点でアムダールの限界を緩和する考え方として提唱されました。実務ではI/O待ちや排他制御など直列部分をいかに減らすかが並列化設計の鍵です。"
        }
      },
      {
        "id": "c",
        "text": "ソフトウェアの機能が増えるほど、処理速度は指数的に遅くなる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはアムダールの法則とは無関係です。アムダールの法則は並列処理の高速化の限界に関する法則であり、ソフトウェアの機能数と処理速度の関係を述べたものではありません。",
          "analogy": "料理の品数が増えると調理時間が長くなるのは当然ですが、これはアムダールの法則とは全く別の話です。"
        }
      },
      {
        "id": "d",
        "text": "キャッシュメモリを活用することで、メインメモリへのアクセス時間を短縮できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはキャッシュメモリの効果（局所性の原理）の説明です。アムダールの法則は並列化による高速化の限界に関する理論であり、キャッシュメモリとは無関係です。",
          "analogy": "手元にメモ（キャッシュ）を置くと本棚（メインメモリ）まで行かずに済むのはキャッシュの話。アムダールの法則は「何人で作業しても、一人でしかできない工程がある限り全体時間の短縮には限界がある」という別の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "アムダールの法則は、並列化できない直列部分の割合が高速化の上限を決める法則です。直列部分が20%あれば最大5倍にしかなりません。並列化設計ではボトルネックの特定と直列部分の削減が重要です。",
      "keyPoint": "高速化の上限＝1/（直列部分の割合）。プロセッサを無限に増やしても直列部分があれば限界がある。ボトルネック削減が並列化の鍵。",
      "relatedTopics": ["並列処理", "マルチコア", "スループット", "ボトルネック", "グスタフソンの法則"],
      "studyTip": "「直列部分20%→最大5倍」「直列部分10%→最大10倍」と具体例で覚えましょう。直列部分が少ないほど並列化の効果が大きくなります。"
    },
    "tags": ["アムダールの法則", "並列処理", "高速化", "ボトルネック", "性能評価"]
  },
  {
    "questionId": "q-sc-018",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "ベンチマーク（SPEC/TPC）",
    "level": 5,
    "question": "SPEC CPU ベンチマークの説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "データベースのトランザクション処理性能を測定するためのベンチマーク",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "データベースのトランザクション処理性能を測定するベンチマークはTPC（Transaction Processing Performance Council）が策定するTPCベンチマーク（TPC-C、TPC-Eなど）です。SPECはプロセッサの演算性能を測定します。",
          "analogy": "SPECはエンジン（CPU）の性能テスト、TPCは工場（データベース）の生産量テストです。測定対象が異なります。"
        }
      },
      {
        "id": "b",
        "text": "ネットワークの通信速度と帯域幅を測定するためのベンチマーク",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ネットワーク性能の測定にはiperf・Netperfなどのツールが使われます。SPECはネットワークではなくCPUやシステムの計算性能を測定するベンチマークです。",
          "analogy": "ネットワークの速度測定は「道路の交通量測定」、SPECはエンジン（CPU）の性能測定です。測定対象が全く異なります。"
        }
      },
      {
        "id": "c",
        "text": "プロセッサやシステムの演算性能を客観的に比較するための標準化されたベンチマーク",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "SPEC（Standard Performance Evaluation Corporation）はコンピュータの性能測定・比較のための標準ベンチマークを開発・管理する非営利団体です。SPEC CPU は整数演算・浮動小数点演算の性能を測定する代表的なベンチマークで、異なるCPUやシステムの性能を公平に比較するための基準として広く使われます。",
          "analogy": "車の燃費評価に「JC08モード」や「WLTCモード」という統一基準があるように、コンピュータの演算性能を統一基準で測るのがSPECベンチマークです。メーカーが異なってもSPECスコアがあれば公平に比較できます。",
          "deepDive": "主なベンチマークの分類：SPEC CPU（CPU演算性能）、SPEC Power（電力効率）、TPC-C（オンライントランザクション）、TPC-H（データウェアハウス）、LINPACK（スーパーコンピュータのFLOPS値。TOP500ランキングに使用）。ベンチマークは「その環境での測定値」であり、実際のビジネス用途と乖離することもあるため注意が必要です。"
        }
      },
      {
        "id": "d",
        "text": "Webサーバへの同時アクセス数と応答速度を測定するためのベンチマーク",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "WebサーバのパフォーマンステストにはApache JMeter・Locust・ab（Apache Benchmark）などのツールが使われます。SPECにはSPECwebというWebサーバ向けベンチマークもありますが、SPEC CPUはCPU演算性能の測定です。",
          "analogy": "ショッピングモールの混雑シミュレーション（Webサーバ負荷テスト）とエンジンの出力測定（SPEC CPU）は全く別の測定項目です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "SPECはCPU・システムの演算性能を標準化された手法で測定・比較するベンチマークです。TPCはトランザクション処理性能のベンチマークです。用途に応じたベンチマークの種類を押さえましょう。",
      "keyPoint": "SPEC＝CPU・システムの演算性能測定。TPC＝トランザクション処理性能。LINPACK＝スーパーコンピュータのFLOPS測定。",
      "relatedTopics": ["TPC", "LINPACK", "FLOPS", "性能評価", "キャパシティプランニング"],
      "studyTip": "「SPEC（スペック）」は「仕様・性能」の意味でもあります。コンピュータの性能を「規格化（Standard）」して測る団体名です。SPECとTPCのどちらが何を測るか区別して覚えましょう。"
    },
    "tags": ["SPEC", "TPC", "ベンチマーク", "性能評価", "CPU性能"]
  },
  {
    "questionId": "q-sc-019",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "キャパシティプランニング",
    "level": 5,
    "question": "キャパシティプランニングの目的として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "現在発生しているシステム障害の原因を特定し、迅速に復旧する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは障害対応（インシデント管理）の説明です。キャパシティプランニングは将来の需要に備えた事前の計画立案であり、現在の障害対応とは異なります。",
          "analogy": "道路が渋滞しているときの交通整理がインシデント管理。キャパシティプランニングは「5年後の交通量を予測して道路を何車線にするか」を事前に計画することです。"
        }
      },
      {
        "id": "b",
        "text": "将来の需要増加や業務拡張に備え、必要なシステムリソースを事前に計画・確保する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "キャパシティプランニングは、将来のビジネス要件（ユーザ数増加・データ量増加・トランザクション数増加など）を予測し、それに対応できるシステムリソース（CPU・メモリ・ストレージ・ネットワーク帯域）を事前に計画・確保するプロセスです。不足によるパフォーマンス低下と、過剰投資によるコスト増加の両方を避けることが目的です。",
          "analogy": "新しいビルを建てるとき、何年後に何人の従業員が働くかを予測して電気・水道・エレベータの容量を設計します。これがキャパシティプランニングです。最初から十分な容量を確保しないと後から拡張が大変になります。",
          "deepDive": "キャパシティプランニングのプロセス：①現状把握（現在のリソース使用率・性能データの収集）→②需要予測（ビジネス計画から将来の負荷を予測）→③容量計算（必要なリソースを試算）→④計画立案（調達・設置・テストのスケジュール策定）→⑤モニタリング（計画との乖離を監視して調整）。クラウド環境では需要に応じた自動スケーリングが普及し、過剰確保リスクが低減されています。"
        }
      },
      {
        "id": "c",
        "text": "システムのセキュリティホールを発見し、脆弱性を修正する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはセキュリティ評価・脆弱性診断（ペネトレーションテストやセキュリティスキャン）の説明です。キャパシティプランニングはリソースの容量計画であり、セキュリティとは異なります。",
          "analogy": "建物のセキュリティ点検（セキュリティ評価）と、将来の入居者数を予測して駐車場の台数を計画する（キャパシティプランニング）は全く別の活動です。"
        }
      },
      {
        "id": "d",
        "text": "ソフトウェアの品質を評価し、リリース可能かどうかを判定する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはソフトウェアテスト・品質保証（QA）の説明です。キャパシティプランニングはインフラリソース（ハードウェア・ネットワーク）の容量計画であり、ソフトウェア品質の評価とは異なります。",
          "analogy": "製品の品質検査（QA）と工場の生産能力計画（キャパシティプランニング）は別の業務です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "キャパシティプランニングは将来の需要増加に備え、必要なシステムリソースを事前に計画・確保するプロセスです。現状把握→需要予測→容量計算→計画立案の流れで進めます。",
      "keyPoint": "キャパシティプランニング＝将来の需要予測に基づくリソース容量計画。不足（性能低下）と過剰（コスト増）の両方を防ぐ。",
      "relatedTopics": ["TCO", "SLA", "性能管理", "スケールアウト", "クラウドコンピューティング"],
      "studyTip": "「キャパシティ（Capacity）」は「容量・収容能力」の意味。将来「どれだけ入れられるか」を事前に計画するプロセスです。"
    },
    "tags": ["キャパシティプランニング", "需要予測", "リソース管理", "性能管理", "システム計画"]
  },
  {
    "questionId": "q-sc-020",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "TCO（総所有コスト）",
    "level": 5,
    "question": "TCO（Total Cost of Ownership：総所有コスト）の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "システムの初期導入費用（ハードウェア・ソフトウェアの購入費用）だけを指す",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "TCOは初期費用だけでなく、運用・保守・廃棄までの全ライフサイクルを通じたコストの合計です。初期費用のみを指す概念ではありません。初期費用はTCOの一部に過ぎません。",
          "analogy": "車の「車両本体価格」だけで経済性を判断するのは誤りです。ガソリン代・保険・車検・修理代なども含めた「維持費総額」がTCOに相当します。"
        }
      },
      {
        "id": "b",
        "text": "システムの導入から廃棄まで全ライフサイクルにわたる全コスト（初期費用＋運用費用＋保守費用など）の合計",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "TCO（Total Cost of Ownership）はシステムの調達・導入から運用・保守・廃棄まで、ライフサイクル全体を通じた総コストです。初期費用（ハードウェア・ソフトウェア購入費、設置費、初期教育費）と、ランニングコスト（電力費・施設費・人件費・保守費・ライセンス費・バックアップ費・アップグレード費）の全てを合計します。",
          "analogy": "マイカーのTCOは「車両購入費」だけでなく「ガソリン代＋保険料＋車検費用＋駐車場代＋タイヤ交換費＋最終的な廃車費用」まで含めた金額です。安い車でもランニングコストが高ければTCOは大きくなります。",
          "deepDive": "TCOの構成要素：直接費用（ハードウェア・ソフトウェア・ネットワーク費）＋間接費用（管理・サポート人件費・電力・施設・エンドユーザ支援・ダウンタイムによる損失）。IT投資の評価ではTCOをROI（投資対効果）と組み合わせて判断します。クラウドへの移行ではTCOの削減が主な根拠となることが多く、オンプレミスとクラウドのTCO比較が重要です。"
        }
      },
      {
        "id": "c",
        "text": "システム開発プロジェクトに要した開発工数（人月）の合計",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "開発工数（人月）は開発費用の一部であり、TCO全体を指す概念ではありません。TCOは開発費・運用費・保守費など全ての費用を含みます。また、TCOは金額で表されるのが通常であり、工数だけでは評価できません。",
          "analogy": "家を建てるときの大工さんの作業日数だけを計算しても、それは家の建設費の一部であり、光熱費・修繕費・固定資産税などを含む総所有コストではありません。"
        }
      },
      {
        "id": "d",
        "text": "システムの性能測定において、一定時間内に処理できるトランザクション数",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはスループット（処理能力）の説明です。TCOはコストに関する概念であり、性能測定とは無関係です。",
          "analogy": "工場の生産台数（スループット）と工場を所有・運営するためのトータルコスト（TCO）は別の指標です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "TCOはシステムの調達から廃棄まで全ライフサイクルにわたる全費用（初期費用＋運用費用＋保守費用等）の合計です。クラウド移行の意思決定やシステム選定時にオンプレミスとの比較で重要な指標です。",
      "keyPoint": "TCO＝初期費用＋ランニングコスト全体。「買うだけでなく使い続けるコスト」も含む。クラウドvsオンプレミスの判断に使われる。",
      "relatedTopics": ["ROI（投資対効果）", "クラウドコンピューティング", "SLA", "キャパシティプランニング", "IT投資"],
      "studyTip": "「Total（全部の）Cost of Ownership（所有するコスト）」。買った後の電気代・人件費・修理費まで全部含めたコストです。安く買えても維持費が高いとTCOは大きくなります。"
    },
    "tags": ["TCO", "総所有コスト", "IT投資", "コスト管理", "クラウド移行"]
  }
]
