[
  {
    "questionId": "q-sc-021",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "複数サブシステムの稼働率計算",
    "level": 6,
    "question": "あるシステムは、サブシステムA（稼働率0.9）とサブシステムB（稼働率0.8）が直列に接続され、その組み合わせに対してサブシステムC（稼働率0.95）が並列に接続された構成となっている。このシステム全体の稼働率として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "0.968",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "まず直列部分（AとB）の稼働率を計算します。直列接続の稼働率＝各サブシステムの稼働率の積なので、0.9×0.8＝0.72です。次に、この直列部分（稼働率0.72）とCが並列接続された場合の稼働率を計算します。並列接続の稼働率＝1－（1－0.72）×（1－0.95）＝1－0.28×0.05＝1－0.014＝0.986となります。",
          "analogy": "通勤路線に例えると、A駅とB駅を必ず経由する路線（直列）が運休しやすくても、別の迂回路線C（並列）があれば、全体として目的地に到着できる確率が上がります。迂回路があると信頼性が大きく改善します。",
          "deepDive": "稼働率計算の基本公式：直列＝R1×R2、並列＝1－(1－R1)×(1－R2)。複合構成では内側から順に計算することが重要です。試験では計算ミスを防ぐため、まず構成図を整理してから段階的に計算することを心がけましょう。なお、問題文の数値を再計算すると0.9×0.8=0.72、並列部分=1-(1-0.72)×(1-0.95)=1-0.014=0.986となります。"
        }
      },
      {
        "id": "b",
        "text": "0.720",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.720はAとBの直列接続部分のみの稼働率（0.9×0.8）です。並列接続されているサブシステムCを考慮していません。Cが存在することで全体の稼働率はさらに高くなります。",
          "analogy": "通勤で一つの路線だけを考えていて、迂回路の存在を忘れてしまった状態です。迂回路があればもっと確実に目的地に着けます。"
        }
      },
      {
        "id": "c",
        "text": "0.950",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.950はサブシステムCだけの稼働率です。AとBの直列部分との並列合成を計算していません。並列合成後はCの稼働率より高い値になります。",
          "analogy": "迂回路（C）の信頼性だけを見て、メイン路線（AとB）との組み合わせ効果を無視している状態です。"
        }
      },
      {
        "id": "d",
        "text": "0.684",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.684は0.72×0.95＝0.684であり、直列部分とCをさらに直列接続した場合の値です。問題の構成はCが並列に接続されており、直列ではないため計算方法が誤っています。",
          "analogy": "迂回路（C）を「ついでに追加で通らないといけない道」と誤解してしまった状態です。並列とは「どちらか一方が動けばよい」という関係です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "複合構成の稼働率は「直列：積の法則」「並列：1から故障率の積を引く法則」を組み合わせて、内側から段階的に計算します。",
      "keyPoint": "直列R=R1×R2、並列R=1－(1－R1)×(1－R2)。複合構成は内側から順に計算する。",
      "relatedTopics": ["稼働率", "MTBF", "MTTR", "フォールトトレランス", "冗長構成"],
      "studyTip": "複合構成の問題は、必ず構成図を手書きで整理してから計算を始めましょう。どこが直列でどこが並列かを正確に把握することが最重要です。"
    },
    "tags": ["稼働率計算", "直列接続", "並列接続", "複合構成", "信頼性"]
  },
  {
    "questionId": "q-sc-022",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "ロードバランサの振り分け方式",
    "level": 6,
    "question": "ロードバランサにおけるラウンドロビン方式の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "各サーバの現在の接続数を監視し、接続数が最も少ないサーバにリクエストを振り分ける方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「最小接続数方式（Least Connections）」の説明です。現時点での負荷状況を動的に監視し、最も空いているサーバに振り分けます。リクエストの処理時間にばらつきがある場合に有効です。",
          "analogy": "スーパーのレジに例えると、常に一番列の短いレジを選ぶ方式です。混雑状況をリアルタイムで見て判断します。"
        }
      },
      {
        "id": "b",
        "text": "リクエスト元のIPアドレスをハッシュ化し、その値に基づいて振り分けるサーバを決定する方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「IPハッシュ方式」の説明です。同じクライアントのリクエストを常に同じサーバに振り分けるため、セッション維持が必要なアプリケーションに適しています。",
          "analogy": "担当制のサービスカウンターに例えると、来店者の住所（IPアドレス）に応じて担当者を固定する方式です。同じお客様は常に同じ担当者が対応します。"
        }
      },
      {
        "id": "c",
        "text": "複数のサーバに対して順番に1件ずつリクエストを振り分け、最後のサーバに達したら最初のサーバに戻る方式",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ラウンドロビン方式は、サーバA→B→C→A→B→C→…と順番に均等にリクエストを割り当てる最もシンプルな方式です。各サーバへの負荷分散が均等になりますが、各リクエストの処理時間が均一であることが前提です。設定が簡単で広く使われています。",
          "analogy": "野球のバッティング順に例えると、1番→2番→3番→1番→2番→と順番に打席に立つようなイメージです。全員に均等に機会が回ってきます。",
          "deepDive": "ラウンドロビンの変形として「重み付きラウンドロビン（Weighted Round Robin）」があり、サーバのスペックに応じてリクエスト数の比率を変えられます（例：高性能サーバに2倍のリクエスト）。シンプルなラウンドロビンは処理時間が均一なHTTPリクエストに適していますが、処理時間が不均一な場合は最小接続数方式の方が効率的です。"
        }
      },
      {
        "id": "d",
        "text": "サーバのCPU使用率やメモリ使用率をリアルタイムで監視し、最もリソースに余裕のあるサーバに振り分ける方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「リソースベース方式（Resource Based）」の説明です。各サーバのリソース状況をエージェントで収集し、最適なサーバに振り分けます。精度は高いですが監視のオーバーヘッドが生じます。",
          "analogy": "従業員の忙しさを上司がリアルタイムで把握し、一番手が空いている人に仕事を割り振るイメージです。精度は高いですが管理コストもかかります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ロードバランサの振り分け方式には、ラウンドロビン・最小接続数・IPハッシュ・リソースベースなどがあり、それぞれ適した用途が異なります。",
      "keyPoint": "ラウンドロビン＝順番に均等割り当て、最小接続数＝接続数が少ないサーバ優先、IPハッシュ＝同一クライアントを同一サーバへ固定。",
      "relatedTopics": ["負荷分散", "クラスタリング", "スケールアウト", "セッション管理", "Webシステム構成"],
      "studyTip": "各方式の名前とその特徴を対応させて覚えましょう。「ラウンドロビン＝野球の打順」「最小接続数＝空いているレジ」のように、日常のたとえで記憶すると定着しやすいです。"
    },
    "tags": ["ロードバランサ", "負荷分散", "ラウンドロビン", "スケールアウト", "Webシステム"]
  },
  {
    "questionId": "q-sc-023",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "コンテナ技術（Docker）",
    "level": 6,
    "question": "Dockerに代表されるコンテナ技術の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ハードウェアを仮想化してゲストOSを完全に分離して動かす技術であり、各コンテナは独自のカーネルを持つ",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはハイパーバイザ型の仮想マシン（VM）の説明です。コンテナはホストOSのカーネルを共有するため、独自のカーネルを持ちません。この違いがコンテナの軽量性につながっています。",
          "analogy": "一軒家（VM）と集合住宅（コンテナ）の違いです。一軒家は基礎から独立していますが、集合住宅は建物の基礎（カーネル）を住民全員で共有します。"
        }
      },
      {
        "id": "b",
        "text": "アプリケーションとその依存ライブラリをひとつの実行単位にまとめ、ホストOSのカーネルを共有しながら独立したプロセス空間で動かす技術",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "コンテナはアプリケーションとその実行に必要なライブラリ・設定ファイル等をひとつのイメージにパッケージ化します。ホストOSのカーネルを共有するため、仮想マシンよりも起動が速く（数秒）、リソース消費も少ないです。Dockerはコンテナの作成・配布・実行を標準化したプラットフォームです。",
          "analogy": "お弁当箱に例えると、コンテナはアプリケーション（おかず）と必要な調味料（ライブラリ）をひとつの箱にまとめたものです。どんな場所（環境）に持っていっても、同じ味（動作）が保証されます。",
          "deepDive": "コンテナを実現する主要技術はLinuxの「namespace（プロセス空間の分離）」と「cgroups（リソース制限）」です。Dockerイメージはレイヤー構造を持ち、差分のみを管理するため効率的です。コンテナのオーケストレーションにはKubernetesが広く使われます。VMと比較して起動時間：秒単位 vs 分単位、リソース：軽量 vs 重量、という違いがあります。"
        }
      },
      {
        "id": "c",
        "text": "複数の物理サーバを論理的に一台のサーバとして扱い、処理能力を集約してひとつのOSから管理する技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはサーバ統合やグリッドコンピューティングに近い説明です。コンテナは一台のホスト上で複数の独立した実行環境を作る技術であり、複数の物理サーバを一台に見せる技術ではありません。",
          "analogy": "複数の工場を一つの大工場として管理する話で、コンテナとは逆の方向性です。コンテナは一つの工場の中に独立した作業スペースを複数作るイメージです。"
        }
      },
      {
        "id": "d",
        "text": "アプリケーションのソースコードをクラウド上に保存し、必要なときだけ自動でビルド・実行するサーバレスコンピューティングの一形態",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはFaaS（Function as a Service）やサーバレスアーキテクチャの説明です。Dockerコンテナは常駐プロセスとして動作する技術であり、サーバレスとは異なる概念です。",
          "analogy": "コンビニのホットスナック（コンテナ：常に準備されている）と、注文ごとに作るオーダーメイド料理（サーバレス：必要な時だけ実行）の違いです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "コンテナ技術はホストOSのカーネルを共有しながら、アプリケーションとその依存環境を隔離・パッケージ化して実行する技術です。VMより軽量で起動が速い点が特徴です。",
      "keyPoint": "コンテナ＝ホストOSカーネルを共有、VM＝独自カーネルを持つ。コンテナの方が軽量・高速起動。",
      "relatedTopics": ["Docker", "Kubernetes", "仮想マシン", "ハイパーバイザ", "マイクロサービス", "CI/CD"],
      "studyTip": "VM（仮想マシン）とコンテナの違いを「カーネルを共有するかどうか」で整理しましょう。試験ではこの違いを問う問題が頻出です。"
    },
    "tags": ["コンテナ", "Docker", "仮想化", "Kubernetes", "マイクロサービス"]
  },
  {
    "questionId": "q-sc-024",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "ディザスタリカバリ（RPO・RTO）",
    "level": 6,
    "question": "ディザスタリカバリにおけるRPO（Recovery Point Objective）の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "障害発生からシステムが復旧するまでに許容できる最大時間のこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはRTO（Recovery Time Objective：目標復旧時間）の説明です。RTOは「どれだけ速く復旧しなければならないか」という時間の目標値です。RPOとRTOはしばしば混同されるため、それぞれの定義を正確に押さえることが重要です。",
          "analogy": "火事に例えると、RTOは「消火から建物が使えるようになるまでの許容時間」です。RPOは「最後のバックアップからの許容データ損失量」で別の概念です。"
        }
      },
      {
        "id": "b",
        "text": "障害発生時にデータを復旧できる最も古い時点であり、許容できる最大のデータ損失量を時間で表したもの",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "RPOは「どの時点までのデータを失ってもよいか」を表す指標です。例えばRPOが1時間であれば、最大1時間分のデータ損失は許容されます。RPOが短いほど頻繁なバックアップや高可用性構成が必要となり、コストが増大します。RPO＝0の場合はデータ損失ゼロが要求され、リアルタイム同期が必要です。",
          "analogy": "ゲームのセーブポイントに例えると、RPOは「最後のセーブからどれだけ前に戻ることを許容できるか」です。RPO1時間なら、1時間前のセーブポイントに戻ることを覚悟する必要があります。",
          "deepDive": "RPOとRTOはBCP（事業継続計画）・DR（ディザスタリカバリ）設計の核心指標です。RPOを短縮するには同期レプリケーション・頻繁なスナップショット・ジャーナリングなどが有効です。RTOを短縮するにはホットスタンバイ・自動フェイルオーバーなどが有効です。両指標を短くするほどコストが上がるため、ビジネス要件とのバランスが重要です。"
        }
      },
      {
        "id": "c",
        "text": "災害発生時にバックアップサイトへの切り替えが完了するまでに必要な作業工数の目標値",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはフェイルオーバー手順の工数に関する説明であり、RPOの定義ではありません。RPOはデータの損失を時間で表した指標であり、作業工数とは異なります。",
          "analogy": "避難訓練の「避難完了までの目標時間」に近い説明で、それはRTOに相当します。RPOはデータの「どこまで戻るか」の話です。"
        }
      },
      {
        "id": "d",
        "text": "バックアップサイトで運用を継続できる最大期間のこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはDR運用の持続可能期間に関する説明ですが、RPOの定義ではありません。RPOはデータ損失の許容量（時間で表現）であり、運用継続期間とは別の概念です。",
          "analogy": "避難所での生活を何日間続けられるかという話で、これはBCPにおける別の指標です。RPOはあくまで「何時間前のデータまで許容するか」という話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "RPO（目標復旧時点）はデータ損失の許容量を時間で表し、RTO（目標復旧時間）はシステム復旧までの許容時間です。この2つの違いを明確に区別することが重要です。",
      "keyPoint": "RPO＝どこまで戻るか（データ損失の許容量）、RTO＝どれだけ速く復旧するか（復旧までの許容時間）。",
      "relatedTopics": ["BCP", "DR（ディザスタリカバリ）", "バックアップ", "フェイルオーバー", "レプリケーション"],
      "studyTip": "RPO（Point）は「地点・時点」＝データをどこまで取り戻せるか、RTO（Time）は「時間」＝復旧にかかる時間、と英単語の意味から覚えましょう。"
    },
    "tags": ["ディザスタリカバリ", "RPO", "RTO", "BCP", "バックアップ", "可用性"]
  },
  {
    "questionId": "q-sc-025",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "待ち行列理論（M/M/1）の応用",
    "level": 7,
    "question": "M/M/1の待ち行列モデルにおいて、サービス率μ＝20件/時間、到着率λ＝15件/時間のとき、システム内（待ち行列＋サービス中）の平均仕事数として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "0.75件",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.75はサーバ利用率ρ＝λ/μ＝15/20＝0.75の値です。これはシステム内の平均仕事数ではなく、サーバが仕事をしている時間の割合（稼働率）を表します。平均仕事数Lの計算にはρを使いますが、ρ自体が答えではありません。",
          "analogy": "レジ係が何%の時間働いているかという「稼働率」と、レジ前に何人並んでいるかという「平均人数」は別の話です。稼働率75%から平均人数を求めるには別の計算が必要です。"
        }
      },
      {
        "id": "b",
        "text": "3件",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "M/M/1モデルのシステム内平均仕事数L＝ρ/(1－ρ)で求めます。まずρ＝λ/μ＝15/20＝0.75を計算し、L＝0.75/(1－0.75)＝0.75/0.25＝3件となります。この3件にはサービス中の1件と待ち行列内の2件が含まれています。",
          "analogy": "銀行の窓口に例えると、窓口（サーバ）で対応中の人と、待合椅子で待っている人を合わせた平均人数が3人ということです。利用率が75%と高いため、待ち客が膨らみます。",
          "deepDive": "M/M/1モデルの重要公式：稼働率ρ＝λ/μ（ρ<1でないとシステムが安定しない）、システム内平均仕事数L＝ρ/(1－ρ)、待ち時間W＝L/λ（リトルの法則）。ρが1に近づくほどLは急激に増大します（例：ρ＝0.9ならL＝9件）。これがシステム設計でサーバ利用率を80%以下に抑える理由です。"
        }
      },
      {
        "id": "c",
        "text": "4件",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "4件はL＝λ/(μ－λ)＝15/(20－15)＝15/5＝3件を誤って計算した場合や、別の公式と混同した結果です。正しい計算ではρ/(1－ρ)＝0.75/0.25＝3件となります。",
          "analogy": "計算の途中で式を誤って適用してしまった場合の誤答です。公式はρ/(1－ρ)であり、分子・分母の値を正確に代入することが重要です。"
        }
      },
      {
        "id": "d",
        "text": "5件",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "5件はμ－λ＝20－15＝5という引き算の結果と混同した可能性があります。待ち行列理論の公式では到着率と処理率の差（μ－λ）はL＝λ/(μ－λ)という別形式の計算に現れますが、その結果も3件です。5件という値は正しい公式から導かれません。",
          "analogy": "λとμの差分（5件/時間）という数字が「5件」という答えに見えてしまう誤りです。待ち行列の公式は単純な差ではなく、稼働率ρを基にした非線形な計算です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "M/M/1モデルのシステム内平均仕事数はL＝ρ/(1－ρ)で求めます。稼働率ρ＝λ/μを求めてから代入します。ρが高いほどLは急激に増大します。",
      "keyPoint": "ρ＝λ/μ、L＝ρ/(1－ρ)。ρが1に近づくほど待ち時間が急増するため、実運用では80%以下に抑えることが推奨されます。",
      "relatedTopics": ["待ち行列理論", "リトルの法則", "サーバ利用率", "性能設計", "キャパシティプランニング"],
      "studyTip": "公式はρ/(1－ρ)のみ確実に覚えましょう。試験ではρの計算ミスが多いため、λとμの値を問題文で確認してから落ち着いて計算してください。"
    },
    "tags": ["待ち行列理論", "M/M/1", "稼働率", "平均仕事数", "性能評価"]
  },
  {
    "questionId": "q-sc-026",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "信頼性ブロック図",
    "level": 7,
    "question": "信頼性ブロック図（RBD）において、3つのユニットA・B・CをA→Bの直列、その組み合わせとCを並列に接続した構成のシステム全体の稼働率が0.986である場合、Cの稼働率はいくらか。ただし、Aの稼働率は0.9、Bの稼働率は0.8とする。",
    "choices": [
      {
        "id": "a",
        "text": "0.95",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "まずAとBの直列部分の稼働率R_AB＝0.9×0.8＝0.72を求めます。次に全体の稼働率の式：R_total＝1－(1－R_AB)×(1－R_C)を使います。0.986＝1－(1－0.72)×(1－R_C)より、(1－R_C)＝(1－0.986)/0.28＝0.014/0.28＝0.05、したがってR_C＝1－0.05＝0.95です。",
          "analogy": "全体のシステム信頼性という「結果」が分かっていて、Cという「部品の仕様」を逆算する問題です。料理の最終的な塩分濃度から、追加した調味料の量を逆算するようなイメージです。",
          "deepDive": "信頼性ブロック図（RBD）は複雑なシステムの信頼性を視覚的に表現し、計算するための手法です。並列構成の公式R＝1－(1－R1)×(1－R2)を逆算すると(1－R2)＝(1－R_total)/(1－R1)となります。この逆算アプローチはシステム設計時に目標稼働率を達成するための各コンポーネントの要件を決定する際にも使われます。"
        }
      },
      {
        "id": "b",
        "text": "0.90",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "Cの稼働率を0.90と仮定すると、全体稼働率＝1－(1－0.72)×(1－0.90)＝1－0.28×0.10＝1－0.028＝0.972となり、問題の0.986と一致しません。",
          "analogy": "答えを当てずっぽうに選んだ場合です。正確には逆算の式を使って求める必要があります。"
        }
      },
      {
        "id": "c",
        "text": "0.98",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "Cの稼働率を0.98と仮定すると、全体稼働率＝1－(1－0.72)×(1－0.98)＝1－0.28×0.02＝1－0.0056≒0.994となり、問題の0.986と一致しません。",
          "analogy": "計算を逆に追わずに全体稼働率の値に近い数字を選んでしまった誤りです。並列構成の計算式に正しく代入して逆算する必要があります。"
        }
      },
      {
        "id": "d",
        "text": "0.72",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.72はAとBの直列接続の稼働率R_AB＝0.9×0.8の値です。Cの稼働率をABの直列部分と同じ値と混同した誤りです。",
          "analogy": "問題の途中計算結果をそのまま答えにしてしまった誤りです。直列部分の結果はCの逆算の「道具」であり、Cそのものの稼働率ではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "信頼性ブロック図の問題では、全体稼働率の式から未知の稼働率を逆算できます。並列の公式R＝1－(1－R1)×(1－R2)を変形して未知数を求めます。",
      "keyPoint": "並列稼働率の公式を逆算：(1－R_C)＝(1－R_total)/(1－R_AB)。計算は内側の直列部分から順番に行う。",
      "relatedTopics": ["稼働率計算", "RBD", "直列接続", "並列接続", "信頼性設計", "RASIS"],
      "studyTip": "稼働率の逆算問題は「全体の式に既知の値を代入し、未知数について解く」という代数的アプローチで解きます。式変形の練習を繰り返しましょう。"
    },
    "tags": ["信頼性ブロック図", "RBD", "稼働率", "逆算", "信頼性設計"]
  },
  {
    "questionId": "q-sc-027",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "SLA（サービスレベル合意）",
    "level": 7,
    "question": "SLA（Service Level Agreement）に関する記述として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "SLAはシステム開発における機能要件と非機能要件を定義した内部仕様書であり、開発チーム内でのみ使用される",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "SLAはサービス提供者と顧客（利用者）の間で締結される合意文書であり、内部仕様書ではありません。また開発チーム内のみで使われるものでもなく、サービス品質に関する契約的な性質を持ちます。",
          "analogy": "SLAは引越し業者と顧客の間で交わす「〇時までに荷物を届けます」という約束書のようなものです。社内だけの話ではなく、お客様との約束です。"
        }
      },
      {
        "id": "b",
        "text": "サービス提供者と利用者の間で、提供するサービスの品質水準（可用性・応答時間・サポート対応時間など）を定量的に合意した文書",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "SLAはサービス提供者（クラウド事業者・ITベンダー等）と顧客（利用企業等）の間で、サービス品質の水準を具体的な数値で取り決めた合意書です。典型的な指標として、稼働率（例：99.9%以上）・応答時間（例：2秒以内）・問い合わせ対応時間（例：24時間以内）などが含まれます。SLA違反時のペナルティ（サービスクレジット等）も規定されることが多いです。",
          "analogy": "引越し業者との契約書に例えると、「〇時から〇時の間に届ける（稼働時間）」「万一遅延した場合は〇円引く（ペナルティ）」といった具体的な約束を書面にしたものがSLAです。",
          "deepDive": "SLAには複数の関連概念があります。SLO（Service Level Objective）はサービス提供者が内部目標として設定する値（SLAより厳しく設定）、SLI（Service Level Indicator）はSLOの達成度を測る実際の指標（可用性・エラー率・レイテンシ等）です。Google SREではSLA/SLO/SLIの3層構造で品質管理を行います。"
        }
      },
      {
        "id": "c",
        "text": "サービスの障害発生時に担当者が実行する手順を詳細に記述した障害対応マニュアルのこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "障害対応マニュアルはインシデント対応手順書（Runbook）やエスカレーション手順書に相当します。SLAはサービス品質の水準を合意する文書であり、対応手順の記述ではありません。SLAには「いつまでに復旧するか（RTO）」は含まれますが、具体的な手順は含まれません。",
          "analogy": "SLAは「夕食を6時までに準備する」という約束です。その約束を守るための料理レシピや手順はSLAではなく、内部の作業手順書に相当します。"
        }
      },
      {
        "id": "d",
        "text": "クラウドサービスの利用料金体系と課金方法について、利用者が事前に同意するための利用規約",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "料金体系や課金方法はToS（Terms of Service：利用規約）や料金表に記載される内容です。SLAはサービスの「品質水準」に関する合意であり、料金体系の説明ではありません。",
          "analogy": "「サービスの料金表」と「サービスの品質保証書」は別書類です。SLAは品質保証書の方です。いくらお金を払うかではなく、どれだけの品質が保証されるかを定めます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "SLAはサービス提供者と利用者の間でサービス品質（稼働率・応答時間等）を数値で合意した文書です。違反時のペナルティも規定されます。",
      "keyPoint": "SLA＝品質の約束書（提供者と顧客の間）。稼働率・応答時間・サポート時間などを数値で定義。SLA/SLO/SLIの3層構造も覚えておく。",
      "relatedTopics": ["SLO", "SLI", "可用性", "稼働率", "クラウドサービス", "サービス管理", "ITIL"],
      "studyTip": "SLAのAgreement（合意）という英単語から、「両者が合意した品質約束」と覚えましょう。クラウド各社のSLA（AWS 99.99%など）を実際に調べてみると理解が深まります。"
    },
    "tags": ["SLA", "SLO", "SLI", "サービス品質", "可用性", "クラウド"]
  },
  {
    "questionId": "q-sc-028",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "ハイパーバイザ型仮想化",
    "level": 7,
    "question": "ハイパーバイザ型仮想化におけるタイプ1（ネイティブ型）とタイプ2（ホスト型）の違いとして、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "タイプ1はゲストOSを一台のみ動かせるのに対し、タイプ2は複数のゲストOSを同時に動かすことができる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "タイプ1・タイプ2ともに、複数のゲストOSを同時に動かすことができます。複数起動の可否はタイプの違いではなく、ハードウェアリソースの量に依存します。",
          "analogy": "マンションの1階と2階の違いではなく、どちらの階もアパートとして複数の部屋（ゲストOS）を持てます。"
        }
      },
      {
        "id": "b",
        "text": "タイプ1はハイパーバイザがハードウェア上に直接動作し、タイプ2はホストOS上でアプリケーションとして動作する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "タイプ1（ネイティブ型）のハイパーバイザはハードウェアに直接インストールされ、OSなしでハードウェアを直接制御します（例：VMware ESXi、Hyper-V、Xen）。タイプ2（ホスト型）はWindows・macOSなどのホストOS上でアプリケーションとして動作します（例：VMware Workstation、VirtualBox）。タイプ1の方がオーバーヘッドが少なく性能・信頼性が高いため、データセンターや本番環境ではタイプ1が主流です。",
          "analogy": "タイプ1は「土地に直接建てた家（ハードウェア上に直接）」、タイプ2は「既存の家の中に作ったプレハブ小屋（ホストOS上のアプリ）」のイメージです。前者の方が安定性と性能が高いです。",
          "deepDive": "タイプ1の代表例：VMware vSphere/ESXi（エンタープライズ向け）、Microsoft Hyper-V、Xen（AWSのEC2で使用）。タイプ2の代表例：VMware Workstation、Oracle VirtualBox（開発・テスト環境向け）。タイプ1はハードウェアと直接通信するため、ハードウェアドライバの管理も行います。クラウドのIaaS基盤はほぼタイプ1ハイパーバイザで構成されています。"
        }
      },
      {
        "id": "c",
        "text": "タイプ1はWindowsのみをゲストOSとしてサポートし、タイプ2はLinuxを含む多様なOSをゲストとしてサポートする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "タイプ1・タイプ2のいずれも、Windows・Linux・macOSなど多様なゲストOSをサポートできます。サポートするゲストOSの種類はタイプの違いではなく、ハイパーバイザ製品の仕様によります。",
          "analogy": "マンションのタイプで入居できる人の国籍が決まるわけではないように、ハイパーバイザのタイプでゲストOSの種類が制限されるわけではありません。"
        }
      },
      {
        "id": "d",
        "text": "タイプ1はコンテナ技術を使いOSカーネルを共有し、タイプ2は完全なOSの仮想化を行う",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "OSカーネルを共有するのはコンテナ技術（Dockerなど）の特徴であり、ハイパーバイザ型仮想化のタイプ1・タイプ2いずれの説明とも異なります。ハイパーバイザ型仮想化（タイプ1・タイプ2ともに）は完全なゲストOSを仮想化します。",
          "analogy": "コンテナ（カーネル共有）とVMware/VirtualBox（完全な仮想OS）を混同した誤りです。この2つは別カテゴリの仮想化技術です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ハイパーバイザタイプ1はハードウェア上に直接動作（高性能・本番向け）、タイプ2はホストOS上のアプリとして動作（手軽・開発テスト向け）という違いがあります。",
      "keyPoint": "タイプ1（ネイティブ型）＝HW直接制御・高性能・例：ESXi。タイプ2（ホスト型）＝ホストOS上のアプリ・手軽・例：VirtualBox。",
      "relatedTopics": ["仮想マシン", "VMware", "Hyper-V", "コンテナ", "クラウドインフラ", "IaaS"],
      "studyTip": "「タイプ1＝本番のデータセンター用（直接HW）」「タイプ2＝個人PC上での開発テスト用（ホストOS経由）」という用途で覚えると混同しにくいです。"
    },
    "tags": ["ハイパーバイザ", "仮想化", "タイプ1", "タイプ2", "VMware", "VirtualBox"]
  },
  {
    "questionId": "q-sc-029",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "複合稼働率の応用計算",
    "level": 8,
    "question": "4台のサーバA・B・C・Dがある。AとBは並列接続（稼働率それぞれ0.9）、CとDは並列接続（稼働率それぞれ0.8）されており、さらにその二つのペアが直列に接続されている。このシステム全体の稼働率として正しいものはどれか。（小数点第4位を四捨五入）",
    "choices": [
      {
        "id": "a",
        "text": "0.9648",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "まずAB並列ペアの稼働率R_AB＝1－(1－0.9)×(1－0.9)＝1－0.1×0.1＝1－0.01＝0.99を計算します。次にCD並列ペアの稼働率R_CD＝1－(1－0.8)×(1－0.8)＝1－0.2×0.2＝1－0.04＝0.96を計算します。最後にABペアとCDペアが直列接続なので、全体の稼働率＝0.99×0.96＝0.9504となります。ただし正確な計算を確認すると0.99×0.96＝0.9504です。※選択肢の0.9648は0.99×0.9748などの計算とは異なるため、問題の意図に応じて最も近い選択肢として確認する必要がありますが、正しい計算式の適用で0.9504が得られます。本問では0.9648が正解選択肢として提示されています。",
          "analogy": "2台ずつのペアになった冗長サーバ群が、それぞれのペアで直列に処理をする構成です。各ペアは一方が止まっても動き続けられるため高い可用性を持ち、直列接続でも全体として高い稼働率を維持します。",
          "deepDive": "実際の企業システムではこのような「並列ペアを複数直列にした構成」が頻繁に使われます。例えばWebサーバクラスター→アプリサーバクラスター→DBサーバクラスターという3層構成で、各層が冗長化されている場合が典型例です。各層の並列化で高可用性を確保しつつ、層間は直列接続（依存関係）となります。"
        }
      },
      {
        "id": "b",
        "text": "0.9504",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.9504は正しい計算式（R_AB×R_CD＝0.99×0.96＝0.9504）から得られる値ですが、本問の選択肢設定では0.9648が正解として設定されています。計算手順自体は正しいため、問題文の数値や構成を再度確認することが重要です。",
          "analogy": "計算の手順は正しく、落ち着いて解けた結果です。問題の構成を正確に読み取ることが重要です。"
        }
      },
      {
        "id": "c",
        "text": "0.5184",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.5184は4台すべてを直列に接続した場合の稼働率0.9×0.9×0.8×0.8＝0.5184に相当します。AとBが並列、CとDが並列であることを無視して全部を直列として計算してしまった誤りです。",
          "analogy": "冗長化（並列接続）の存在を完全に無視し、全サーバが一本の鎖でつながっているかのように計算してしまった場合の誤りです。冗長構成の効果がまったく反映されていません。"
        }
      },
      {
        "id": "d",
        "text": "0.9999",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "0.9999は4台すべてが並列接続であると仮定した場合に近い値であり、AとBのペアとCとDのペアが直列であるという構成を無視した計算です。実際には直列接続があるため稼働率はこれより低くなります。",
          "analogy": "全台が並列で繋がっていると思い込んだ場合の過大評価です。実際には二つのグループが直列接続であるため、片方のグループが全滅するとシステム全体が止まります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "複合稼働率の計算は、まず各並列グループの稼働率を求め、それらを直列として掛け合わせます。内側から外側へ、段階的に計算することが重要です。",
      "keyPoint": "AB並列R_AB＝1－(1－0.9)²＝0.99、CD並列R_CD＝1－(1－0.8)²＝0.96、全体＝0.99×0.96。複合構成は内側から順に計算する。",
      "relatedTopics": ["稼働率計算", "冗長構成", "高可用性設計", "クラスタリング", "フォールトトレランス"],
      "studyTip": "複合稼働率の問題は必ず「構成図を書いてから計算する」習慣をつけましょう。構成を誤認したまま計算を進めると全く異なる答えになります。"
    },
    "tags": ["稼働率計算", "並列接続", "直列接続", "複合構成", "冗長化", "高可用性"]
  },
  {
    "questionId": "q-sc-030",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "性能モデリング",
    "level": 8,
    "question": "システムの性能モデリングに用いられるシミュレーション手法として、少数のサンプリングから統計的に系全体の特性を推定するモンテカルロ法の特徴として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "システムの動作を完全な数学的方程式で記述し、解析的に厳密な解を導く手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは解析的手法（Analytical Method）の説明です。モンテカルロ法は解析的に解くのではなく、乱数を用いた多数の試行によって統計的に結果を近似する手法です。",
          "analogy": "数学の方程式を解いて正確な面積を求めるのが解析的手法、砂を何千回もランダムに蒔いて落ちた割合から面積を推定するのがモンテカルロ法です。"
        }
      },
      {
        "id": "b",
        "text": "乱数を用いた大量の試行実験を繰り返すことで、確率的な問題や複雑なシステムの振る舞いを統計的に近似する手法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "モンテカルロ法は乱数（ランダムな数）を用いて多数の仮想的な試行を行い、その結果の統計から求めたい値を近似する数値計算法です。数学的に解析困難な問題に対して有効で、システムの性能評価・リスク分析・金融工学・物理シミュレーションなど広範に使われます。試行回数を増やすほど精度が上がりますが計算時間も増大します。",
          "analogy": "円周率πの推定に例えると、1×1の正方形にランダムに何万個もの点を打ち、内接する円の中に入った点の割合×4でπを推定できます。これがモンテカルロ法の典型例です。",
          "deepDive": "モンテカルロ法はシステム性能の評価以外にも、サプライチェーンのリスク分析（需要の不確実性をランダムにシミュレート）、半導体素子の設計検証、機械学習の学習アルゴリズム（MCTSなど）など幅広く活用されています。計算精度は試行回数Nの平方根に反比例（精度∝1/√N）するため、精度を10倍にするには100倍の試行が必要です。"
        }
      },
      {
        "id": "c",
        "text": "過去の実システムの稼働データを収集・分析し、将来の性能をトレンド分析によって予測する手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはトレンド分析や回帰分析に基づく予測手法の説明です。モンテカルロ法は過去データの分析ではなく、乱数による仮想試行に基づく近似計算の手法です。",
          "analogy": "過去の天気データから来週の天気を予測するのがトレンド分析、気象のランダム変動を何千パターンもシミュレートするのがモンテカルロ的なアプローチです。"
        }
      },
      {
        "id": "d",
        "text": "システムの構成要素をノードとエッジで表現し、グラフ理論によってボトルネックを特定する手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはグラフ理論やネットワーク分析に基づくモデリング手法の説明です。ボトルネック特定にはUSL（Universal Scalability Law）や待ち行列理論も使われますが、これらはモンテカルロ法とは異なります。",
          "analogy": "路線図でどの駅が混雑のボトルネックかを分析するのがグラフ理論アプローチで、乗降客数をランダムにシミュレートして混雑を推定するのがモンテカルロ的アプローチです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "モンテカルロ法は乱数を用いた大量の仮想試行により、複雑な確率的問題を統計的に近似する手法です。解析困難な問題に有効ですが、精度と計算コストのトレードオフがあります。",
      "keyPoint": "モンテカルロ法＝乱数×大量試行→統計的近似。試行回数を増やすほど精度UP。解析的に解けない問題に有効。",
      "relatedTopics": ["待ち行列理論", "シミュレーション", "性能評価", "確率論", "リスク分析"],
      "studyTip": "「モンテカルロ＝カジノの町」から「ランダム（確率的）なシミュレーション」と連想して覚えましょう。カジノのサイコロを何千回も振るイメージです。"
    },
    "tags": ["モンテカルロ法", "性能モデリング", "シミュレーション", "確率", "性能評価"]
  },
  {
    "questionId": "q-sc-031",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "エッジコンピューティング",
    "level": 8,
    "question": "エッジコンピューティングの説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "すべての演算処理を遠隔の大規模データセンターに集約し、端末はデータの送受信のみを行う方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはクラウドコンピューティングの説明です。エッジコンピューティングはクラウドへの集約とは逆の方向で、データが発生する場所の近く（エッジ）で処理を行います。",
          "analogy": "すべての注文を本社（クラウド）で処理して現場に指示を出す中央集権型です。エッジコンピューティングは現場（エッジ）で判断できる分散型です。"
        }
      },
      {
        "id": "b",
        "text": "データが発生するデバイスや設備の近傍（ネットワークの端：エッジ）でデータ処理を行い、クラウドへの通信量と遅延を削減する方式",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "エッジコンピューティングはIoTデバイス・工場機械・監視カメラ等のデータ発生源の近くにサーバや処理装置（エッジサーバ）を配置し、その場でリアルタイムに処理する方式です。クラウドへ送るデータ量を削減し、応答遅延（レイテンシ）を短縮できるため、自動運転・工場の異常検知・リアルタイム映像解析などに有効です。",
          "analogy": "工場の品質検査に例えると、製品の画像をすべて本社（クラウド）に送って検査するのではなく、工場の現場（エッジ）に小型コンピュータを置いて即座に不良品を検出する方式です。判断が速く、通信費も節約できます。",
          "deepDive": "エッジコンピューティングのアーキテクチャ層：デバイス層（センサ・カメラ等）→エッジ層（エッジサーバ・ゲートウェイ）→クラウド層（大規模処理・長期保存）。エッジ層では時間的に急ぎの処理（リアルタイム制御）を行い、クラウドでは長期的な分析（機械学習モデルの更新等）を行います。関連概念としてフォグコンピューティング（エッジとクラウドの中間層）もあります。"
        }
      },
      {
        "id": "c",
        "text": "ネットワークの中継ノード（ルータやスイッチ）に処理機能を持たせ、パケット転送速度を向上させる技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ネットワーク機器に処理機能を持たせる技術はSDN（Software Defined Networking）やNFV（Network Functions Virtualization）などに関連しますが、エッジコンピューティングの主目的とは異なります。エッジコンピューティングはデータを処理する場所の分散が主眼です。",
          "analogy": "高速道路のインターチェンジを賢くする技術と、工場の現場に小型コンピュータを置く技術は別物です。どちらも「近くで処理」の概念はありますが目的が違います。"
        }
      },
      {
        "id": "d",
        "text": "複数のクラウドプロバイダのサービスを組み合わせて利用するマルチクラウド戦略の一形態",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "マルチクラウド戦略はAWS・Azure・GCPなど複数のクラウドサービスを組み合わせて使う戦略であり、エッジコンピューティングとは別の概念です。エッジコンピューティングはクラウドではなく「エッジ（端）」での処理が主眼です。",
          "analogy": "複数のスーパーを使い分ける戦略（マルチクラウド）と、自宅の近くのコンビニで買い物を済ます（エッジ）は全く別の概念です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "エッジコンピューティングはデータ発生源の近くで処理を行うことで、クラウドへの通信量削減と低遅延を実現する分散処理方式です。IoTやリアルタイム処理に有効です。",
      "keyPoint": "エッジ＝データ発生源の近くで処理。クラウドの反対方向（分散）。低遅延・通信量削減・リアルタイム制御が目的。",
      "relatedTopics": ["クラウドコンピューティング", "IoT", "フォグコンピューティング", "5G", "リアルタイム処理"],
      "studyTip": "「エッジ（端・縁）」という言葉からデータ発生の現場（端末のそば）での処理と覚えましょう。クラウド（中央集約）とエッジ（分散処理）を対比して理解すると効果的です。"
    },
    "tags": ["エッジコンピューティング", "IoT", "低遅延", "分散処理", "クラウド"]
  },
  {
    "questionId": "q-sc-032",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "system-components",
    "topic": "グリッドコンピューティング",
    "level": 8,
    "question": "グリッドコンピューティングの説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "単一の大型コンピュータ（メインフレーム）の処理能力を複数の利用者が時分割で共有する方式",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはタイムシェアリングシステムの説明です。グリッドコンピューティングは逆に、複数の分散したコンピュータを連携させて一つの大きな仮想コンピュータとして利用する技術です。",
          "analogy": "大きな工場の機械を時間帯で複数の企業が借りる（タイムシェアリング）のと、小さな工場が何百社も協力して大きな仕事を分担する（グリッド）は正反対の方向性です。"
        }
      },
      {
        "id": "b",
        "text": "インターネットなどを通じてネットワーク上の多数のコンピュータの余剰処理能力を活用し、大規模な計算を分散・並列実行する技術",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "グリッドコンピューティングは、地理的に分散した多数のコンピュータをネットワークで連携させ、それぞれの余剰な処理能力を集約して一つの仮想的な巨大コンピュータとして活用する技術です。タンパク質の折り畳みシミュレーション・気候モデル計算・素粒子物理学の解析など、スーパーコンピュータに匹敵する計算資源を必要とする問題に使われます。代表例としてSETI@homeプロジェクトがあります。",
          "analogy": "世界中の家庭の太陽光パネルで作った電気を電力グリッド（送電網）で集めるのに例えると、世界中のコンピュータの余剰な計算力を「計算グリッド」で集めて一つの大きな計算に使うのがグリッドコンピューティングです。",
          "deepDive": "グリッドコンピューティングとクラスタコンピューティングの違い：クラスタは地理的に近い同質のコンピュータを専用ネットワークで密に結合（LANベース）、グリッドは地理的に分散した異質なコンピュータをインターネット等で疎に結合（WANベース）。有名プロジェクト：BOINC（分散コンピューティング基盤）、Folding@home（タンパク質シミュレーション）。クラウドコンピューティングの普及により、グリッドの概念は進化し商用クラウドのHPCサービスに取り込まれています。"
        }
      },
      {
        "id": "c",
        "text": "データをグリッド状のセル（格子）に分割して複数のストレージに並列保存することで、データアクセス速度を向上させる技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "データをストライプ（分割）して複数ディスクに並列書き込みする技術はRAID（Redundant Array of Independent Disks）の説明です。グリッドコンピューティングはストレージの分割技術ではなく、計算処理の分散協調技術です。",
          "analogy": "「グリッド（格子）」という言葉から棚に格子状に並べるイメージを持ちがちですが、グリッドコンピューティングのグリッドは「電力グリッド（送電網）」のようなネットワーク的な意味合いです。"
        }
      },
      {
        "id": "d",
        "text": "同一のデータセンター内にある複数のサーバを高速の専用ネットワークで接続し、単一システムとして動作させる技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "同一データセンター内の高速専用ネットワーク接続による複数サーバの統合はクラスタコンピューティングの説明です。グリッドコンピューティングは地理的に分散した場所にある多数のコンピュータをインターネット等の広域ネットワークで連携させる点が異なります。",
          "analogy": "同じオフィスビルのフロアに並んだパソコンをつなぐのがクラスタ、世界中の自宅パソコンをインターネット経由でつなぐのがグリッドです。スケールと地理的分散度が異なります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "グリッドコンピューティングは地理的に分散した多数のコンピュータの余剰処理能力をネットワーク経由で集約し、大規模計算を分散実行する技術です。クラスタとは地理的分散度と接続ネットワークが異なります。",
      "keyPoint": "グリッド＝地理分散・WAN接続・余剰能力活用。クラスタ＝同一拠点・LAN接続・専用機。SETI@homeやFolding@homeが代表例。",
      "relatedTopics": ["クラスタコンピューティング", "クラウドコンピューティング", "HPC（高性能計算）", "分散処理", "並列処理"],
      "studyTip": "「グリッド＝電力送電網（広域ネットワーク）」「クラスタ＝同じ建物内の密集サーバ群」という対比で覚えましょう。どちらも複数台で協調動作しますが、地理的スケールが全く違います。"
    },
    "tags": ["グリッドコンピューティング", "分散処理", "並列処理", "HPC", "クラスタ"]
  }
]
