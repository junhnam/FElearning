[
  {
    "questionId": "q-ap-001",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "アルゴリズムの基本概念",
    "level": 1,
    "question": "アルゴリズムの説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "プログラムを動作させるために必要なハードウェアの仕様",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはハードウェア要件の説明です。アルゴリズムはハードウェアとは無関係に、問題を解くための手順そのものを指します。",
          "analogy": "料理のレシピは鍋の種類（ハードウェア）の話ではなく、作り方の手順の話です。"
        }
      },
      {
        "id": "b",
        "text": "問題を解くための有限の手順の集まり",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "アルゴリズムとは、ある問題を解くために必要な処理手順を有限個の明確なステップで記述したものです。「有限」であること（いつか終わること）と「明確」であること（曖昧さがないこと）が重要な性質です。",
          "analogy": "料理のレシピがアルゴリズムに相当します。「①玉ねぎを切る②炒める③塩を加える」という有限の手順があり、誰がやっても同じ料理ができます。",
          "deepDive": "アルゴリズムには4つの重要な性質があります。①入力（0個以上の入力がある）②出力（1個以上の出力がある）③明確性（各ステップが曖昧でない）④有限性（有限ステップで終了する）です。"
        }
      },
      {
        "id": "c",
        "text": "コンピュータが理解できる機械語の命令列",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "機械語の命令列はプログラムの説明です。アルゴリズムは特定の言語や機械語に依存しない抽象的な手順です。",
          "analogy": "レシピ（アルゴリズム）は日本語でも英語でも表せますが、機械語は特定の言語（コンピュータ語）に固定されたものです。"
        }
      },
      {
        "id": "d",
        "text": "プログラムのバグを見つけて修正する作業",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "バグを見つけて修正する作業はデバッグと呼ばれます。アルゴリズムはデバッグとは別の概念です。",
          "analogy": "レシピ（アルゴリズム）を考えることと、料理の失敗原因を探すこと（デバッグ）は別の作業です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "アルゴリズムとは問題を解くための有限の明確な手順の集まりです。特定のプログラム言語やハードウェアに依存しない抽象的な概念です。",
      "keyPoint": "アルゴリズム = 問題を解く有限の手順。有限性・明確性が重要。",
      "relatedTopics": ["フローチャート", "計算量", "プログラム"],
      "studyTip": "アルゴリズムを「料理のレシピ」と覚えると、有限・明確・手順という性質がイメージしやすくなります。"
    },
    "tags": ["アルゴリズム基礎", "定義", "有限性"]
  },
  {
    "questionId": "q-ap-002",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "フローチャート",
    "level": 1,
    "question": "フローチャートで「判断」を表すために使用する図形はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "長方形（矩形）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "長方形は「処理」を表す記号です。計算や代入などの処理ステップに使用します。",
          "analogy": "長方形は「作業する箱」のイメージです。「玉ねぎを切る」のような処理を表します。"
        }
      },
      {
        "id": "b",
        "text": "ひし形（菱形）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "フローチャートでひし形（菱形）は「判断」を表します。条件分岐（Yes/Noや真/偽）の分岐点として使い、複数の出口を持ちます。",
          "analogy": "ひし形は「交差点の標識」のイメージです。「右に曲がる？Yes→右、No→直進」のように、条件によって道が分かれます。",
          "deepDive": "フローチャートの主な記号：長方形（処理）、ひし形（判断）、角丸長方形（端子：開始・終了）、平行四辺形（入出力）、矢印（流れ線）。JIS規格で標準化されています。"
        }
      },
      {
        "id": "c",
        "text": "角丸長方形（スタジアム形）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "角丸長方形は「端子」を表す記号で、フローチャートの開始点や終了点に使います。",
          "analogy": "角丸長方形は「旅の始まりと終わり」のイメージです。出発地と目的地を示します。"
        }
      },
      {
        "id": "d",
        "text": "平行四辺形",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "平行四辺形は「入出力」を表す記号で、データの入力や出力の操作を示します。",
          "analogy": "平行四辺形は「受付窓口」のイメージです。情報を受け取ったり、渡したりする場所です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "フローチャートでは図形ごとに意味が決まっており、判断（条件分岐）はひし形で表します。",
      "keyPoint": "ひし形＝判断、長方形＝処理、角丸長方形＝端子（開始・終了）、平行四辺形＝入出力",
      "relatedTopics": ["アルゴリズム", "条件分岐", "構造化プログラミング"],
      "studyTip": "4種類の記号とその意味をセットで覚えましょう。試験では「この記号は何を表すか」という形でよく出題されます。"
    },
    "tags": ["フローチャート", "記号", "判断", "条件分岐"]
  },
  {
    "questionId": "q-ap-003",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "配列",
    "level": 1,
    "question": "配列に関する説明として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "要素の追加・削除が配列の先頭からしかできないデータ構造である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "先頭からしか追加・削除できないのはスタック（後入れ先出し）の特徴ではなく、キューに近い説明ですが、配列の説明としては誤りです。配列は任意の位置にインデックスでアクセスできます。",
          "analogy": "配列は番号付きの引き出しで、どの引き出しにも直接アクセスできます。先頭からしかアクセスできないわけではありません。"
        }
      },
      {
        "id": "b",
        "text": "同じ型のデータを連続したメモリ領域に格納し、インデックスでアクセスするデータ構造である",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "配列は同じデータ型の要素を連続したメモリ領域に並べて格納するデータ構造です。各要素には0から始まるインデックス（添え字）でアクセスでき、任意の要素への直接アクセスが高速（O(1)）です。",
          "analogy": "配列はマンションの部屋番号のようなものです。101号室・102号室と連番で並んでおり、部屋番号（インデックス）を指定すれば直接その部屋に入れます。",
          "deepDive": "配列の特性：①ランダムアクセスO(1)（インデックスで直接アクセス）②要素の挿入・削除はO(n)（後ろにずらす必要あり）③サイズが固定（多くの言語で）。対照的にリスト（連結リスト）は挿入・削除がO(1)ですがランダムアクセスがO(n)です。"
        }
      },
      {
        "id": "c",
        "text": "後から追加したデータを先に取り出すことができるデータ構造である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "後入れ先出し（LIFO）の特性を持つのはスタックです。配列はそのような制約はなく、任意の位置のデータにアクセスできます。",
          "analogy": "スタックは皿の積み重ねで、一番上（最後に置いた）皿から取ります。配列はどの皿にも直接手が届くイメージです。"
        }
      },
      {
        "id": "d",
        "text": "異なるデータ型の要素を1つにまとめて扱えるデータ構造である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "異なるデータ型をまとめるのは構造体（struct）やオブジェクトの特徴です。一般的な配列は同じデータ型の要素を格納します。",
          "analogy": "配列は同じ種類の商品を並べる棚です。異なる種類の商品をまとめるのは、仕切りのある収納箱（構造体）の役割です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "配列は同じ型のデータを連続したメモリ領域に格納し、インデックスで高速にアクセスできるデータ構造です。",
      "keyPoint": "配列の特徴：同型データ・連続メモリ・インデックスアクセスO(1)・挿入削除O(n)",
      "relatedTopics": ["リスト", "スタック", "キュー", "データ構造"],
      "studyTip": "配列とリストの違い（アクセス速度と挿入・削除速度のトレードオフ）はよく出題されます。"
    },
    "tags": ["配列", "データ構造", "インデックス", "ランダムアクセス"]
  },
  {
    "questionId": "q-ap-004",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "スタック",
    "level": 1,
    "question": "スタック（stack）の説明として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "先に入れたデータを先に取り出す（FIFO）構造である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "先入れ先出し（FIFO：First In First Out）はキューの特性です。スタックはその逆のLIFO（後入れ先出し）です。",
          "analogy": "FIFOは行列（並んでいる順に入場できる）のイメージです。スタックはそうではありません。"
        }
      },
      {
        "id": "b",
        "text": "後に入れたデータを先に取り出す（LIFO）構造である",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "スタックはLIFO（Last In First Out：後入れ先出し）の性質を持つデータ構造です。データを積み重ねるイメージで、追加（push）は上に積み、取り出し（pop）も上から行います。",
          "analogy": "食器洗いで洗ったお皿を積み重ねる場合、最後に積んだ（上の）皿から取り出すのがスタックです。関数の呼び出しやブラウザの「戻る」ボタンはスタックで管理されています。",
          "deepDive": "スタックの主な操作：push（データを積む）、pop（先頭から取り出す）、peek/top（先頭を確認するだけで取り出さない）、isEmpty（空かどうか確認）。スタックはプログラムの関数呼び出し管理（コールスタック）に使われています。"
        }
      },
      {
        "id": "c",
        "text": "任意の位置のデータに直接アクセスできる構造である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "任意の位置に直接アクセスできるのは配列の特性です。スタックはLIFOの制約があり、先頭（top）からしかアクセスできません。",
          "analogy": "スタックは積み重なった箱で、一番上の箱しか取れません。どの箱にも直接アクセスできる配列とは異なります。"
        }
      },
      {
        "id": "d",
        "text": "データを木構造で管理する構造である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "木構造で管理するのはツリー（木）構造です。スタックは線形なデータ構造です。",
          "analogy": "木構造は家系図のように枝分かれしますが、スタックは一本の積み重ねです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "スタックはLIFO（後入れ先出し）のデータ構造です。push（追加）とpop（取り出し）の操作で管理します。",
      "keyPoint": "スタック＝LIFO（後入れ先出し）。関数呼び出しやブラウザの履歴管理に使用される。",
      "relatedTopics": ["キュー", "配列", "再帰", "コールスタック"],
      "studyTip": "スタック（LIFO）とキュー（FIFO）の違いを日常の例（皿の積み重ね vs. 行列）でセットで覚えましょう。"
    },
    "tags": ["スタック", "LIFO", "データ構造", "push", "pop"]
  },
  {
    "questionId": "q-ap-005",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "キュー",
    "level": 1,
    "question": "キュー（queue）の説明として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "後に入れたデータを先に取り出す（LIFO）構造である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "後入れ先出し（LIFO）はスタックの特性です。キューはFIFO（先入れ先出し）です。",
          "analogy": "LIFOは皿の積み重ねで最後に置いた皿から取りますが、キューはそうではありません。"
        }
      },
      {
        "id": "b",
        "text": "先に入れたデータを先に取り出す（FIFO）構造である",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "キューはFIFO（First In First Out：先入れ先出し）の性質を持つデータ構造です。データを後ろに追加し（enqueue）、前から取り出す（dequeue）操作を行います。",
          "analogy": "スーパーのレジ待ち列（行列）がキューそのものです。先に並んだ人が先に会計できます。プリンタの印刷待ちキューも同じ仕組みです。",
          "deepDive": "キューの主な操作：enqueue（末尾にデータを追加）、dequeue（先頭からデータを取り出す）、peek/front（先頭を確認するだけ）。OSのプロセススケジューリングやネットワークのパケット管理に広く使われています。"
        }
      },
      {
        "id": "c",
        "text": "データを二分木として管理する構造である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "データを二分木として管理するのは二分木（バイナリツリー）です。キューは線形なデータ構造です。",
          "analogy": "二分木は家系図のように枝分かれしますが、キューはまっすぐな1列の行列です。"
        }
      },
      {
        "id": "d",
        "text": "任意の位置のデータを直接削除できる構造である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "キューは先頭からしかデータを取り出せません。任意の位置からの削除はキューの特性ではありません。",
          "analogy": "行列の途中の人を割り込ませて先に出すのはキューのルール違反です。必ず先頭から順番に処理します。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "キューはFIFO（先入れ先出し）のデータ構造です。enqueue（追加）とdequeue（取り出し）の操作で管理します。",
      "keyPoint": "キュー＝FIFO（先入れ先出し）。プリンタ待ちや行列の管理に使用される。",
      "relatedTopics": ["スタック", "配列", "リスト", "プロセス管理"],
      "studyTip": "「queue（キュー）」は英語で「行列・順番待ち」という意味です。スーパーの行列をイメージして覚えましょう。"
    },
    "tags": ["キュー", "FIFO", "データ構造", "enqueue", "dequeue"]
  },
  {
    "questionId": "q-ap-006",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "線形探索",
    "level": 1,
    "question": "線形探索（逐次探索）の説明として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "データが昇順または降順に並んでいることを前提として、中央の値と比較しながら探索する方法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "中央の値と比較しながら探索するのは二分探索（バイナリサーチ）です。二分探索はデータが整列済みであることが前提です。",
          "analogy": "辞書で単語を探すとき、真ん中から始めてページを絞り込むのが二分探索です。線形探索とは異なります。"
        }
      },
      {
        "id": "b",
        "text": "先頭から順番に1つずつ目的のデータと比較しながら探索する方法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "線形探索は先頭から順番にデータを1つずつ確認し、目的のデータと一致するまで探し続ける最もシンプルな探索アルゴリズムです。データが整列されていなくても使えますが、最悪の場合は全データを確認するためO(n)の計算量になります。",
          "analogy": "落とし物を探すとき、部屋の端から端まで順番に隅々を確認するのが線形探索です。見つかれば即座に終了し、見つからなければ全部確認します。",
          "deepDive": "線形探索の計算量：最良O(1)（先頭にある場合）、平均O(n/2)、最悪O(n)（末尾にある場合）。データが整列されていない場合や小規模なデータには適していますが、大規模データには二分探索の方が効率的です。"
        }
      },
      {
        "id": "c",
        "text": "木構造を使ってデータを管理し、効率よく探索する方法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "木構造を使った探索は二分探索木（BST）などの探索です。線形探索は木構造とは無関係で、単純な順番探索です。",
          "analogy": "木の枝を分かれながら探すのが木構造探索で、1本道を順番に歩いて探すのが線形探索です。"
        }
      },
      {
        "id": "d",
        "text": "ハッシュ関数を使ってデータの格納位置を計算し、直接アクセスする方法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ハッシュ関数を使ってデータの位置を計算するのはハッシュ探索（ハッシュテーブル）です。線形探索とは全く異なる方法です。",
          "analogy": "住所から地図で位置を直接特定するのがハッシュ探索で、家を1軒ずつ訪問して探すのが線形探索です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "線形探索は先頭から順番に1つずつ比較する最もシンプルな探索方法です。整列不要ですが効率はO(n)です。",
      "keyPoint": "線形探索＝先頭から順番に探索・整列不要・計算量O(n)",
      "relatedTopics": ["二分探索", "ハッシュ探索", "計算量"],
      "studyTip": "線形探索と二分探索の違い（整列が必要か・計算量）を比較して覚えましょう。"
    },
    "tags": ["線形探索", "探索アルゴリズム", "O(n)", "逐次探索"]
  },
  {
    "questionId": "q-ap-007",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "バブルソート",
    "level": 2,
    "question": "バブルソートの説明として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "未整列部分から最小値を選んで先頭に移動する操作を繰り返すソート",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "未整列部分から最小値（または最大値）を選んで整列済み部分の末尾に移動するのは選択ソートです。",
          "analogy": "全体を見渡して一番小さいものを選ぶのが選択ソートです。バブルソートとは仕組みが異なります。"
        }
      },
      {
        "id": "b",
        "text": "隣接する要素を比較し、順序が逆なら交換する操作を繰り返すソート",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "バブルソートは隣接する2つの要素を比較し、順序が正しくなければ交換する操作をリストの先頭から末尾まで繰り返すソートアルゴリズムです。大きな値が泡のように末尾に浮かび上がるイメージからバブルソートと呼ばれます。",
          "analogy": "子供たちが身長順に並ぶとき、隣の子と背の高さを比べて「大きい方が右」になるよう順番に入れ替えていくイメージです。最も大きい子が右端に泡のように浮かび上がります。",
          "deepDive": "バブルソートの計算量：最良O(n)（既に整列済みで交換不要の場合）、平均・最悪O(n²)。実装は単純ですが効率は低く、実用的にはクイックソートやマージソートが使われます。ただし安定ソート（同じ値の要素の順序が保たれる）という性質があります。"
        }
      },
      {
        "id": "c",
        "text": "整列済みの部分に新しい要素を適切な位置に挿入する操作を繰り返すソート",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "整列済み部分に新しい要素を挿入するのは挿入ソートです。バブルソートとは異なるアルゴリズムです。",
          "analogy": "手持ちのトランプを小さい順に並べるとき、1枚ずつ正しい位置に差し込むのが挿入ソートです。"
        }
      },
      {
        "id": "d",
        "text": "基準値（ピボット）を選び、それより小さい値と大きい値に分けて再帰的にソートする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ピボットを使った分割統治法のソートはクイックソートです。バブルソートとは全く異なるアルゴリズムです。",
          "analogy": "グループを二手に分けて整理するのがクイックソートで、隣同士を比べながら整理するのがバブルソートです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "バブルソートは隣接する要素を比較・交換する単純なソートです。大きな値が末尾に「浮かび上がる」イメージです。",
      "keyPoint": "バブルソート＝隣接比較・交換・計算量O(n²)・安定ソート",
      "relatedTopics": ["選択ソート", "挿入ソート", "クイックソート", "計算量"],
      "studyTip": "バブルソート・選択ソート・挿入ソートの3つの違いを整理して覚えましょう。全てO(n²)ですが仕組みが異なります。"
    },
    "tags": ["バブルソート", "ソートアルゴリズム", "O(n²)", "安定ソート"]
  },
  {
    "questionId": "q-ap-008",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "選択ソート",
    "level": 2,
    "question": "10個の数値を選択ソートで昇順に整列するとき、比較回数の合計として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "10回",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "10回は要素数と同じですが、選択ソートでは各パスで未整列部分の最小値を探すために複数回の比較が必要です。",
          "analogy": "10人の中から一番背が低い人を探すだけで9回の比較が必要です。それを繰り返すので10回では足りません。"
        }
      },
      {
        "id": "b",
        "text": "45回",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "選択ソートでn個の要素を整列するとき、比較回数は(n-1)+(n-2)+…+1 = n(n-1)/2 回です。n=10の場合、10×9÷2 = 45回になります。1パス目で9回、2パス目で8回…最終パスで1回の比較を行います。",
          "analogy": "10人の中で一番背が低い人を選ぶ（9回比較）、次に残り9人の中から（8回比較）…と繰り返すと、9+8+7+6+5+4+3+2+1=45回の比較が行われます。",
          "deepDive": "選択ソートの比較回数：n(n-1)/2。これは計算量O(n²)に対応します。ただし選択ソートの交換回数は最大O(n)で、バブルソートより交換回数が少ないという特徴があります。ただし選択ソートは不安定ソートです。"
        }
      },
      {
        "id": "c",
        "text": "100回",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "100回はn²=10²ですが、実際の比較回数はn(n-1)/2=45回です。O(n²)の計算量ですが係数として1/2があります。",
          "analogy": "部屋の全ての組み合わせでペアを作るのと（C(10,2)=45通り）、全員で全員と比較するの（100回）は異なります。"
        }
      },
      {
        "id": "d",
        "text": "90回",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "90回はn×(n-1)=10×9=90ですが、実際の比較回数はその半分のn(n-1)/2=45回です。",
          "analogy": "10人の全ての2人組の組み合わせは45通りです（握手の回数と同じ）。90回は全ての組み合わせを2回ずつ数えた計算です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "選択ソートのn要素の比較回数はn(n-1)/2回です。n=10の場合は45回です。",
      "keyPoint": "選択ソートの比較回数 = n(n-1)/2。n=10なら45回。",
      "relatedTopics": ["バブルソート", "挿入ソート", "計算量", "O(n²)"],
      "studyTip": "n(n-1)/2の公式は等差数列の和の公式です。1+2+3+…+(n-1)=n(n-1)/2と覚えましょう。"
    },
    "tags": ["選択ソート", "ソートアルゴリズム", "比較回数", "計算量"]
  },
  {
    "questionId": "q-ap-009",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "二分探索",
    "level": 2,
    "question": "二分探索の前提条件として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "データがランダムに並んでいること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "二分探索はデータが整列（昇順または降順）されていることが必須条件です。ランダムな並びでは二分探索を適用できません。",
          "analogy": "辞書は五十音順に並んでいるから「な行」を開いて範囲を絞れます。バラバラに並んでいたら最初から探すしかありません。"
        }
      },
      {
        "id": "b",
        "text": "データが昇順または降順に整列されていること",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "二分探索は「データが整列済みである」ことが前提条件です。中央の値を参照して「探索対象が中央より大きいか小さいか」を判断することで、毎回探索範囲を半分に絞ることができます。整列されていないと大小比較による絞り込みができません。",
          "analogy": "辞書で単語を探すとき、五十音順に並んでいるから真ん中のページを開いて「目的の言葉はここより前か後か」と判断できます。バラバラに並んでいたら最初から1ページずつ探すしかありません（線形探索）。",
          "deepDive": "二分探索の計算量はO(log n)です。n=1024の場合、最大10回（log₂1024=10）の比較で見つかります。線形探索の最悪O(n)=1024回と比べると劇的に効率的です。ただし整列コスト（O(n log n)）を考慮する必要があります。"
        }
      },
      {
        "id": "c",
        "text": "データが連結リストに格納されていること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "二分探索は中央の要素に直接アクセスする必要があるため、連結リストには適していません。配列のようにランダムアクセスできるデータ構造が必要です。",
          "analogy": "本の真ん中のページを直接開けるのは本が「ページ番号でアクセスできる」からです。連結リストは先頭から順番にたどるしかないため、真ん中に直接ジャンプできません。"
        }
      },
      {
        "id": "d",
        "text": "データが重複していないこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "データに重複があっても二分探索は適用できます（実装が少し複雑になりますが）。前提条件は重複の有無ではなく、データが整列されていることです。",
          "analogy": "辞書に同じスペルの単語が複数の意味で載っていても（重複あり）、五十音順（整列）に並んでいれば目的の単語を探せます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "二分探索の前提条件は「データが整列済み」であることです。整列済みデータに対してO(log n)で探索できます。",
      "keyPoint": "二分探索の前提：データが整列済み。計算量O(log n)で効率的。",
      "relatedTopics": ["線形探索", "整列アルゴリズム", "計算量"],
      "studyTip": "二分探索を辞書の使い方にたとえると覚えやすいです。「整列が前提」と「毎回半分に絞る」をセットで覚えましょう。"
    },
    "tags": ["二分探索", "探索アルゴリズム", "O(log n)", "前提条件"]
  },
  {
    "questionId": "q-ap-010",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "コンパイラとインタプリタ",
    "level": 2,
    "question": "インタプリタの説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ソースコード全体を一括して機械語に変換してから実行する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ソースコード全体を一括して機械語に変換してから実行するのはコンパイラの動作です。インタプリタとは逆の方式です。",
          "analogy": "コンパイラは本全体を事前に翻訳してから読むのに対し、インタプリタは1文ずつ読みながらその場で翻訳します。"
        }
      },
      {
        "id": "b",
        "text": "ソースコードを1行（または1文）ずつ解釈しながら実行する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "インタプリタはソースコードを1行（または1文）ずつ読み込み、その場で解釈（翻訳）して即座に実行します。コンパイラのように事前に全体を変換しないため、実行前の準備時間はありませんが、実行速度はコンパイラ方式より遅くなりがちです。",
          "analogy": "インタプリタは同時通訳者のようなものです。外国語の演説を聞きながら、その場でリアルタイムに翻訳します。コンパイラは事前に全文を翻訳した台本を用意してから読むイメージです。",
          "deepDive": "インタプリタの特徴：①実行速度がコンパイラより遅い（毎回解釈が必要）②ソースコードを直接実行できる③デバッグしやすい④プラットフォームに依存しにくい。Python・Ruby・JavaScriptはインタプリタ型の代表例。Javaは中間言語（バイトコード）を使うハイブリッド型です。"
        }
      },
      {
        "id": "c",
        "text": "機械語を高水準言語に変換するプログラムである",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "機械語を高水準言語に変換するのはデコンパイラ（逆コンパイラ）です。コンパイラもインタプリタも高水準言語を低水準言語（機械語）に変換します。",
          "analogy": "日本語を英語に翻訳するのがコンパイラ・インタプリタで、英語から日本語に戻すのがデコンパイラです。"
        }
      },
      {
        "id": "d",
        "text": "プログラムのリンクを行い、実行可能なファイルを生成するプログラムである",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "複数のオブジェクトファイルを結合して実行可能ファイルを生成するのはリンカ（リンクエディタ）です。インタプリタとは別のプログラムです。",
          "analogy": "複数の部品を組み合わせて完成品を作るのがリンカで、その都度翻訳しながら動かすのがインタプリタです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "インタプリタはソースコードを1行ずつ解釈・実行します。コンパイラとの違いは「事前変換なし・都度解釈」です。",
      "keyPoint": "インタプリタ＝1行ずつ解釈・実行（同時通訳）。コンパイラ＝全体を事前変換（翻訳本）。",
      "relatedTopics": ["コンパイラ", "リンカ", "アセンブラ", "プログラミング言語"],
      "studyTip": "コンパイラとインタプリタの違いを「翻訳のタイミング（事前 vs. リアルタイム）」で覚えましょう。"
    },
    "tags": ["インタプリタ", "コンパイラ", "プログラミング言語", "実行方式"]
  },
  {
    "questionId": "q-ap-011",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "プログラミング言語の種類",
    "level": 2,
    "question": "オブジェクト指向プログラミング言語として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "COBOL",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "COBOLは1960年代に開発された手続き型プログラミング言語です。事務処理・金融系システムで使われてきましたが、オブジェクト指向言語ではありません（後にオブジェクト指向機能が一部追加されましたが、設計思想は手続き型）。",
          "analogy": "COBOLは昔ながらの手順書（手続き型）で、オブジェクト指向の概念を中心に設計された言語ではありません。"
        }
      },
      {
        "id": "b",
        "text": "Java",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "Javaはオブジェクト指向プログラミングを中心に設計された言語です。クラス・オブジェクト・継承・ポリモーフィズム・カプセル化というオブジェクト指向の4大概念を全てサポートしています。「Write Once, Run Anywhere」（一度書けばどこでも動く）を理念とし、JVM（Java仮想マシン）上で動作します。",
          "analogy": "Javaはレゴブロックのようなものです。「ブロック（クラス）」を組み合わせてシステムを構築し、ブロックを再利用（継承）することで効率よくプログラムを作れます。",
          "deepDive": "代表的なオブジェクト指向言語：Java、C++、C#、Python、Ruby、Swift、Kotlin。オブジェクト指向の4原則：カプセル化（データと操作をまとめる）、継承（性質を引き継ぐ）、ポリモーフィズム（同名の操作が異なる動作）、抽象化（不要な詳細を隠す）。"
        }
      },
      {
        "id": "c",
        "text": "FORTRAN",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "FORTRANは科学技術計算向けに開発された手続き型プログラミング言語です。数値計算が得意ですが、オブジェクト指向を主体とした言語ではありません。",
          "analogy": "FORTRANは計算専門の手順書（手続き型）で、モノ（オブジェクト）を中心とした考え方ではありません。"
        }
      },
      {
        "id": "d",
        "text": "アセンブリ言語",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "アセンブリ言語はCPUの命令に対応した低水準言語です。機械語と1対1対応に近い言語で、オブジェクト指向の概念は持ちません。",
          "analogy": "アセンブリ言語はCPUへの直接命令で、部品（オブジェクト）を組み合わせる概念はありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "Javaはオブジェクト指向を中心に設計された代表的な言語です。COBOLやFORTRANは手続き型言語です。",
      "keyPoint": "オブジェクト指向言語の代表例：Java・C++・C#・Python・Ruby",
      "relatedTopics": ["手続き型言語", "クラス", "継承", "カプセル化"],
      "studyTip": "各プログラミングパラダイム（手続き型・オブジェクト指向・関数型・論理型）と代表的な言語をセットで覚えましょう。"
    },
    "tags": ["プログラミング言語", "オブジェクト指向", "Java", "パラダイム"]
  },
  {
    "questionId": "q-ap-012",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "連結リスト",
    "level": 2,
    "question": "連結リスト（リンクリスト）の特徴として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "要素へのランダムアクセスがO(1)で行える",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(1)のランダムアクセスは配列の特徴です。連結リストはポインタをたどる必要があるため、n番目の要素へのアクセスはO(n)かかります。",
          "analogy": "配列はページ番号で直接開ける本ですが、連結リストは1ページから順番にたどる紙の鎖のようなもので、特定の場所に直接ジャンプできません。"
        }
      },
      {
        "id": "b",
        "text": "要素の挿入・削除がO(1)で行える（位置がわかっている場合）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "連結リストは各要素がポインタ（次の要素への参照）を持つ構造です。挿入・削除する位置がわかっていれば、ポインタを付け替えるだけでO(1)で操作できます（配列は後ろにずらすためO(n)が必要）。ただし目的の位置を探すのにO(n)かかります。",
          "analogy": "連結リストは鎖のようなものです。鎖の途中に輪を追加したり外したりするのは、前後の輪をつなぎ替えるだけで簡単です。配列は全員が一列に並んでいて、途中に人を入れると後ろ全員が動かなければなりません。",
          "deepDive": "連結リストの種類：単方向リスト（次の要素へのポインタのみ）、双方向リスト（前後のポインタを持つ）、循環リスト（末尾が先頭を指す）。連結リストは動的なサイズ変更が容易で、キューやスタックの実装に使われます。"
        }
      },
      {
        "id": "c",
        "text": "メモリが連続した領域に配置されることが保証される",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "連続したメモリ領域に配置されるのは配列の特徴です。連結リストの各要素は分散したメモリ領域に配置され、ポインタでつながれています。",
          "analogy": "配列は引き出しが横に並んだ整理ダンスですが、連結リストは街中に散らばった宝の地図のように、次の場所の住所（ポインタ）で移動します。"
        }
      },
      {
        "id": "d",
        "text": "サイズが固定されており、事前に確保したメモリ以上の要素を追加できない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "サイズ固定で事前確保が必要なのは静的な配列の特徴です。連結リストは動的にサイズを変更でき、要素の追加時にメモリを動的に確保します。",
          "analogy": "配列は最初から席数が決まった映画館で、連結リストは必要に応じて椅子を追加できる柔軟な会場です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "連結リストは挿入・削除がO(1)（位置がわかれば）、ランダムアクセスはO(n)。配列とは逆の特性を持ちます。",
      "keyPoint": "連結リスト：挿入・削除O(1)、ランダムアクセスO(n)、動的サイズ変更可",
      "relatedTopics": ["配列", "スタック", "キュー", "ポインタ"],
      "studyTip": "配列と連結リストのトレードオフ（ランダムアクセス vs. 挿入・削除）を表で整理して覚えましょう。"
    },
    "tags": ["連結リスト", "データ構造", "ポインタ", "O(1)"]
  },
  {
    "questionId": "q-ap-013",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "計算量（O記法）",
    "level": 3,
    "question": "O記法（ランダウ記法）の説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "アルゴリズムが使用するメモリ量の正確な値を表す記法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O記法は時間計算量（または空間計算量）の「オーダー（規模）」を表すものであり、正確な値ではありません。定数倍の違いは無視し、入力サイズnが増加したときの増加の傾向を表します。",
          "analogy": "O記法は「だいたいこのくらいのペースで増える」というおおまかな傾向を示すもので、「正確に何回」という数値ではありません。"
        }
      },
      {
        "id": "b",
        "text": "入力サイズが増加したときのアルゴリズムの処理時間の増加傾向を表す記法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "O記法（ビッグオー記法）は入力サイズnに対してアルゴリズムの計算量がどのように増加するかの「オーダー（上限）」を示す記法です。定数倍や低次の項を無視し、最も支配的な項だけを残します。例：O(1)は定数、O(n)は線形、O(n²)は二乗、O(log n)は対数の増加を示します。",
          "analogy": "O記法は都市間の距離感のようなものです。「東京から大阪は500キロ程度」という大まかな把握で、実際に531kmか512kmかという正確な値は気にしません。アルゴリズムの効率をざっくり比較するための道具です。",
          "deepDive": "主なオーダーの比較（n=1000の場合）：O(1)=1、O(log n)≈10、O(n)=1000、O(n log n)≈10000、O(n²)=1,000,000、O(2ⁿ)=天文学的数値。アルゴリズム選択では特にO(n²)とO(n log n)の差が重要です。"
        }
      },
      {
        "id": "c",
        "text": "アルゴリズムの実行時間を秒単位で計測した最悪値を表す記法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O記法は秒単位の実行時間ではなく、入力サイズnとの関係（増加の傾向）を表します。実際の秒数はハードウェアの性能によって変わりますが、O記法は環境に依存しない理論的な指標です。",
          "analogy": "O記法はドライブの所要時間を「高速道路なら一般道の2倍速」という比率で表すようなもので、「何時間何分」という実測値ではありません。"
        }
      },
      {
        "id": "d",
        "text": "アルゴリズムが出力するデータ量の上限を表す記法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O記法は出力データ量ではなく、入力サイズnに対する計算量（時間または空間）の増加傾向を表します。",
          "analogy": "O記法は「何を出力するか」ではなく「どれだけ時間・空間がかかるか」という効率の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "O記法は入力サイズnに対して計算量がどう増加するかの傾向を表す記法です。定数倍は無視し、増加の規模（オーダー）を示します。",
      "keyPoint": "O記法＝計算量の増加傾向を表す。O(1)<O(log n)<O(n)<O(n log n)<O(n²)<O(2ⁿ)",
      "relatedTopics": ["時間計算量", "空間計算量", "アルゴリズム効率"],
      "studyTip": "各ソート・探索アルゴリズムのO記法をセットで覚えましょう。線形探索O(n)、二分探索O(log n)、バブルソートO(n²)など。"
    },
    "tags": ["O記法", "計算量", "時間計算量", "アルゴリズム効率"]
  },
  {
    "questionId": "q-ap-014",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "再帰",
    "level": 3,
    "question": "再帰（再帰呼び出し）の説明として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "同じ処理を繰り返すためにfor文やwhile文を使う手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "for文やwhile文は反復（イテレーション）による繰り返しです。再帰は自分自身を呼び出す手法であり、ループとは異なります。",
          "analogy": "ループは同じ作業を何度も繰り返す工場のベルトコンベアで、再帰は「この仕事は小さく分けられる」と気づいて自分が自分に仕事を渡す仕組みです。"
        }
      },
      {
        "id": "b",
        "text": "関数がその処理の中で自分自身を呼び出す手法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "再帰（再帰呼び出し）とは、関数の内部でその関数自身を呼び出す手法です。問題を同じ構造の小さな問題に分割して解く「分割統治法」の考え方に基づいています。必ず「基底条件（base case）」と「再帰条件（recursive case）」が必要で、基底条件なしでは無限ループになります。",
          "analogy": "ロシアのマトリョーシカ人形が再帰のイメージです。大きな人形を開けると同じ形の小さな人形が入っており、それをまた開けると…という繰り返しですが、最後は「これ以上開かない最小の人形（基底条件）」があります。",
          "deepDive": "再帰の典型的な例：階乗計算（n! = n × (n-1)!）、フィボナッチ数列、二分木の走査、ハノイの塔。再帰はスタック（コールスタック）を使って関数の状態を保持するため、深い再帰はスタックオーバーフローの原因になります。末尾再帰最適化でこの問題を回避できる言語もあります。"
        }
      },
      {
        "id": "c",
        "text": "複数の関数が互いに呼び出し合うことで並列処理を実現する手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "複数の関数が互いに呼び出し合うのは「相互再帰」の一種ですが、並列処理を実現するものではありません。再帰は並列処理とは別の概念です。",
          "analogy": "再帰は自分が自分に仕事を依頼することで、並列処理は複数の人が同時に別々の仕事をこなすことです。別の概念です。"
        }
      },
      {
        "id": "d",
        "text": "変数の値を保持したまま処理を中断し、後で再開する手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "処理を中断して後で再開するのはコルーチンやジェネレータの概念です。再帰とは異なります。",
          "analogy": "中断・再開は「しおりをはさんで本を閉じる」イメージです。再帰は「本の中で別の本（同じ本の縮小版）を開く」イメージです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "再帰とは関数が自分自身を呼び出す手法です。基底条件（終了条件）が必須で、問題を小さな同じ構造の問題に分割するのに適しています。",
      "keyPoint": "再帰＝関数が自分自身を呼び出す。基底条件（終了条件）が必須。スタックを使用する。",
      "relatedTopics": ["スタック", "コールスタック", "分割統治法", "フィボナッチ"],
      "studyTip": "再帰を理解するには階乗（n!）の計算を手で追ってみるのが効果的です。f(3)=3×f(2)=3×2×f(1)=3×2×1=6という展開を確認しましょう。"
    },
    "tags": ["再帰", "関数", "基底条件", "コールスタック"]
  },
  {
    "questionId": "q-ap-015",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "挿入ソート",
    "level": 3,
    "question": "挿入ソートの動作として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "隣接する要素を繰り返し比較・交換し、最大値を末尾に移動させる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "隣接する要素を繰り返し比較・交換して最大値を末尾に移動させるのはバブルソートの動作です。",
          "analogy": "泡（大きな値）が浮き上がるように末尾に移動するのがバブルソートで、挿入ソートとは動作が異なります。"
        }
      },
      {
        "id": "b",
        "text": "未整列部分から最小値を選んで整列済み部分の末尾に移動させる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "未整列部分から最小値を選んで整列済み部分の末尾に配置するのは選択ソートの動作です。",
          "analogy": "全体から一番小さいものを選んで並べていくのが選択ソートで、1枚ずつ適切な位置に差し込むのが挿入ソートです。"
        }
      },
      {
        "id": "c",
        "text": "未整列部分の先頭要素を、整列済み部分の適切な位置に挿入する操作を繰り返す",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "挿入ソートは未整列部分から1つ要素を取り出し、既に整列された部分の適切な位置に挿入する操作を繰り返します。トランプを1枚ずつ手に取り、手持ちのカードの正しい順番の位置に差し込むイメージです。既にほぼ整列されたデータに対して効率的で、最良の場合はO(n)になります。",
          "analogy": "手持ちのトランプを整理するとき、1枚ずつ新しいカードを引いて、手持ちカードの正しい位置に差し込むのが挿入ソートです。小さいカードを左、大きいカードを右に差し込みながら常に手持ちを整列状態に保ちます。",
          "deepDive": "挿入ソートの計算量：最良O(n)（既に整列済みの場合）、平均・最悪O(n²)。バブルソートや選択ソートと同じオーダーですが、ほぼ整列されたデータには最も効率的です。クイックソートやマージソートの内部で小さいデータの整列に使われることがあります（ハイブリッドソート）。"
        }
      },
      {
        "id": "d",
        "text": "ピボットを中心にデータを分割し、再帰的に各部分を整列する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ピボットで分割して再帰的に整列するのはクイックソートの動作です。挿入ソートとは全く異なります。",
          "analogy": "グループを2つに分けて整理するのがクイックソートで、1枚ずつ適切な位置に差し込むのが挿入ソートです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "挿入ソートは未整列部分の先頭を取り出して整列済み部分の適切な位置に挿入する操作を繰り返します。トランプの並べ替えがイメージしやすいです。",
      "keyPoint": "挿入ソート＝1要素ずつ適切な位置に挿入。最良O(n)、最悪O(n²)。",
      "relatedTopics": ["バブルソート", "選択ソート", "クイックソート", "計算量"],
      "studyTip": "3つの基本ソート（バブル・選択・挿入）をトランプで実際に試してみると、動作の違いが体感でわかります。"
    },
    "tags": ["挿入ソート", "ソートアルゴリズム", "O(n²)", "安定ソート"]
  },
  {
    "questionId": "q-ap-016",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "計算量（O記法）",
    "level": 3,
    "question": "1024個の整列済みデータに対して二分探索を行う場合、最悪でも何回の比較で目的のデータを見つけられるか。",
    "choices": [
      {
        "id": "a",
        "text": "512回",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "512回は1024の半分ですが、二分探索では比較のたびに探索範囲が半分になるため、512回も比較する必要はありません。",
          "analogy": "辞書を真ん中から開いたとき、残りのページ数は512枚ではなく、また真ん中を開いて…と繰り返せば10回程度で見つかります。"
        }
      },
      {
        "id": "b",
        "text": "1024回",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1024回は線形探索の最悪計算量です。二分探索はO(log n)なので、はるかに少ない回数で見つかります。",
          "analogy": "1024冊の本を端から1冊ずつ調べるのが線形探索（最悪1024回）で、二分探索なら半分ずつ絞り込むので10回程度で済みます。"
        }
      },
      {
        "id": "c",
        "text": "10回",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "二分探索の最悪比較回数はlog₂nで計算します。n=1024の場合、log₂1024 = 10（2¹⁰=1024）なので、最悪10回の比較で見つかります。1回の比較で探索範囲が半分になるため、1024→512→256→128→64→32→16→8→4→2→1と10回で1つに絞れます。",
          "analogy": "1024ページの辞書を二分探索する場合：真ん中（512ページ）を開く→前半・後半どちらか（256ページ相当）→…と10回真ん中を開けば必ず見つかります。これが二分探索の強力さです。",
          "deepDive": "二分探索の最悪比較回数＝ceil(log₂n)。重要な値：n=8→3回、n=16→4回、n=1024→10回、n=100万→20回。线形探索と比べると劇的な差があり、100万件のデータでも最悪20回で見つかります。"
        }
      },
      {
        "id": "d",
        "text": "32回",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "32回はlog₂(1024)=10の正しい計算ではありません。2⁵=32なので、32回の比較が必要なのはn=2³²（約43億）件のデータです。",
          "analogy": "43億ページの辞書でも32回の比較で見つけられるのが二分探索の力です。1024ページなら10回で十分です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "二分探索の最悪比較回数はlog₂nです。n=1024の場合log₂1024=10回です。",
      "keyPoint": "二分探索の最悪比較回数＝log₂n。n=1024なら10回。",
      "relatedTopics": ["二分探索", "線形探索", "O(log n)", "対数"],
      "studyTip": "2の累乗とlog₂の値は試験でよく使います。2¹⁰=1024、log₂1024=10を覚えておきましょう。"
    },
    "tags": ["二分探索", "比較回数", "O(log n)", "log₂n"]
  },
  {
    "questionId": "q-ap-017",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "アルゴリズムの基本制御構造",
    "level": 3,
    "question": "構造化プログラミングの3つの基本制御構造の組み合わせとして正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "順次・選択・並列",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "並列は構造化プログラミングの3基本制御構造には含まれません。3つは「順次・選択・反復」です。並列処理は別の概念です。",
          "analogy": "料理のレシピに「同時に」という手順があっても、基本的な料理の流れ（順番・分岐・繰り返し）とは別の話です。"
        }
      },
      {
        "id": "b",
        "text": "順次・選択・反復",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "構造化プログラミングの3つの基本制御構造は「順次（sequence）・選択（selection）・反復（iteration）」です。ダイクストラが提唱したこの理論により、goто文を使わずにすべてのアルゴリズムを表現できることが証明されました。",
          "analogy": "料理のレシピで考えると：順次は「①玉ねぎを切る②炒める③塩を加える」という手順通りの実行、選択は「辛くする場合はAを、辛くない場合はBを加える」という条件分岐、反復は「3回かき混ぜる」という繰り返しです。",
          "deepDive": "構造化プログラミングはダイクストラ（Edsger W. Dijkstra）が1968年に提唱した概念です。それ以前のgoto文による「スパゲッティコード」の問題を解決しました。現在のほぼすべてのプログラミング言語はこの3構造を基本としています。"
        }
      },
      {
        "id": "c",
        "text": "入力・処理・出力",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "入力・処理・出力はプログラムの「データの流れ」を表す概念であり、制御構造ではありません。制御構造とは処理の「実行順序を制御する仕組み」です。",
          "analogy": "食材（入力）→料理（処理）→料理（出力）はデータフローの話で、「どの順番で調理するか」という制御構造とは別の話です。"
        }
      },
      {
        "id": "d",
        "text": "宣言・代入・出力",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "宣言・代入・出力はプログラミングの基本的な文の種類であり、制御構造（実行の流れを制御する仕組み）ではありません。",
          "analogy": "道具の準備（宣言）・材料を鍋に入れる（代入）・盛り付ける（出力）は調理の操作の種類で、「いつ何をするか」という制御の話とは異なります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "構造化プログラミングの3基本制御構造は「順次・選択・反復」です。これだけですべてのアルゴリズムを表現できます。",
      "keyPoint": "3基本制御構造＝順次・選択・反復。goto文不要でプログラムを構造化できる。",
      "relatedTopics": ["フローチャート", "アルゴリズム", "goto文", "ダイクストラ"],
      "studyTip": "「順次・選択・反復」は試験の頻出キーワードです。英語（sequence・selection・iteration）もセットで覚えましょう。"
    },
    "tags": ["構造化プログラミング", "制御構造", "順次", "選択", "反復"]
  },
  {
    "questionId": "q-ap-018",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "スタック",
    "level": 3,
    "question": "スタックに対して次の操作を順に行ったとき、スタックに残っているデータを下から順に並べたものはどれか。\n操作: push(1)→push(2)→push(3)→pop()→push(4)→pop()",
    "choices": [
      {
        "id": "a",
        "text": "1, 2",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "操作を順番に追います。push(1):スタック[1]、push(2):スタック[1,2]、push(3):スタック[1,2,3]、pop():3を取り出す→スタック[1,2]、push(4):スタック[1,2,4]、pop():4を取り出す→スタック[1,2]。最終的に下から1,2の順で残ります。",
          "analogy": "皿を積み上げる操作です。1→2→3の順に積み、上から3を取り出し、4を積み、また上から4を取り出すと、1と2の皿が残ります。一番下が1、その上が2です。",
          "deepDive": "スタックのトレースはLIFO原則を丁寧に追うことが重要です。試験ではpush/popの操作を図や表に書きながら追うと間違いが減ります。スタックの状態を「一番上が右（または上）」と統一して管理すると混乱しません。"
        }
      },
      {
        "id": "b",
        "text": "1, 4",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "4は最後のpop()で取り出されているため、スタックには残っていません。pop()はスタックから要素を取り出して削除する操作です。",
          "analogy": "4の皿は積んだ後すぐに取り出したので、スタックには残っていません。最後に残っているのは最初の2枚（1と2）です。"
        }
      },
      {
        "id": "c",
        "text": "2, 4",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "4は最後のpop()で取り出されておりスタックに残っていません。また最初にpush(1)した1もスタックに残っています。",
          "analogy": "4の皿はすでに取り出されています。1の皿は最初から積まれており、誰も取り出していないので底に残っています。"
        }
      },
      {
        "id": "d",
        "text": "1, 2, 4",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "4は最後のpop()で取り出されているため残っていません。pop()は取り出し（削除）操作であることに注意が必要です。",
          "analogy": "pop()は「皿を取って使った」操作です。使った皿（4）はスタックに戻りません。残っているのは使っていない1と2の皿だけです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "スタック操作をトレースすると：push(1)→push(2)→push(3)→pop(3を取出)→push(4)→pop(4を取出)で、残りは下から[1,2]です。",
      "keyPoint": "スタックのトレースはLIFO（後入れ先出し）を意識しながら1操作ずつ追うこと。",
      "relatedTopics": ["スタック", "push", "pop", "LIFO"],
      "studyTip": "スタック操作の問題は図を書きながらトレースすると間違いが防げます。上に積まれた要素から順にpopされることを意識しましょう。"
    },
    "tags": ["スタック", "LIFO", "push", "pop", "トレース"]
  },
  {
    "questionId": "q-ap-019",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "コンパイラ",
    "level": 4,
    "question": "コンパイラに関する説明として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ソースプログラムを1行ずつ解釈して実行する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1行ずつ解釈しながら実行するのはインタプリタです。コンパイラはプログラム全体を一括して変換します。",
          "analogy": "インタプリタは同時通訳、コンパイラは事前に全文を翻訳した書籍のようなものです。"
        }
      },
      {
        "id": "b",
        "text": "高水準言語で書かれたソースプログラムを機械語（または中間コード）に変換するプログラムである",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "コンパイラはC言語・JavaなどのプログラムのソースコードをCPUが直接実行できる機械語（またはJavaのような中間コード）に一括変換するプログラムです。変換（コンパイル）後は変換前のソースコードなしで実行できます。実行前に全体を変換するためインタプリタより実行速度が速くなります。",
          "analogy": "外国語の本を事前に日本語に翻訳しておけば（コンパイル）、読むとき（実行時）に翻訳コストがかかりません。インタプリタは読みながら翻訳するので毎回翻訳コストがかかります。",
          "deepDive": "コンパイラの処理フロー：字句解析→構文解析→意味解析→最適化→コード生成。C・C++・Goはネイティブの機械語にコンパイルします。Javaはバイトコード（中間コード）にコンパイルし、JVM（インタプリタ）で実行するハイブリッド方式です。"
        }
      },
      {
        "id": "c",
        "text": "複数のオブジェクトファイルを結合して実行可能ファイルを生成する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "複数のオブジェクトファイルを結合して実行可能ファイルを生成するのはリンカ（リンクエディタ）の役割です。コンパイラはソースコードをオブジェクトファイルに変換するところまでが役割です。",
          "analogy": "コンパイラはパーツを製造する工場で、リンカはパーツを組み立てて完成品を作る組立工場です。"
        }
      },
      {
        "id": "d",
        "text": "実行時にエラーが発生した場合のみ、エラーが発生した行を機械語に変換する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "コンパイラは実行前にプログラム全体を機械語に変換します。エラーが発生した行だけを変換するという動作はしません。コンパイル時にエラー（構文エラー等）を検出すると変換処理が中断されます。",
          "analogy": "コンパイラは書籍全体を事前に翻訳します。「読んでいてわからない部分だけ翻訳する」というわけではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "コンパイラは高水準言語のソースコードを機械語（または中間コード）に一括変換するプログラムです。実行前に全体を変換します。",
      "keyPoint": "コンパイラ＝全体を事前変換。インタプリタ＝1行ずつ実行時解釈。",
      "relatedTopics": ["インタプリタ", "リンカ", "アセンブラ", "オブジェクトファイル"],
      "studyTip": "コンパイラ→リンカ→実行ファイルという処理の流れを押さえておきましょう。各ツールの役割の違いが問われます。"
    },
    "tags": ["コンパイラ", "インタプリタ", "機械語", "中間コード"]
  },
  {
    "questionId": "q-ap-020",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "木構造（二分木）",
    "level": 4,
    "question": "二分木を中順（in-order）で走査したときのノードの訪問順序として正しいものはどれか。ただし、以下の構造を持つ二分木とする。\n根:A、Aの左の子:B、Aの右の子:C、Bの左の子:D、Bの右の子:E",
    "choices": [
      {
        "id": "a",
        "text": "A → B → D → E → C",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは前順（pre-order）の走査順序です。前順は「根→左部分木→右部分木」の順に訪問します（A→B→D→E→C）。中順とは異なります。",
          "analogy": "前順は親が先に出てくる順序です。「親→左の子→右の子」という訪問順です。"
        }
      },
      {
        "id": "b",
        "text": "D → B → E → A → C",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "中順（in-order）走査は「左部分木→根→右部分木」の順に再帰的に訪問します。この二分木では：左部分木（Bを根とする）を中順で走査→D→B→E、その後根のA、最後に右部分木のC。よってD→B→E→A→Cとなります。",
          "analogy": "二分探索木を中順で走査すると昇順に並んだ値が得られます。「左→自分→右」という順で、木の左端から右端へと順番に訪問するイメージです。",
          "deepDive": "二分木の3種類の走査方法：前順（pre-order）=根→左→右（A→B→D→E→C）、中順（in-order）=左→根→右（D→B→E→A→C）、後順（post-order）=左→右→根（D→E→B→C→A）。二分探索木の中順走査は必ず昇順になります。"
        }
      },
      {
        "id": "c",
        "text": "D → E → B → C → A",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは後順（post-order）に近い順序ですが正確ではありません。後順は「左部分木→右部分木→根」の順で、D→E→B→C→Aが後順（D→E→B→C→Aは正しい後順）です。中順とは異なります。",
          "analogy": "後順は「子供たちが先で、最後に親」という訪問順序です。木の葉から根に向かって訪問します。"
        }
      },
      {
        "id": "d",
        "text": "A → B → C → D → E",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは幅優先探索（BFS）の訪問順序です。上の階層から左から右へと訪問します。中順（深さ優先探索のin-order）とは異なります。",
          "analogy": "幅優先は階層ごとに左から右へ訪問するイメージで、中順は木を左から右へ「ひねって」一列に並べたような順序です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "中順（in-order）走査は「左部分木→根→右部分木」の順に再帰的に訪問します。この木ではD→B→E→A→Cとなります。",
      "keyPoint": "中順＝左→根→右。前順＝根→左→右。後順＝左→右→根。",
      "relatedTopics": ["二分木", "木構造", "前順", "後順", "二分探索木"],
      "studyTip": "3種類の走査を「根がいつ出るか」で覚えましょう。前順：根が最初、中順：根が真ん中、後順：根が最後です。"
    },
    "tags": ["二分木", "木構造", "中順", "in-order", "ツリー走査"]
  },
  {
    "questionId": "q-ap-021",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "クイックソート",
    "level": 4,
    "question": "クイックソートの説明として適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "隣接する要素を繰り返し比較・交換することで整列するアルゴリズム",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "隣接する要素を比較・交換するのはバブルソートです。クイックソートはピボットを使った分割統治法を用います。",
          "analogy": "隣の人と背の高さを比べて順番を入れ替えるのがバブルソートで、クイックソートはもっと効率的な方法です。"
        }
      },
      {
        "id": "b",
        "text": "ピボットと呼ばれる基準値を選び、それより小さい値と大きい値のグループに分割して再帰的に整列するアルゴリズム",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "クイックソートは「ピボット（基準値）」を選び、ピボットより小さい値を左グループ、大きい値を右グループに分割します。各グループに対して同じ操作を再帰的に繰り返すことで整列します。平均計算量O(n log n)で実用的な高速ソートアルゴリズムです。",
          "analogy": "クラスを身長順に並べるとき、代表者（ピボット）より背が低い人を左、高い人を右に分けます。各グループでまた代表者を決めて同じことを繰り返すと、やがて全員が整列します。",
          "deepDive": "クイックソートの計算量：平均O(n log n)、最悪O(n²)（ピボットが常に最大値や最小値になる場合）。最悪ケースを避けるためにランダムなピボット選択や中央値を使う手法があります。不安定ソートですが、実際の実装では高速なため多くの言語の標準ソートに使われています。"
        }
      },
      {
        "id": "c",
        "text": "配列を半分に分割し、それぞれを整列してから結合するアルゴリズム",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "配列を半分に分割し整列・結合するのはマージソートです。クイックソートは均等な半分ではなくピボットで大小2グループに分割します。",
          "analogy": "ちょうど半分に分けて後で合わせるのがマージソートで、基準値で大小に分けるのがクイックソートです。"
        }
      },
      {
        "id": "d",
        "text": "ヒープ（完全二分木）を使って整列するアルゴリズム",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ヒープ（完全二分木）を使って整列するのはヒープソートです。クイックソートはピボットによる分割統治法を使います。",
          "analogy": "ヒープソートは木構造を活用したソートで、クイックソートはグループ分けを繰り返すソートです。異なるアプローチです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "クイックソートはピボットで大小グループに分割して再帰的に整列します。平均計算量O(n log n)の高速アルゴリズムです。",
      "keyPoint": "クイックソート＝ピボット選択→分割→再帰。平均O(n log n)、最悪O(n²)。",
      "relatedTopics": ["マージソート", "ヒープソート", "ピボット", "分割統治法"],
      "studyTip": "クイックソートの最悪ケース（O(n²)）がなぜ起きるか（ピボットの選び方）を理解しておくと応用問題に対応できます。"
    },
    "tags": ["クイックソート", "ソートアルゴリズム", "ピボット", "分割統治法"]
  },
  {
    "questionId": "q-ap-022",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "計算量（O記法）",
    "level": 4,
    "question": "次のプログラムの時間計算量はどれか。\n```\nfor i in range(n):\n  for j in range(n):\n    print(i, j)\n```",
    "choices": [
      {
        "id": "a",
        "text": "O(1)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(1)は入力サイズnに関わらず実行時間が一定の場合です。このプログラムはnが増えると実行時間が増加するため、O(1)ではありません。",
          "analogy": "O(1)は何人来ても対応できる自動販売機のようなものです。このプログラムはnが増えると処理量が増えるため、O(1)ではありません。"
        }
      },
      {
        "id": "b",
        "text": "O(n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n)は1重のループの計算量です。このプログラムはn×nの2重ループのため、計算量はO(n²)です。",
          "analogy": "1列n人の握手はO(n)ですが、n人全員でお互いに握手するとn²回に近い握手が必要です。"
        }
      },
      {
        "id": "c",
        "text": "O(n²)",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "このプログラムは外側のループがn回、内側のループもn回実行されます。print文はn×n=n²回実行されるため、時間計算量はO(n²)（n²に比例）です。2重ループは一般にO(n²)になります。",
          "analogy": "n人のクラスで全員がお互いに1回ずつ自己紹介するとn×n回の自己紹介が必要です（実際には自分自身も含むため）。クラスの人数nが2倍になると自己紹介の回数は4倍になります。",
          "deepDive": "ネストされたループの計算量：1重ループ→O(n)、2重ループ→O(n²)、3重ループ→O(n³)。2重ループのO(n²)の代表例はバブルソート・選択ソート・挿入ソートです。n=1000の場合O(n)=1000回、O(n²)=100万回と大きな差があります。"
        }
      },
      {
        "id": "d",
        "text": "O(log n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(log n)は毎回探索範囲が半分になる二分探索のような場合に現れます。このプログラムは毎回nとn回ループするため、O(log n)ではありません。",
          "analogy": "O(log n)は辞書を半分ずつ絞り込む二分探索のイメージです。このプログラムは毎回n回ループするので、そのような絞り込みはありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "2重ループでそれぞれn回繰り返す場合、計算量はO(n²)になります。ネストの深さとループ回数から計算量を求めます。",
      "keyPoint": "n回×n回の2重ループ＝O(n²)。ループのネスト数で計算量の指数が決まる。",
      "relatedTopics": ["O記法", "ループ", "アルゴリズム効率", "ソートアルゴリズム"],
      "studyTip": "プログラムの計算量を求める問題は、ループの構造（何重か、各ループが何回か）に注目してください。"
    },
    "tags": ["O(n²)", "計算量", "2重ループ", "O記法"]
  },
  {
    "questionId": "q-ap-023",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "再帰",
    "level": 4,
    "question": "次の再帰関数f(n)においてf(4)を呼び出したとき、戻り値として正しいものはどれか。\n```\ndef f(n):\n  if n == 0:\n    return 1\n  else:\n    return n * f(n - 1)\n```",
    "choices": [
      {
        "id": "a",
        "text": "10",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "10は4+3+2+1の合計（等差数列の和）ですが、このプログラムは掛け算をしています。f(4)=4×3×2×1=24です。",
          "analogy": "足し算と掛け算を混同しています。このプログラムはn × f(n-1)と掛け算をしているので、階乗の計算です。"
        }
      },
      {
        "id": "b",
        "text": "24",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "この関数は階乗（n!）を計算する再帰関数です。f(4)の展開：f(4)=4×f(3)=4×3×f(2)=4×3×2×f(1)=4×3×2×1×f(0)=4×3×2×1×1=24。よってf(4)=4!=24です。",
          "analogy": "ロシアのマトリョーシカ人形のように開けていきます。f(4)を開けるとf(3)が入っており、f(3)を開けるとf(2)…と最終的にf(0)=1に到達して、帰りに掛け算しながら戻ります。",
          "deepDive": "このコードは階乗（factorial）の典型的な再帰実装です。n!=n×(n-1)×…×2×1、0!=1。再帰の基底条件はn==0でreturn 1です。計算量はO(n)で、再帰の深さもO(n)なのでnが大きいとスタックオーバーフローの可能性があります。"
        }
      },
      {
        "id": "c",
        "text": "16",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "16は4²ですが、このプログラムは4の2乗ではなく4の階乗（4!）を計算しています。4×4=16ではなく4×3×2×1=24です。",
          "analogy": "4の2乗（4×4）と4の階乗（4×3×2×1）を混同しています。このプログラムはn-1を使って1ずつ減らして掛けていくので階乗の計算です。"
        }
      },
      {
        "id": "d",
        "text": "4",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "4は引数nそのものの値ですが、再帰呼び出しによって複数の乗算が行われるため、戻り値は4より大きくなります。",
          "analogy": "f(4)を呼び出すと中でf(3)を呼び出し…と連鎖するので、最終的な値は4より大きくなります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "この再帰関数は階乗を計算します。f(4)=4×3×2×1×1=24。基底条件f(0)=1から逆方向に乗算して結果を返します。",
      "keyPoint": "n×f(n-1)で基底条件f(0)=1の再帰関数は階乗（n!）を計算する。",
      "relatedTopics": ["再帰", "階乗", "基底条件", "コールスタック"],
      "studyTip": "再帰関数のトレースは展開と縮約の2段階に分けて考えましょう。展開（f(4)→f(3)→…→f(0)）して、縮約（return 1→1→2→6→24）する流れです。"
    },
    "tags": ["再帰", "階乗", "トレース", "基底条件"]
  },
  {
    "questionId": "q-ap-024",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "データ構造（ハッシュ）",
    "level": 4,
    "question": "ハッシュテーブルの特徴として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "データを昇順に整列して格納するため、二分探索で効率よく検索できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "データを整列して格納するのは整列配列や二分探索木の特性です。ハッシュテーブルは整列ではなくハッシュ関数でアドレスを計算して格納します。",
          "analogy": "整列配列は五十音順の辞書のように順番に並べますが、ハッシュテーブルは名前から部屋番号を直接計算する住所録のようなものです。"
        }
      },
      {
        "id": "b",
        "text": "ハッシュ関数を使ってキーから格納アドレスを計算することで、平均O(1)での探索・挿入・削除が可能",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ハッシュテーブルはキー（名前など）をハッシュ関数で計算してメモリアドレス（バケット）を求め、そこに値を格納します。正常に動作すれば探索・挿入・削除の全てが平均O(1)で行えるため、大量データの管理に非常に有効です。ただしハッシュ衝突が多発すると効率が落ちます。",
          "analogy": "電話帳の引き方で考えると：従来は名前を五十音順に探す（O(log n)）のに対し、ハッシュテーブルは「名前から部屋番号を計算してその部屋を直接見る」方法で、名前さえわかれば直接アクセスできます（O(1)）。",
          "deepDive": "ハッシュテーブルの問題：ハッシュ衝突（collision）―異なるキーが同じアドレスになる問題。対処法：チェイン法（連結リストで衝突を解決）、オープンアドレス法（空きを線形探索）。最悪計算量はO(n)（全て衝突した場合）ですが、適切なハッシュ関数なら平均O(1)が維持できます。"
        }
      },
      {
        "id": "c",
        "text": "データを木構造で管理し、O(log n)での探索が保証される",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(log n)での探索が保証される木構造はバランス木（AVL木やRed-Black木）です。ハッシュテーブルは木構造ではなく、平均O(1)で動作します（最悪はO(n)）。",
          "analogy": "木構造は分岐しながら絞り込む探索（O(log n)）ですが、ハッシュテーブルは直接アドレスを計算するので平均O(1)です。"
        }
      },
      {
        "id": "d",
        "text": "要素を順序通りに並べているため、最小値・最大値の取得がO(1)で行える",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "最小値・最大値をO(1)で取得できるのはヒープ（優先度付きキュー）の特性です。ハッシュテーブルは順序を保持しないため、最小値・最大値の取得にはO(n)かかります。",
          "analogy": "ハッシュテーブルは部屋番号で直接アクセスできる便利な構造ですが、「全部屋の中で一番小さい部屋番号は？」という質問には全部屋を調べる必要があります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ハッシュテーブルはハッシュ関数でアドレスを計算し、平均O(1)での探索・挿入・削除を実現するデータ構造です。",
      "keyPoint": "ハッシュテーブル＝ハッシュ関数でアドレス計算・平均O(1)・衝突が課題",
      "relatedTopics": ["ハッシュ関数", "衝突", "配列", "二分探索木"],
      "studyTip": "ハッシュテーブルはPythonの辞書型（dict）やJavaのHashMapの内部実装です。衝突とその対処法（チェイン法・オープンアドレス法）も理解しておきましょう。"
    },
    "tags": ["ハッシュテーブル", "ハッシュ関数", "O(1)", "データ構造"]
  },
  {
    "questionId": "q-ap-025",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "マージソート",
    "level": 5,
    "question": "マージソートの計算量として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "最悪の場合O(n²)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n²)は最悪の場合クイックソートの計算量であり、バブルソートや選択ソートの計算量です。マージソートの最悪計算量はO(n log n)で、クイックソートより安定しています。",
          "analogy": "マージソートはどんな入力データでも常に同じ効率（O(n log n)）を保つ、クイックソートより安定した方法です。"
        }
      },
      {
        "id": "b",
        "text": "最良・最悪ともにO(n log n)",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "マージソートは配列を半分に分割し、それぞれを再帰的に整列した後、2つの整列済み配列をマージ（結合）します。分割の深さはlog n、各レベルでn個の要素を処理するためO(n log n)です。クイックソートと異なり、入力データの並び順に関係なく常にO(n log n)が保証されます（安定した最悪計算量）。",
          "analogy": "マラソン参加者1000人をタイム順に並べるとき：まず500人ずつに分け、それぞれを再帰的に整列し、最後に2つのグループをマージします。グループを半分にする深さはlog₂1000≈10回、各回で全員を比較するので合計O(n log n)の操作になります。",
          "deepDive": "マージソートの性質：①常にO(n log n)で安定（最悪ケースがクイックソートより優秀）②安定ソート（同じ値の元の順序を保持）③追加メモリO(n)が必要（クイックソートはO(log n)）。大規模データや連結リストのソートに適しています。"
        }
      },
      {
        "id": "c",
        "text": "O(n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n)は線形の計算量で、比較ベースのソートの理論的下限はO(n log n)です（n個の要素の比較ベースソートは少なくともO(n log n)必要）。O(n)でのソートは比較ベースでない特殊なケース（カウントソートなど）に限られます。",
          "analogy": "カードを整列するとき、少なくとも全カードを1枚ずつ確認する必要があるのでO(n)が下限ですが、比較ソートはそれに加えて比較の回数が必要でO(n log n)が理論的下限です。"
        }
      },
      {
        "id": "d",
        "text": "O(log n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(log n)は二分探索のような「毎回半分に絞り込む」探索の計算量です。ソートはすべての要素を処理する必要があるためO(log n)では不可能です。",
          "analogy": "ソートはn枚全カードを整理する必要があるので、少なくともO(n)はかかります。O(log n)はn枚中1枚を探す探索の計算量です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "マージソートは最良・最悪ともにO(n log n)が保証されます。クイックソートより最悪ケースが安定しており、安定ソートでもあります。",
      "keyPoint": "マージソート＝最良・最悪・平均ともO(n log n)。安定ソート。追加メモリO(n)必要。",
      "relatedTopics": ["クイックソート", "ヒープソート", "安定ソート", "分割統治法"],
      "studyTip": "マージソートとクイックソートの比較（最悪計算量・安定性・メモリ使用量）はよく出題されます。両者の違いをまとめておきましょう。"
    },
    "tags": ["マージソート", "ソートアルゴリズム", "O(n log n)", "安定ソート"]
  },
  {
    "questionId": "q-ap-026",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "オブジェクト指向",
    "level": 5,
    "question": "オブジェクト指向プログラミングにおける「カプセル化」の説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "一つのクラスが複数の異なるクラスの特性を受け継ぐこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "複数のクラスの特性を受け継ぐのは「継承（inheritance）」の説明です。カプセル化とは異なる概念です。",
          "analogy": "親から性質を受け継ぐのが継承で、データと操作をひとまとめにして外からは操作方法だけを見せるのがカプセル化です。"
        }
      },
      {
        "id": "b",
        "text": "データ（フィールド）と操作（メソッド）を一つのクラスにまとめ、内部の実装を隠蔽すること",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "カプセル化（encapsulation）とは、関連するデータ（属性・フィールド）と操作（メソッド）を1つのクラスにまとめ、外部からは必要なインターフェースだけを公開し、内部の実装の詳細を隠す（情報隠蔽）ことです。これにより外部への影響を最小化し、保守性が向上します。",
          "analogy": "テレビのリモコンがカプセル化の好例です。チャンネルボタン（メソッド）を押せばチャンネルが変わりますが、内部の回路（実装）の詳細は知らなくても使えます。内部の配線を直接触れないようにケースで覆われているのが「カプセル」です。",
          "deepDive": "カプセル化のメリット：①内部実装を変更しても外部への影響が最小化できる（保守性向上）②不正な状態への変更を防げる（データの整合性保持）③インターフェースが明確になる（使いやすさ向上）。アクセス修飾子（private/protected/public）でカプセル化を実現します。"
        }
      },
      {
        "id": "c",
        "text": "同じ名前のメソッドが、異なるオブジェクトに対して異なる動作をすること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "同じ名前のメソッドが異なるオブジェクトで異なる動作をするのは「ポリモーフィズム（多態性）」の説明です。カプセル化とは別の概念です。",
          "analogy": "「鳴け」という命令に犬は「ワン」、猫は「ニャー」と異なる反応をするのがポリモーフィズムで、カプセル化とは異なります。"
        }
      },
      {
        "id": "d",
        "text": "クラスから具体的なオブジェクトを生成すること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "クラスから具体的なオブジェクトを生成するのは「インスタンス化（instantiation）」です。カプセル化とは異なります。",
          "analogy": "設計図（クラス）から家（オブジェクト）を建てるのがインスタンス化で、家の内部をどう構造化して外部に何を見せるかがカプセル化の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "カプセル化はデータと操作をクラスにまとめ、内部実装を隠蔽することです。外部にはインターフェース（操作方法）だけを公開します。",
      "keyPoint": "カプセル化＝データ+操作をひとまとめ+内部実装の隠蔽。情報隠蔽によって保守性が向上する。",
      "relatedTopics": ["継承", "ポリモーフィズム", "抽象化", "アクセス修飾子"],
      "studyTip": "オブジェクト指向の4原則（カプセル化・継承・ポリモーフィズム・抽象化）はそれぞれの定義と具体例をセットで覚えましょう。"
    },
    "tags": ["カプセル化", "オブジェクト指向", "情報隠蔽", "クラス"]
  },
  {
    "questionId": "q-ap-027",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "アルゴリズム（グラフ探索）",
    "level": 5,
    "question": "幅優先探索（BFS）と深さ優先探索（DFS）の説明として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "BFSはスタックを使い、DFSはキューを使う",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "BFSとDFSで使うデータ構造が逆です。BFSはキュー（幅を優先するため、同じ深さのノードを順番に処理）、DFSはスタック（または再帰）を使います。",
          "analogy": "BFSは行列（キュー）のように同じ階層を左から右に処理し、DFSはメモ帳（スタック）のように深くまで潜ってから戻ります。"
        }
      },
      {
        "id": "b",
        "text": "BFSはキューを使い同じ深さのノードを優先して探索し、DFSはスタック（または再帰）を使い深く潜って探索する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "幅優先探索（BFS）はキューを使い、始点に近い（浅い）ノードから順に探索します。最短経路を求めるのに適しています。深さ優先探索（DFS）はスタック（または再帰）を使い、一方向に深く潜ってから戻り、別の方向を探索します。迷路の解法やトポロジカルソートに使われます。",
          "analogy": "BFSは石を池に投げたときの波紋のように、中心から外側に広がりながら探索します（同じ深さを全部見てから次の深さへ）。DFSは迷路を1つの道を最後まで進んで行き止まりなら戻る方法で探索します。",
          "deepDive": "BFSの特徴：①最短経路を保証（重みなしグラフ）②キューを使用③メモリ使用量が多い場合あり。DFSの特徴：①スタック/再帰を使用②メモリ効率が良い③最短経路を保証しない。グラフ問題ではBFSとDFSの適切な選択が重要です。"
        }
      },
      {
        "id": "c",
        "text": "BFSとDFSはどちらも同じ順序でノードを探索するが、使用するメモリ量が異なる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "BFSとDFSは探索する順序が異なります。BFSは浅い層から広く探索し、DFSは深く潜ってから戻ります。同じ順序で探索するわけではありません。",
          "analogy": "波紋のように広がる探索（BFS）と迷路を1本道に進む探索（DFS）では、同じグラフでも訪問するノードの順序は全く異なります。"
        }
      },
      {
        "id": "d",
        "text": "BFSは最長経路を求めるのに適し、DFSは最短経路を求めるのに適している",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "BFSとDFSの特性が逆です。BFSは始点から近い順に探索するため最短経路（重みなし）を求めるのに適しています。DFSは最短経路を保証しません。",
          "analogy": "波紋（BFS）は中心から順番に広がるので、最初にゴールに到達したときが最短経路です。迷路（DFS）は最初に見つけた道が最短とは限りません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "BFSはキューを使って浅い層から広く探索し最短経路に適します。DFSはスタック/再帰を使って深く潜って探索します。",
      "keyPoint": "BFS＝キュー・広く（最短経路）。DFS＝スタック/再帰・深く（迷路・木の走査）。",
      "relatedTopics": ["グラフ", "キュー", "スタック", "最短経路", "木構造"],
      "studyTip": "BFSとDFSはグラフや木の問題でよく使われます。「どのデータ構造を使うか（キュー vs. スタック）」と「どんな問題に適しているか」を覚えましょう。"
    },
    "tags": ["BFS", "DFS", "グラフ探索", "キュー", "スタック"]
  },
  {
    "questionId": "q-ap-028",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "計算量（O記法）",
    "level": 5,
    "question": "n要素を整列するとき、比較ベースのソートアルゴリズムの理論的な時間計算量の下限として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "O(n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n)は理論的下限ではありません。比較ベースのソートでは少なくともO(n log n)の比較が必要であることが情報理論的に証明されています。O(n)のソートは比較ベースではない特殊な方法（カウントソートなど）に限られます。",
          "analogy": "n枚のカードを全部見ずに整列することは不可能なので最低O(n)必要ですが、比較ソートはそれ以上かかります。"
        }
      },
      {
        "id": "b",
        "text": "O(n log n)",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "情報理論による証明：n個の要素を整列するには、n!通りの並び順から正しい1つを決める必要があります。1回の比較で2択を決めるので、少なくともlog₂(n!)回の比較が必要です。スターリングの近似式よりlog₂(n!)≈n log₂nとなり、比較ベースソートの下限はΩ(n log n)（オメガ記法）です。マージソートとヒープソートはこの下限を達成しています。",
          "analogy": "50音順に並んだ100枚のカードを整理するとき、カード同士を比べながら並べる方法では最低でも何百回かの比較が避けられません。これが理論的下限で、O(n log n)という回数です。それ以上速くする方法は存在しません（比較ベースでは）。",
          "deepDive": "比較ベースソートの下限O(n log n)を達成するアルゴリズム：マージソート（最悪O(n log n)）、ヒープソート（最悪O(n log n)）。クイックソートは平均O(n log n)ですが最悪O(n²)。O(n)のソート：カウントソート・バケットソート・基数ソート（比較を使わない特殊な手法）。"
        }
      },
      {
        "id": "c",
        "text": "O(n²)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n²)はバブルソート・選択ソート・挿入ソートの計算量ですが、理論的下限ではありません。O(n log n)のマージソートやヒープソートがより少ない比較回数で整列できるため、O(n²)は下限ではなく上限（の悪いアルゴリズム）側です。",
          "analogy": "O(n²)より良い方法（マージソートなど）が存在するので、O(n²)は下限ではなく「頑張れば改善できる計算量」です。"
        }
      },
      {
        "id": "d",
        "text": "O(log n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(log n)はn要素を整列するには不可能な計算量です。ソートには少なくとも全要素を1度は確認する必要があるためO(n)未満にはなれず、比較ベースでは更にO(n log n)が下限です。",
          "analogy": "O(log n)はn=1000なら10回の操作で完了する計算量ですが、1000枚のカードを10回の操作で整列することは不可能です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "比較ベースのソートの理論的下限はO(n log n)です。マージソートとヒープソートがこの下限を達成しています。",
      "keyPoint": "比較ベースソートの下限＝O(n log n)。これより速い比較ソートは存在しない。",
      "relatedTopics": ["マージソート", "ヒープソート", "クイックソート", "情報理論"],
      "studyTip": "「なぜO(n log n)が下限か」の理由（n!通りの並び順をlog₂(n!)回の比較で決定する）を理解すると、ソートの理論が深く理解できます。"
    },
    "tags": ["計算量下限", "O(n log n)", "比較ベースソート", "情報理論"]
  },
  {
    "questionId": "q-ap-029",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "動的計画法",
    "level": 5,
    "question": "動的計画法（Dynamic Programming）の特徴として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "問題をランダムに分割し、分割した部分問題を並列に解く手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "問題を分割して解くのは分割統治法（divide and conquer）に近いですが、動的計画法の特徴は「部分問題の重複」を利用して計算済みの結果を再利用する点です。並列処理とは異なります。",
          "analogy": "動的計画法はすでに解いた問題の答えをメモしておき、同じ問題が出てきたらメモを見るだけで済ます方法です。並列に解くこととは違います。"
        }
      },
      {
        "id": "b",
        "text": "重複する部分問題を一度だけ解いて結果を記録し（メモ化）、再利用することで計算量を削減する手法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "動的計画法は「重複する部分問題（overlapping subproblems）」と「最適部分構造（optimal substructure）」を持つ問題に有効です。同じ計算を何度も繰り返さないよう、計算結果をテーブルに記録して再利用します。フィボナッチ数列の素朴な再帰はO(2ⁿ)ですが、動的計画法でO(n)に削減できます。",
          "analogy": "試験勉強での動的計画法は「一度解いた問題の答えをノートに書いておき、同じ問題が出たらノートを見る」方法です。毎回1から解くより圧倒的に速くなります。",
          "deepDive": "動的計画法の典型問題：フィボナッチ数列（再帰O(2ⁿ)→DPでO(n)）、最長共通部分列（LCS）、ナップサック問題、最短経路問題（ベルマンフォード法）。動的計画法には「トップダウン（メモ化再帰）」と「ボトムアップ（テーブル充填）」の2つのアプローチがあります。"
        }
      },
      {
        "id": "c",
        "text": "現在の状態で最善と思われる選択を繰り返す貪欲な探索手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "現在の状態で最善の選択を繰り返す手法は貪欲法（グリーディアルゴリズム）です。動的計画法は全体最適を保証するために全ての部分問題を解くのに対し、貪欲法は局所的に最善の選択をします。",
          "analogy": "貪欲法はご飯を食べるとき「今一番おいしそうなものから食べる」選択で、動的計画法は「全体のバランスを考えて最善の食べ方を計算する」方法です。"
        }
      },
      {
        "id": "d",
        "text": "全ての可能な解を列挙して最善のものを選ぶ全探索手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "全ての解を列挙するのは全探索（ブルートフォース）です。動的計画法は重複する計算を省略することで全探索より効率的に最適解を求めます。",
          "analogy": "全探索は全ての道を1本ずつ歩いて最短を探す方法で、動的計画法はすでに計算した部分の結果を記録して賢く探索する方法です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "動的計画法は重複する部分問題の計算結果を記録・再利用することで計算量を大幅に削減するアルゴリズム設計手法です。",
      "keyPoint": "動的計画法＝重複部分問題のメモ化・再利用。フィボナッチをO(2ⁿ)からO(n)に削減できる。",
      "relatedTopics": ["メモ化", "再帰", "分割統治法", "貪欲法"],
      "studyTip": "動的計画法の理解はフィボナッチ数列の素朴な再帰とDP版を比較するのが近道です。計算の無駄を省く発想を掴みましょう。"
    },
    "tags": ["動的計画法", "メモ化", "部分問題", "フィボナッチ"]
  },
  {
    "questionId": "q-ap-030",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "プログラミング言語（処理系）",
    "level": 5,
    "question": "JIT（Just-In-Time）コンパイラの説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ソースコードを事前に機械語に変換し、変換後のファイルのみを配布する手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ソースコードを事前に機械語に変換するのは通常の（事前）コンパイラの動作です。JITコンパイラは実行時にコンパイルを行う点が異なります。",
          "analogy": "事前コンパイラは旅行前に全ての会話を翻訳してきた翻訳書を用意する方法で、JITはその場で素早く翻訳する方法です。"
        }
      },
      {
        "id": "b",
        "text": "プログラムの実行中に、実行される直前のコードを機械語にコンパイルすることでインタプリタより高速な実行を実現する手法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "JIT（Just-In-Time）コンパイラはプログラム実行中に、実行が必要になったコードをその場で機械語にコンパイルする手法です。純粋なインタプリタ（毎回解釈）より速く、事前コンパイラ（移植性が低い）の中間的な位置づけです。頻繁に実行されるコードを最適化する「ホットスポット最適化」も行います。JavaのJVM（HotSpot）やPython（PyPy）などで使われています。",
          "analogy": "JITは「よく使う表現は暗記して素早く言い、初めて出てきた表現はその場で訳す」方法をとる通訳者のようなものです。同じ文が何度も出てきたら、機械語に翻訳した結果を再利用するので段々速くなります。",
          "deepDive": "JITコンパイラの特性：①起動直後は遅い（まだコンパイルしていないため）、実行が続くと速くなる②ホットスポット（頻繁に実行されるコード）を優先的に最適化③プラットフォーム依存の最適化が可能。Javaの「Write Once, Run Anywhere」はバイトコード+JITで実現しています。"
        }
      },
      {
        "id": "c",
        "text": "ソースコードを1行ずつ解釈して実行する方式で、デバッグに優れた処理系",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1行ずつ解釈して実行するのはインタプリタです。JITコンパイラはインタプリタより高速に実行できることが特徴であり、単純なインタプリタとは区別されます。",
          "analogy": "JITはインタプリタの速度問題を解決するために生まれた技術で、インタプリタ方式とは異なります。"
        }
      },
      {
        "id": "d",
        "text": "複数のオブジェクトファイルを1つの実行可能ファイルにまとめるプログラム",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "複数のオブジェクトファイルを結合するのはリンカです。JITコンパイラはリンカとは全く別の概念です。",
          "analogy": "リンカはパーツを組み立てて完成品を作るもので、JITは使う直前に部品を加工して最適化するものです。役割が異なります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "JITコンパイラはプログラム実行中に必要なコードを実行直前に機械語にコンパイルすることで、インタプリタより高速な実行を実現します。",
      "keyPoint": "JIT＝実行時コンパイル。インタプリタより速く、事前コンパイラの移植性を保ちつつ高速化。JavaのJVMなどで使用。",
      "relatedTopics": ["コンパイラ", "インタプリタ", "Java", "バイトコード"],
      "studyTip": "コンパイラ・インタプリタ・JITの3つを「翻訳のタイミング（事前・都度・直前）」という軸で整理すると区別しやすくなります。"
    },
    "tags": ["JIT", "コンパイラ", "インタプリタ", "実行時最適化", "Java"]
  }
]
