[
  {
    "questionId": "q-ap-049",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "動的計画法の応用",
    "level": 9,
    "question": "ナップサック問題（0/1 knapsack）を動的計画法で解く場合の時間計算量はどれか。ただし、n はアイテム数、W は容量の上限（整数）とする。",
    "choices": [
      {
        "id": "a",
        "text": "O(n log n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n log n) はソートアルゴリズム（マージソートなど）の計算量であり、ナップサック問題の動的計画法とは無関係です。容量 W に対するループが存在するため、W の影響を無視することはできません。",
          "analogy": "棚に荷物を詰め込む際に、荷物の数だけでなく棚の大きさも考慮しなければならないのと同じように、W を無視した計算量は正しくありません。"
        }
      },
      {
        "id": "b",
        "text": "O(nW)",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "0/1 ナップサック問題の動的計画法では、dp[i][w] という二次元テーブル（i: 0〜n、w: 0〜W）を埋めます。各セルは O(1) で計算できるため、全体の時間計算量は O(nW) となります。この計算量は W が大きい場合に指数的にはならないものの、W は整数値そのものに依存するため「擬多項式時間」と呼ばれます。",
          "analogy": "n 種類のお菓子を W グラムのバッグに詰める組み合わせを一覧表（n 行 × W 列）で整理するイメージです。表の全マスを埋めるので n × W 回の計算が必要になります。",
          "deepDive": "O(nW) は多項式時間のように見えますが、W を表現するビット数を k とすると W = 2^k 程度になり得るため、入力サイズに対しては指数時間になる可能性があります。これを「擬多項式時間（pseudo-polynomial time）」といい、ナップサック問題が NP 困難である事実と矛盾しません。"
        }
      },
      {
        "id": "c",
        "text": "O(2^n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(2^n) は総当たり（全列挙）でナップサック問題を解く場合の計算量です。動的計画法によってこの指数爆発を避けるのが DP の目的であり、DP では O(nW) に抑えられます。",
          "analogy": "n 種類のお菓子を「全部の組み合わせ」で試すと 2^n 通りになりますが、表を使って計算を再利用すれば nW 回の計算で済む、という違いです。"
        }
      },
      {
        "id": "d",
        "text": "O(n^2)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n^2) はアイテム数 n の二乗に比例する計算量ですが、ナップサック問題では容量 W に対するループも必要なため W が n より大きい場合に不十分な見積もりです。正しくは O(nW) です。",
          "analogy": "荷物の種類だけを考えて棚の大きさを忘れると、見積もりが足りなくなります。荷物の種類（n）と棚の容量（W）両方を掛け合わせた回数の作業が必要です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "0/1 ナップサック問題を動的計画法で解く時間計算量は O(nW) です。これは擬多項式時間であり、W が入力ビット数に対して指数的になる場合があるため NP 困難と矛盾しません。",
      "keyPoint": "DP テーブルのサイズ = n × W、各セルの計算は O(1) → 全体 O(nW)。擬多項式時間という概念を理解すること。",
      "relatedTopics": ["動的計画法", "NP 困難", "擬多項式時間", "計算量理論"],
      "studyTip": "DP では「何を縦軸・横軸にするか」でテーブルサイズが決まり、それが計算量になると覚えましょう。ナップサックは『アイテム数 × 容量』のテーブルです。"
    },
    "tags": ["動的計画法", "ナップサック問題", "計算量", "擬多項式時間"]
  },
  {
    "questionId": "q-ap-050",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "動的計画法の応用",
    "level": 9,
    "question": "最長共通部分列（LCS: Longest Common Subsequence）を動的計画法で求めるとき、文字列 X（長さ m）と文字列 Y（長さ n）に対する漸化式として正しいものはどれか。ただし、dp[i][j] は X の先頭 i 文字と Y の先頭 j 文字の LCS 長さとする。",
    "choices": [
      {
        "id": "a",
        "text": "X[i] == Y[j] のとき dp[i][j] = dp[i-1][j-1]、それ以外は dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "X[i] == Y[j] のとき dp[i-1][j-1] に 1 を加えるのが正しいです。一致した文字を LCS に追加するため、+1 が必要です。また不一致時に +1 するのも誤りで、どちらか長い方をそのまま引き継ぐべきです。",
          "analogy": "共通の文字が見つかったら手帳に1件追記する（+1）ことを忘れているイメージです。"
        }
      },
      {
        "id": "b",
        "text": "X[i] == Y[j] のとき dp[i][j] = dp[i-1][j-1] + 1、それ以外は dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "LCS の漸化式の核心は「末尾文字が一致するかどうか」です。一致する場合、その文字を LCS に追加できるので dp[i-1][j-1] + 1。一致しない場合は、X の i 文字目を使わない場合（dp[i-1][j]）と Y の j 文字目を使わない場合（dp[i][j-1]）の大きい方を選びます。",
          "analogy": "2人の旅行の日程（X と Y）で共通の予定を探すとき、今日の予定が一致すれば「共通リストに追加（+1）」、一致しなければ「どちらかの昨日までの最良リスト」を引き継ぐイメージです。",
          "deepDive": "LCS の計算量は O(mn) です。LCS は差分管理（git diff）や DNA 配列比較、テキスト比較ツールの基盤となる重要なアルゴリズムです。LCS を利用して編集距離（Levenshtein 距離）も導出できます。"
        }
      },
      {
        "id": "c",
        "text": "X[i] == Y[j] のとき dp[i][j] = dp[i][j-1] + 1、それ以外は dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "一致時に参照すべきは dp[i-1][j-1]（両方の直前文字まで）です。dp[i][j-1] は Y の j-1 文字まで・X の i 文字まで、つまり X[i] 自体をまだ処理している状態であり、誤った参照です。",
          "analogy": "共通の予定が見つかったとき、片方の昨日（j-1）だけ振り返って「追加」するのは、もう片方の昨日（i-1）を無視しているので間違いです。"
        }
      },
      {
        "id": "d",
        "text": "X[i] == Y[j] のとき dp[i][j] = max(dp[i-1][j], dp[i][j-1])、それ以外は dp[i][j] = dp[i-1][j-1] + 1",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "一致・不一致の処理が逆転しています。一致したときこそ dp[i-1][j-1] + 1 を使うべきであり、不一致のときに max を取るのが正しい漸化式です。",
          "analogy": "共通の予定が見つかったときに無視して、バラバラの予定のときに追記しようとするのは、リスト作りの方向性が逆です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "LCS の DP 漸化式は「末尾が一致 → dp[i-1][j-1]+1、不一致 → max(dp[i-1][j], dp[i][j-1])」です。計算量は O(mn)。",
      "keyPoint": "一致時は『両方とも1文字戻った位置の LCS + 1』、不一致時は『どちらか一方を1文字戻した場合の最大値』を選ぶ。",
      "relatedTopics": ["動的計画法", "編集距離", "文字列アルゴリズム", "LCS"],
      "studyTip": "DP テーブルを手書きで埋める練習をすると漸化式が体で覚えられます。3〜4文字の短い例で試してみましょう。"
    },
    "tags": ["動的計画法", "LCS", "文字列アルゴリズム", "漸化式"]
  },
  {
    "questionId": "q-ap-051",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "計算量の理論的下限",
    "level": 9,
    "question": "比較に基づくソートアルゴリズムの計算量の理論的下限はどれか。ただし、n はソート対象の要素数とする。",
    "choices": [
      {
        "id": "a",
        "text": "O(n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n) で全要素をソートすることは比較に基づく手法では理論的に不可能です。n 要素を一度しか見ないと、要素間の全ての順序関係を確認できません。",
          "analogy": "本棚を整理するとき、各本を1回しか見なければ、全ての本の相対的な位置関係を決定できないのと同じです。"
        }
      },
      {
        "id": "b",
        "text": "O(n log n)",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "比較に基づくソートの下限は情報理論から導かれます。n 要素の並び順は n! 通りあり、各比較で「大・小」の2択を判定するため、決定木の葉の数は n! 以上必要です。高さ h の二分木の葉数は最大 2^h なので、2^h ≥ n! が必要です。スターリングの近似より log2(n!) ≈ n log2 n となり、h ≥ Ω(n log n) が導かれます。マージソートやヒープソートはこの下限を達成しています。",
          "analogy": "n 冊の本の並び順を当てる○×クイズを考えると、n! 通りの答えを二分探索で絞り込むには log2(n!) ≈ n log n 回の質問が必要です。これ以下の質問で必ず当てることは不可能です。",
          "deepDive": "この下限証明は「決定木モデル」を使います。比較に基づかない基数ソート（Radix Sort）はこの制約を受けず O(nk) を達成できますが、入力の性質（桁数 k が小さいこと）に依存します。"
        }
      },
      {
        "id": "c",
        "text": "O(n^2)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n^2) はバブルソートや挿入ソートなどの単純なアルゴリズムの計算量であり、理論的下限ではありません。O(n log n) のアルゴリズム（マージソート等）が存在するため、下限には相当しません。",
          "analogy": "「最低でも n^2 回の作業が必要」は誤りで、実際には n log n 回で済むアルゴリズムがすでに存在します。"
        }
      },
      {
        "id": "d",
        "text": "O(log n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(log n) は二分探索の計算量ですが、ソートの下限ではありません。n 要素すべての順序を確定するには少なくとも n-1 回以上の比較が必要なため、O(log n) は明らかに少なすぎます。",
          "analogy": "本棚全体を整理するのに、本を数冊しか見ないで完了することは不可能です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "比較に基づくソートの理論的下限は Ω(n log n) です。これは情報理論（決定木モデル）から導かれ、マージソートとヒープソートがこの下限を達成しています。",
      "keyPoint": "n! 通りの可能性を2択比較で絞り込むには log2(n!) ≈ n log n 回の比較が必要という情報理論的議論が核心。",
      "relatedTopics": ["ソートアルゴリズム", "計算量理論", "情報理論", "決定木"],
      "studyTip": "「なぜ n log n が下限か」を決定木の高さで説明できるようにしておくと、応用問題でも対応できます。"
    },
    "tags": ["計算量", "ソート", "下限定理", "情報理論", "決定木"]
  },
  {
    "questionId": "q-ap-052",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "再帰アルゴリズムの解析",
    "level": 9,
    "question": "マスター定理において、漸化式 T(n) = 2T(n/2) + O(n) の解はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "O(n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n) は T(n) = 2T(n/2) + O(1) のような場合に相当します。分割コスト f(n) = O(n) は単純な定数コストより大きく、O(n) では不十分です。",
          "analogy": "グループを2つに分けて解いてから、グループ間の統合作業（n 個の要素を見る）を行う場合、統合作業の分だけ余計な時間がかかるため O(n) より大きくなります。"
        }
      },
      {
        "id": "b",
        "text": "O(n log n)",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "マスター定理のケース 2 に該当します。漸化式 T(n) = aT(n/b) + f(n) において a=2、b=2、f(n)=O(n)、n^(log_b a) = n^(log_2 2) = n^1 = n です。f(n) = O(n) = Θ(n^(log_b a)) なのでケース 2 が適用され、T(n) = Θ(n log n) = O(n log n) となります。これはマージソートの計算量そのものです。",
          "analogy": "集会を2つのグループ（n/2 人ずつ）に分けて議論し、最後に全員（n 人）で結論をまとめる作業を繰り返すイメージです。まとめ作業が毎回 n 人分かかり、log n 回繰り返すので n log n になります。",
          "deepDive": "マスター定理の3ケース：ケース1（f(n) が n^(log_b a) より小さい） → T(n)=Θ(n^(log_b a))、ケース2（等しい） → Θ(n^(log_b a) log n)、ケース3（大きい） → Θ(f(n))。マージソート・クイックソートの平均計算量はこの定理で導出できます。"
        }
      },
      {
        "id": "c",
        "text": "O(n^2)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(n^2) はマスター定理のケース 3（f(n) が n^(log_b a) より十分大きい場合）にあたりますが、本問では f(n) = O(n) = Θ(n) であり、n^(log_b a) = n と等しいためケース 2 が適用されます。",
          "analogy": "毎回の統合コストが n^2 のように爆発的に大きければ O(n^2) になりますが、ここでは統合コストは n 程度に抑えられています。"
        }
      },
      {
        "id": "d",
        "text": "O(log n)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(log n) は T(n) = T(n/2) + O(1) のような二分探索型の漸化式に対応します。本問では a=2 であり、再帰が2分岐するため O(log n) では小さすぎます。",
          "analogy": "2つのグループに分けて同時並行で解いても、統合コストが毎回かかるため O(log n) では収まりません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "T(n)=2T(n/2)+O(n) はマスター定理ケース2に該当し、解は O(n log n) です。マージソートの計算量の理論的根拠です。",
      "keyPoint": "マスター定理：a=2, b=2, f(n)=n のとき n^(log_2 2)=n なのでケース2 → Θ(n log n)。",
      "relatedTopics": ["マスター定理", "再帰", "マージソート", "分割統治"],
      "studyTip": "マスター定理はパターンを覚えるより『n^(log_b a) と f(n) の大小関係でケースを判断する』という手順を理解すると応用が効きます。"
    },
    "tags": ["マスター定理", "再帰", "計算量解析", "分割統治", "マージソート"]
  },
  {
    "questionId": "q-ap-053",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "オブジェクト指向の多態性・抽象クラス",
    "level": 9,
    "question": "抽象クラスとインタフェースの違いとして最も適切な記述はどれか（Java を前提とする）。",
    "choices": [
      {
        "id": "a",
        "text": "抽象クラスは多重継承できるが、インタフェースは単一継承のみである。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "Java では逆です。クラス（抽象クラスを含む）は単一継承のみ許可され、インタフェースは複数実装（implements）できます。多重継承の問題（ダイヤモンド問題）を避けるため、Java はクラスの多重継承を禁止しています。",
          "analogy": "親族の家系は1本の木（単一継承）しか持てないが、資格証明書（インタフェース）は複数持てる、と覚えましょう。"
        }
      },
      {
        "id": "b",
        "text": "抽象クラスはフィールドや具体的なメソッド実装を持てるが、インタフェースは（Java 8 以前は）メソッドシグネチャのみを定義する。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "Java の抽象クラス（abstract class）はインスタンス変数（フィールド）や具体的な実装を持つメソッドを含められます。一方、Java 7 以前のインタフェースはメソッドシグネチャ（と定数）のみを定義でき、実装は持てませんでした（Java 8 からは default メソッドが追加）。この違いが「is-a 関係にはクラス継承、can-do 関係にはインタフェース」という設計指針の根拠です。",
          "analogy": "抽象クラスは「骨格だけある建物の設計図（内装の一部も決まっている）」、インタフェースは「建物が満たすべき法律の基準（中身は各自が決める）」のようなものです。",
          "deepDive": "Java 8 以降は interface に default メソッドと static メソッドが追加されたため境界が曖昧になりましたが、『コンストラクタを持てるか』『フィールド（非定数）を持てるか』の点では今でも抽象クラスのみが可能です。"
        }
      },
      {
        "id": "c",
        "text": "インタフェースは抽象メソッドを持てないが、抽象クラスは全メソッドが抽象メソッドでなければならない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "どちらも誤りです。インタフェースは（Java 7 以前では）抽象メソッドのみを持ちます。抽象クラスは抽象メソッドと具体的なメソッドを混在させることができ、全てが抽象メソッドである必要はありません。",
          "analogy": "資格試験（インタフェース）は試験科目（抽象メソッド）の基準を定めますが、学校（抽象クラス）は必修科目だけでなく選択科目（具体メソッド）も提供できます。"
        }
      },
      {
        "id": "d",
        "text": "抽象クラスもインタフェースもインスタンスを直接生成できる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "抽象クラスもインタフェースも直接インスタンスを生成することはできません（抽象クラスは abstract キーワードがあるためコンパイルエラー、インタフェースも同様）。具体的なサブクラスを定義して使用します。",
          "analogy": "「動物」という概念（抽象クラス）から直接「動物」を作ることはできず、「犬」や「猫」という具体的なものしか作れないのと同じです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "抽象クラスはフィールドや具体的実装を持てるが多重継承不可。インタフェースは多重実装可だが（Java 7 以前は）実装を持てない。設計原則：is-a には継承、can-do にはインタフェース。",
      "keyPoint": "抽象クラス = フィールドあり・具体メソッドあり・単一継承のみ。インタフェース = 定数のみ・シグネチャのみ（Java 7 以前）・多重実装可。",
      "relatedTopics": ["オブジェクト指向", "継承", "多態性", "ポリモーフィズム", "Java"],
      "studyTip": "「抽象クラスはテンプレート、インタフェースは契約」というメタファーで整理すると違いが明確になります。"
    },
    "tags": ["抽象クラス", "インタフェース", "オブジェクト指向", "継承", "Java"]
  },
  {
    "questionId": "q-ap-054",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "デザインパターンの基礎",
    "level": 9,
    "question": "GoF デザインパターンのうち、オブジェクトの生成をサブクラスに委ねることで、クライアントコードを具体クラスから分離するパターンはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "Singleton パターン",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "Singleton はクラスのインスタンスが1つだけ存在することを保証するパターンです。生成をサブクラスに委ねるのではなく、自身のクラスが唯一のインスタンスを管理します。",
          "analogy": "会社に社長が1人しかいない仕組み（Singleton）は、新しい社長の作り方をサブクラスに委ねる話とは別の概念です。"
        }
      },
      {
        "id": "b",
        "text": "Factory Method パターン",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "Factory Method パターンでは、オブジェクト生成のインタフェースを親クラスで定義し、実際にどのクラスのインスタンスを生成するかをサブクラスで決定します。これにより、クライアントコードは具体的なクラス名を知らずにオブジェクトを使用でき、開放閉鎖原則（Open/Closed Principle）を守ることができます。",
          "analogy": "ピザ屋のフランチャイズ本部（親クラス）が「ピザを作れ」という手順だけを定め、各店舗（サブクラス）が「ナポリタン」か「マルゲリータ」か具体的な種類を決めるイメージです。",
          "deepDive": "Factory Method は『生成に関するパターン（Creational Pattern）』の一つです。Abstract Factory は複数の関連オブジェクト群を作るファクトリを抽象化するパターンで、Factory Method を内部で使うことがあります。SOLID 原則の依存性逆転の原則（DIP）とも深く関連します。"
        }
      },
      {
        "id": "c",
        "text": "Observer パターン",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "Observer は状態変化を監視・通知する行動に関するパターンです。オブジェクトの生成とは無関係で、イベント駆動システムで使われます（例：GUI のイベントリスナー）。",
          "analogy": "店の入り口にセンサーを置いて客が来たら通知する（Observer）のは、どの商品を作るかを決める（Factory Method）話とは別の問題です。"
        }
      },
      {
        "id": "d",
        "text": "Decorator パターン",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "Decorator は既存オブジェクトに動的に機能を追加する構造に関するパターンです。オブジェクトの生成ではなく、生成済みオブジェクトの機能拡張を扱います。",
          "analogy": "コーヒーにトッピングを追加する（Decorator）のは、どの飲み物を作るかを決める（Factory Method）とは別の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "Factory Method パターンはオブジェクトの生成をサブクラスに委任し、クライアントを具体クラスから分離します。GoF の生成パターンの1つで、依存性逆転の原則に基づきます。",
      "keyPoint": "Factory Method = 『生成』のロジックをサブクラスに委ねる。親クラスはインタフェースだけ定義し、具体クラス名をクライアントが知らなくてよい。",
      "relatedTopics": ["デザインパターン", "GoF", "Abstract Factory", "生成パターン", "SOLID原則"],
      "studyTip": "GoF の23パターンは『生成・構造・行動』の3カテゴリで分類を覚えると整理しやすいです。Factory Method は『生成』カテゴリの代表格です。"
    },
    "tags": ["デザインパターン", "GoF", "Factory Method", "オブジェクト指向", "生成パターン"]
  },
  {
    "questionId": "q-ap-055",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "動的計画法の応用",
    "level": 10,
    "question": "フロイド・ウォーシャル（Floyd-Warshall）アルゴリズムで全点対最短経路を求める場合の時間計算量はどれか。ただし、グラフの頂点数を V とする。",
    "choices": [
      {
        "id": "a",
        "text": "O(V^2)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(V^2) はダイクストラ法を1回実行した場合の計算量（優先度付きキュー使用時）に近いですが、全点対最短経路を求めるためには全頂点を始点とした探索が必要で、それ以上の計算量がかかります。",
          "analogy": "街のある1か所から全ての目的地への最短ルートを調べるのが O(V^2) 程度ですが、全ての場所を出発点として調べるにはもっと時間がかかります。"
        }
      },
      {
        "id": "b",
        "text": "O(V^3)",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "フロイド・ウォーシャルアルゴリズムは3重ループで実装されます。外側のループが中継頂点 k（V 回）、内側の2重ループが始点 i と終点 j（V×V 回）で、各ステップは O(1) のため全体で O(V^3) となります。動的計画法の考え方を用い、dp[i][j][k]（頂点 1〜k のみを中継点として使う場合の i→j の最短距離）を漸化的に更新します。",
          "analogy": "V 個の都市間の全ルートを最適化するとき、『中継地点候補』を1つずつ増やしながら（V 通り）、全ての出発地・目的地の組み合わせ（V×V 通り）を確認するイメージです。",
          "deepDive": "フロイド・ウォーシャルは負の辺が存在しても正しく動作しますが、負の閉路（サイクル）があると最短距離が定義できないため注意が必要です。負の閉路の検出は dp[v][v]（自己ループ）が負になるかどうかで判定できます。"
        }
      },
      {
        "id": "c",
        "text": "O(V^2 log V)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(V^2 log V) はダイクストラ法をフィボナッチヒープで実装して全頂点に対して繰り返した場合の計算量に近いですが、フロイド・ウォーシャル自体は単純な3重ループで O(V^3) です。",
          "analogy": "特殊な道具（フィボナッチヒープ）を使えばより速くなる手法もありますが、フロイド・ウォーシャルはシンプルな3重ループなので O(V^3) です。"
        }
      },
      {
        "id": "d",
        "text": "O(V log V)",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "O(V log V) は全点対最短経路問題としては明らかに小さすぎます。全ての頂点の対 O(V^2) を少なくとも1回考慮する必要があるため、V^2 未満の計算量で全点対最短経路を求めることは一般には不可能です。",
          "analogy": "V 個の都市全ての組み合わせを考えるだけで V^2 通りあり、それぞれを調べるためには O(V^3) 以上かかるのが自然です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "フロイド・ウォーシャルアルゴリズムは V 頂点の全点対最短経路を O(V^3) で求めます。3重ループ（中継点 k、始点 i、終点 j）で実装し、負の辺があっても動作します（負サイクルを除く）。",
      "keyPoint": "3重ループ = O(V^3)。中継頂点を1つずつ追加しながら dp テーブルを更新する動的計画法。",
      "relatedTopics": ["グラフアルゴリズム", "動的計画法", "最短経路", "ダイクストラ法", "ベルマン-フォード法"],
      "studyTip": "フロイド・ウォーシャル・ダイクストラ・ベルマンフォードの使い分け（負辺の有無、全点対か単一始点か）を表で整理すると試験に役立ちます。"
    },
    "tags": ["フロイド・ウォーシャル", "最短経路", "動的計画法", "グラフ", "計算量"]
  },
  {
    "questionId": "q-ap-056",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "計算量の理論的下限",
    "level": 10,
    "question": "P クラスと NP クラスに関する説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "NP クラスの問題は多項式時間で解けない問題の集合である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "NP クラスは「多項式時間で検証できる問題の集合」であり、「多項式時間で解けない問題の集合」ではありません。NP 問題が多項式時間で解けないかどうかはまだ未解決（P≠NP 予想）です。",
          "analogy": "NP は『答えが合っているかすぐに確認できる問題』であって、『解くのが絶対に難しい問題』というわけではありません。解きやすいかどうかはまだわかっていません。"
        }
      },
      {
        "id": "b",
        "text": "P クラスは決定性チューリング機械で多項式時間で解ける問題の集合であり、NP クラスは非決定性チューリング機械で多項式時間で解ける（または決定性チューリング機械で多項式時間で検証できる）問題の集合である。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "P（Polynomial time）は決定性チューリング機械で多項式時間で解ける判定問題の集合です。NP（Nondeterministic Polynomial time）は非決定性チューリング機械で多項式時間で解ける問題、同値的に「解の候補が与えられたとき決定性チューリング機械で多項式時間で検証できる」問題の集合です。全ての P 問題は NP 問題でもあります（P ⊆ NP）が、P = NP かどうかは未解決問題です。",
          "analogy": "P は『自力で素早く解ける問題』、NP は『答えを見せてもらえばすぐに正しいか確かめられる問題』に相当します。「自力で解ける問題はすべて答えを確認できる」（P⊆NP）のは明らかですが、逆が成り立つか（NP=P か）は不明です。",
          "deepDive": "NP 完全（NP-complete）問題は NP の中で『最も難しい』問題群です。もし NP 完全問題を多項式時間で1つでも解けると証明できれば P=NP が示されます（現在の予想は P≠NP）。ナップサック問題・巡回セールスマン問題・充足可能性問題（SAT）などが NP 完全です。"
        }
      },
      {
        "id": "c",
        "text": "P = NP はすでに証明されており、全ての NP 問題は多項式時間で解くことができる。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "P = NP は2026年現在も未解決の問題です（クレイ数学研究所のミレニアム懸賞問題の1つ）。現在の主流な予想は P ≠ NP ですが、いずれも証明されていません。",
          "analogy": "『答えをすぐ確認できる問題は必ず素早く解けるか』という問いは、数学の世界最大の謎の1つで、まだ誰も解いていません。"
        }
      },
      {
        "id": "d",
        "text": "NP 困難な問題は必ず NP クラスに属する。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "NP 困難（NP-hard）は『NP の全問題から多項式時間還元できる』問題ですが、NP 困難問題自体が NP に属するとは限りません。停止問題など NP に属さない問題も NP 困難になり得ます（NP 困難 ∩ NP = NP 完全）。",
          "analogy": "『史上最も難しいレベルの問題』（NP困難）と『答えをすぐ確認できる問題』（NP）は別のカテゴリで、難しいからといって必ずしも答えを確認できるとは限りません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "P = 多項式時間で解ける問題。NP = 多項式時間で検証できる問題。P⊆NP は明らかだが P=NP かは未解決。NP 困難は NP に属するとは限らない。",
      "keyPoint": "P=多項式時間で解ける、NP=多項式時間で検証できる（非決定性多項式時間で解ける）。P=NP はミレニアム懸賞問題。",
      "relatedTopics": ["計算量理論", "NP完全", "NP困難", "チューリング機械", "還元"],
      "studyTip": "P・NP・NP完全・NP困難の包含関係（P⊆NP、NP完全⊆NP∩NP困難）をベン図で整理すると理解が深まります。"
    },
    "tags": ["P対NP問題", "計算量理論", "NP完全", "NP困難", "チューリング機械"]
  },
  {
    "questionId": "q-ap-057",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "再帰アルゴリズムの解析",
    "level": 10,
    "question": "末尾再帰（Tail Recursion）の説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "再帰呼び出しが関数の最初の処理として行われる再帰の形式である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "末尾再帰は『最後の処理』が再帰呼び出しである形式です。最初に再帰呼び出しを行う形式は特定の名前を持ちませんが、末尾再帰とは定義が逆です。",
          "analogy": "手紙を渡すバトン（再帰）を『最後に渡す』のが末尾再帰です。『最初に渡す』のとは違います。"
        }
      },
      {
        "id": "b",
        "text": "再帰呼び出しが関数の最後の処理として行われ、コンパイラが末尾呼び出し最適化（TCO）によりスタックを消費しないループに変換できる再帰の形式である。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "末尾再帰とは、再帰呼び出しが関数の最後の操作であり、その後に追加の計算が不要な再帰形式です。コンパイラやインタプリタが末尾呼び出し最適化（TCO: Tail Call Optimization）を適用すると、現在のスタックフレームを再利用して再帰をループに変換できます。これにより O(n) のスタック消費が O(1) になりスタックオーバーフローを防げます。",
          "analogy": "バトンを渡したらすぐ退場できる（自分の仕事は終わり）リレー選手のようなものです。渡した後に追加作業がないので、コーチ（コンパイラ）は『バトン渡し係を並べるのではなく、同じ選手が繰り返し走る』と見なして最適化できます。",
          "deepDive": "Haskell・Scala・Erlang などの関数型言語は TCO を言語仕様で保証しています。Python は（CPython では）TCO を行わないため深い再帰はスタックオーバーフローになります。末尾再帰への変換には累積変数（アキュムレータ）パターンを使うことが多く、例えば fact(n, acc=1) の形にします。"
        }
      },
      {
        "id": "c",
        "text": "再帰呼び出しの深さが常に一定（O(1)）になる再帰の形式である。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "末尾再帰でも再帰の深さは一般に入力サイズ n に依存します（O(n) になる場合があります）。TCO が適用されると結果的にスタック消費が O(1) になりますが、再帰呼び出しの回数が O(1) というわけではありません。",
          "analogy": "バトンを渡す回数（再帰の深さ）は n 回のままですが、コーチが最適化して選手1人が繰り返し走る形に変えることで、スタック（準備する選手数）を O(1) にできるというイメージです。"
        }
      },
      {
        "id": "d",
        "text": "末尾再帰は非末尾再帰と比べて常に計算量が少ない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "末尾再帰は計算量そのものを変えるわけではなく、スタックの使用量（空間計算量）を最適化する手法です。時間計算量は末尾再帰と非末尾再帰で同じになることが多く、「常に計算量が少ない」という記述は誤りです。",
          "analogy": "同じ数のバトンを渡す（計算回数は同じ）が、選手を何人並べるか（スタック使用量）を減らせるのが TCO です。作業の総量は変わりません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "末尾再帰は最後の処理が再帰呼び出しである形式で、TCO によりスタック消費を O(1) にできます。関数型言語で重要な最適化手法です。",
      "keyPoint": "末尾再帰 = 再帰が最後の操作 → TCO によりスタックフレームを再利用できる → スタックオーバーフローを防げる。",
      "relatedTopics": ["再帰", "末尾呼び出し最適化", "関数型プログラミング", "スタック", "コンパイラ最適化"],
      "studyTip": "factorial を末尾再帰で書くと fact(n, acc) = n==0 ? acc : fact(n-1, n*acc) の形になります。acc（アキュムレータ）パターンを覚えましょう。"
    },
    "tags": ["末尾再帰", "TCO", "再帰", "関数型プログラミング", "スタック最適化"]
  },
  {
    "questionId": "q-ap-058",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "オブジェクト指向の多態性・抽象クラス",
    "level": 10,
    "question": "SOLID 原則のうち、リスコフの置換原則（LSP: Liskov Substitution Principle）の説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "クラスは単一の責任のみを持つべきであり、変更の理由は1つだけであるべきである。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは単一責任原則（SRP: Single Responsibility Principle）の説明です。LSP は継承に関する原則であり、クラスの責任の数とは無関係です。",
          "analogy": "「1人1役」（SRP）と「部下は上司の代わりができるべき」（LSP）は別の職場ルールです。"
        }
      },
      {
        "id": "b",
        "text": "スーパークラス（親クラス）のオブジェクトが使われている箇所ならば、サブクラス（子クラス）のオブジェクトに置き換えても正しく動作しなければならない。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "LSP はバーバラ・リスコフが提唱した原則で、「S が T のサブタイプであるならば、T 型のオブジェクトをプログラムで使用するすべての箇所で、S 型のオブジェクトに置き換えてもプログラムの正しさが損なわれてはならない」というものです。LSP を破ると多態性が崩れ、サブクラスを使う際に型チェックが必要になります（instanceof などを使うコードが増える）。有名な違反例は『正方形は長方形を継承すべきでない（幅と高さを独立に変更できないため）』です。",
          "analogy": "役所の受付窓口（親クラス）の担当者が休んだとき、代理の担当者（子クラス）に変わっても来庁者が同じサービスを受けられなければならない、というルールです。代理担当者が「それは私の担当ではない」と言うと規則違反です。",
          "deepDive": "LSP 違反の典型例：Rectangle（長方形）の setWidth/setHeight を独立に設定できる前提で、Square（正方形）を Rectangle のサブクラスにすると、Square では幅を変えると高さも変わってしまい事前条件が強化されます。これは LSP 違反です。設計上は継承より合成（Composition over Inheritance）を使うことで解消できます。"
        }
      },
      {
        "id": "c",
        "text": "ソフトウェアは拡張に対して開いており、修正に対して閉じていなければならない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは開放閉鎖原則（OCP: Open/Closed Principle）の説明です。既存コードを修正せずに新機能を追加できる設計を求める原則で、LSP とは別の原則です。",
          "analogy": "「新しいルールを追加するとき既存のルールブックを書き換えない」（OCP）と「部下が上司の代わりができる」（LSP）は別の職場ポリシーです。"
        }
      },
      {
        "id": "d",
        "text": "クライアントは使用しないインタフェースのメソッドに依存することを強制されるべきでない。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはインタフェース分離の原則（ISP: Interface Segregation Principle）の説明です。太りすぎたインタフェースを分割する原則であり、継承の正しさを問う LSP とは異なります。",
          "analogy": "「使わない仕事は担当させない」（ISP）と「代理担当者は本来の担当者と同じ仕事ができるべき」（LSP）は別のルールです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "LSP はサブクラスを親クラスの代わりに使っても正しく動作することを要求します。違反例として正方形-長方形問題が有名です。SOLID の S・O・L・I・D を順番通り整理しておきましょう。",
      "keyPoint": "LSP = 親の代わりに子を使っても動く。違反するとポリモーフィズムが崩れ isinstance 型チェックが増える。",
      "relatedTopics": ["SOLID原則", "継承", "ポリモーフィズム", "オブジェクト指向設計", "合成"],
      "studyTip": "SOLID 各原則の頭文字と概要をセットで覚えましょう。SRP（1責任）、OCP（拡張開・修正閉）、LSP（代替可能）、ISP（不要依存禁止）、DIP（抽象依存）。"
    },
    "tags": ["SOLID原則", "リスコフの置換原則", "LSP", "継承", "オブジェクト指向設計"]
  },
  {
    "questionId": "q-ap-059",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "デザインパターンの基礎",
    "level": 10,
    "question": "Strategy パターンに関する説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "一連の処理手順をスーパークラスで定義し、各ステップの具体的な実装をサブクラスに委ねるパターンである。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは Template Method パターンの説明です。Strategy パターンは継承ではなく委譲（コンポジション）を使い、アルゴリズム全体をオブジェクトとして差し替えられるようにする点が異なります。",
          "analogy": "レシピの手順を親が決めて子が肉付けするのが Template Method、調理法ごとにシェフ（戦略オブジェクト）を用意して料理人（コンテキスト）が必要に応じ交代させるのが Strategy です。"
        }
      },
      {
        "id": "b",
        "text": "アルゴリズム（処理の方法）をクラスとしてカプセル化し、実行時にアルゴリズムを切り替えられるようにするパターンである。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "Strategy パターンは GoF の行動パターンの1つで、「アルゴリズムのファミリーを定義し、それぞれをカプセル化して交換可能にする」パターンです。Context（使用側）は共通のインタフェースを持つ Strategy オブジェクトに処理を委譲し、実行時に戦略を差し替えられます。継承よりも委譲を使うことで、アルゴリズムの追加・変更が既存コードへの影響を最小化します（OCP に準拠）。",
          "analogy": "カーナビアプリが『最短ルート・最安料金・高速優先』などの経路探索アルゴリズムをボタン一つで切り替えられるのが Strategy パターンです。ナビ本体（Context）のコードを変えずに探索ロジック（Strategy）だけを交換できます。",
          "deepDive": "Strategy と State パターンは構造が似ていますが、目的が異なります。Strategy はクライアントが能動的にアルゴリズムを選択・交換するのに対し、State はオブジェクトの内部状態が変化したときに自動的に振る舞いが変わる点が違います。"
        }
      },
      {
        "id": "c",
        "text": "オブジェクトの内部状態に応じて振る舞いを変化させ、状態遷移をオブジェクトで表現するパターンである。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは State パターンの説明です。Strategy と State は構造が似ていますが、Strategy はクライアントが明示的にアルゴリズムを選ぶのに対し、State はオブジェクト自身が内部状態に応じて振る舞いを変える点が異なります。",
          "analogy": "信号機が赤・青・黄で自動的に振る舞いを変えるのが State パターンで、ドライバーが GPS を最短または最安でマニュアル選択するのが Strategy パターンです。"
        }
      },
      {
        "id": "d",
        "text": "既存のクラスのインタフェースを変換し、別のインタフェースを期待するクライアントと連携できるようにするパターンである。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは Adapter パターン（構造パターン）の説明です。Strategy は既存インタフェースの変換ではなく、アルゴリズムを差し替え可能にする行動パターンです。",
          "analogy": "海外の電源プラグを日本のコンセントに合わせる変換アダプタが Adapter パターンです。Strategy はそもそも複数の電気機器（アルゴリズム）をコンセントに自由に挿し替えられる仕組みです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "Strategy パターンはアルゴリズムをオブジェクトとして定義・カプセル化し、実行時に差し替え可能にする行動パターンです。継承より委譲を使い、OCP に準拠した設計を実現します。",
      "keyPoint": "Strategy = アルゴリズムをオブジェクト化して差し替え可能にする。Context は Strategy インタフェースにのみ依存する。",
      "relatedTopics": ["デザインパターン", "GoF", "行動パターン", "Template Method", "State", "OCP"],
      "studyTip": "Strategy・State・Template Method の3つは混同しやすいので、違いを表で整理しておきましょう。カギは『誰が・いつ・何を切り替えるか』です。"
    },
    "tags": ["デザインパターン", "Strategy", "GoF", "行動パターン", "アルゴリズム切り替え"]
  },
  {
    "questionId": "q-ap-060",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "algorithm-programming",
    "topic": "関数型プログラミングの概念",
    "level": 10,
    "question": "関数型プログラミングにおける「高階関数（Higher-Order Function）」の説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "処理速度が最適化された、実行効率の高い関数のことである。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「高階」は処理速度や効率とは無関係です。高階関数は関数を引数として受け取るか、戻り値として返す関数のことを指す数学・プログラミング用語です。",
          "analogy": "「高級レストラン」が食材（関数）を取り扱う場所を指すのではなく、料理人（関数）を雇う（引数として受け取る）レストランが高階関数の比喩です。"
        }
      },
      {
        "id": "b",
        "text": "関数を引数として受け取るか、あるいは関数を戻り値として返す関数のことである。",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "高階関数（Higher-Order Function）は、数学の高階微分と同様に「関数を操作する関数」です。具体的には以下のどちらかまたは両方を満たします。①関数を引数として受け取る（例：map, filter, reduce/fold）②関数を戻り値として返す（例：カリー化、クロージャを返す関数）。関数型プログラミングでは関数が第一級市民（First-Class Citizen）として扱われるため、関数を値と同様に渡したり返したりできます。",
          "analogy": "料理教室（高階関数）は『レシピ（関数）を引数として受け取り、そのレシピで作った料理（新しい関数）を返す』仕組みです。具体的な料理の内容（引数）を気にせず、料理の仕方（関数）そのものを扱います。",
          "deepDive": "代表的な高階関数：map（各要素に関数を適用）・filter（条件を満たす要素を抽出）・reduce（要素を集約）。カリー化（Currying）は多引数関数を高階関数で1引数関数の連鎖に変換します。JavaScript・Python・Haskell・Scala などで広くサポートされています。"
        }
      },
      {
        "id": "c",
        "text": "再帰を使わずに反復（ループ）で実装された関数のことである。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "高階関数は実装方法（再帰かループか）とは無関係です。関数を引数として受け取るかどうかが定義の核心です。再帰・反復はいずれの実装スタイルも高階関数にも非高階関数にも使えます。",
          "analogy": "料理教室（高階関数）の定義は『教え方』（再帰かループか）ではなく、『他の料理人（関数）を雇えるか』という点にあります。"
        }
      },
      {
        "id": "d",
        "text": "副作用のない純粋関数のことであり、同じ入力には常に同じ出力を返す。",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは純粋関数（Pure Function）の説明です。高階関数は純粋関数でも非純粋関数でもあり得ます。「副作用なし」という性質は高階関数の定義要件ではありません。",
          "analogy": "料理教室（高階関数）は健康的な食材を使う（副作用なし = 純粋関数）かどうかとは関係なく、『他の料理人を雇えるか』で定義されます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "高階関数は関数を引数として受け取るか、戻り値として返す関数です。map・filter・reduce が代表例で、関数型プログラミングの核心的な概念です。",
      "keyPoint": "高階関数 = 関数を引数に取るか、関数を返す関数。関数を第一級市民として扱う関数型プログラミングの基礎。",
      "relatedTopics": ["関数型プログラミング", "純粋関数", "カリー化", "クロージャ", "map/filter/reduce"],
      "studyTip": "JavaScript の [1,2,3].map(x => x*2) がまさに高階関数です。map が関数（x => x*2）を引数として受け取っている実例として覚えましょう。"
    },
    "tags": ["関数型プログラミング", "高階関数", "map", "filter", "reduce", "第一級関数"]
  }
]
