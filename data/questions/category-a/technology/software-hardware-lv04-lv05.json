[
  {
    "questionId": "q-sh-016",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "software-hardware",
    "topic": "タスクの状態遷移",
    "level": 4,
    "question": "OSのタスク管理におけるタスクの状態遷移として最も適切なものはどれか。ここでタスクの状態は「実行中」「実行可能」「待ち」の3種類とする。",
    "choices": [
      {
        "id": "a",
        "text": "「実行中」状態のタスクがI/O待ちになると、直接「実行可能」状態に遷移する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "I/O待ちが発生したタスクは「実行可能」ではなく「待ち（ブロック）」状態に遷移します。「実行可能」状態はCPUを使う準備が整っているがCPUに割り当てられていない状態であり、I/O完了などのイベントを待っている「待ち」状態とは異なります。",
          "analogy": "レストランで料理を注文した後（I/O発行後）、お客さんはカウンターの前で待機（実行可能）するのではなく、席に座って料理を待ちます（待ち状態）。料理が来てからはじめてカウンターに呼ばれる（実行可能）状態になります。"
        }
      },
      {
        "id": "b",
        "text": "「待ち」状態のタスクは、待ち原因が解消されると「実行可能」状態に遷移し、スケジューラによって「実行中」状態に遷移する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "タスクの状態遷移の正しい流れは次の通りです。「実行中」→（I/O発行やイベント待ちで）→「待ち」→（I/O完了などで）→「実行可能」→（CPUが割り当てられると）→「実行中」。「待ち」から直接「実行中」にはなれず、必ず「実行可能」を経由します。",
          "analogy": "タスクは列に並ぶ客のようなものです。料理（I/O）を頼んでいる間は席で待ち（待ち状態）、料理が来たら順番待ちの列に並び直します（実行可能）。店員（CPU）が空いたときに呼ばれてはじめてサービスを受けられます（実行中）。「待ち」から直接サービスは受けられません。",
          "deepDive": "3状態モデルの遷移まとめ：①実行中→待ち：I/O発行、セマフォのP操作（資源待ち）、スリープなど。②待ち→実行可能：I/O完了割り込み、セマフォのV操作、タイマー満了など。③実行中→実行可能：タイムスライス切れ、より優先度の高いタスクが実行可能になった場合（プリエンプション）。④実行可能→実行中：スケジューラがCPUを割り当てる（ディスパッチ）。この4種類の遷移を正確に覚えることがポイントです。"
        }
      },
      {
        "id": "c",
        "text": "「実行可能」状態のタスクは、タイムスライスが終了すると「待ち」状態に遷移する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "タイムスライスが終了したタスクは「待ち」ではなく「実行可能」状態に戻ります。タイムスライス切れはI/O待ちなどのイベント待ちとは異なり、すぐに再びCPUを使える状態であるため「待ち」にはなりません。「待ち」はI/O完了などの外部イベントを待つ状態です。",
          "analogy": "お客さんが制限時間（タイムスライス）でレジから離れた場合、列の最後尾に並び直します（実行可能）。病院の診察待ちのように検査結果が来るまで待つ（待ち）とは違います。タイムスライス切れはあくまで「もう少し待ってください」であって「何かが完了するまで待機」とは異なります。"
        }
      },
      {
        "id": "d",
        "text": "「実行中」状態のタスクは、タイムスライスが終了すると「待ち」状態に遷移し、次回のスケジューリングで「実行可能」状態になる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "タイムスライス切れの遷移先は「実行可能」状態であり、「待ち」状態ではありません。「待ち→実行可能」の遷移はI/O完了などの外部イベント通知によって起こります。タイムスライス切れは「待ち状態」を経由せず直接「実行可能」に遷移するのが正しい動作です。",
          "analogy": "持ち時間（タイムスライス）が終わった将棋棋士は、「考え中（待ち）」になるのではなく「次の番を待つ（実行可能）」状態になります。考え中になるのは相手の手番を待つとき（I/O待ち）です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "タスクの3状態（実行中・実行可能・待ち）の遷移を正確に理解することが重要です。I/O待ちで「実行中→待ち」、I/O完了で「待ち→実行可能」、ディスパッチで「実行可能→実行中」、タイムスライス切れで「実行中→実行可能」です。",
      "keyPoint": "「待ち」から直接「実行中」にはなれない。タイムスライス切れの遷移先は「待ち」ではなく「実行可能」。",
      "relatedTopics": [
        "プロセススケジューリング",
        "タイムスライス",
        "ディスパッチャ",
        "プリエンプション",
        "I/O割り込み"
      ],
      "studyTip": "状態遷移図を書いて覚えましょう。矢印の方向と条件（誰が引き起こすか：OSかI/Oか）を意識するのがコツです。「実行中→待ち→実行可能→実行中」の一方通行のループを基本として押さえてください。"
    },
    "tags": ["タスク状態遷移", "プロセス管理", "スケジューリング", "実行可能", "待ち状態"]
  },
  {
    "questionId": "q-sh-017",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "software-hardware",
    "topic": "ページフォールト",
    "level": 4,
    "question": "仮想記憶のページング方式において、ページフォールトが発生する条件として正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "アクセスしようとしたページが主記憶（物理メモリ）に存在しないとき",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ページフォールトは、プロセスがアクセスしようとした仮想ページが現時点で主記憶に存在しない（補助記憶にスワップアウトされているか、まだロードされていない）場合に発生するハードウェア例外です。OSはページフォールト割り込みを受け取り、必要なページを補助記憶から主記憶に読み込むページイン処理を行います。",
          "analogy": "図書館で読みたい本（ページ）を取り出そうとしたら、その本が他の利用者に貸し出し中（スワップアウト）で棚にないときに「本が見つかりません（ページフォールト）」が発生します。司書（OS）が本を倉庫から取り寄せて棚に戻してくれます。",
          "deepDive": "ページフォールトの処理手順：①CPUがページテーブルのPresent（存在）ビットが0のエントリにアクセス→ページフォールト例外発生。②OSのページフォールトハンドラが起動。③必要に応じて主記憶の空きページを確保（なければ既存ページをスワップアウト）。④補助記憶から必要ページをスワップイン。⑤ページテーブルのPresent ビットを1に更新。⑥フォールトした命令を再実行。ページフォールトが多発するとスラッシングという性能劣化が起こります。"
        }
      },
      {
        "id": "b",
        "text": "アクセスしようとしたページが書き込み禁止属性のとき",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "書き込み禁止属性のページへの書き込みアクセスは「プロテクションフォールト（保護例外）」が発生しますが、ページフォールトとは異なります。ページフォールトは「主記憶にページが存在しない」ことが原因で発生する例外です。",
          "analogy": "「図書館の本が館内限定で持ち出し禁止（書き込み禁止）」のときに発生するエラーは「持ち出し規則違反（プロテクションフォールト）」です。「本がそもそも棚にない（ページフォールト）」とは原因が違います。"
        }
      },
      {
        "id": "c",
        "text": "CPUのTLBにアドレス変換情報が存在しないとき",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "TLBにエントリが存在しない（TLBミス）ことはページフォールトとは異なります。TLBミス時はページテーブルを参照してアドレス変換情報を補充（TLBウォーク）するだけで、ページが主記憶に存在すれば通常のアクセスが完了します。ページフォールトはページ自体が主記憶に存在しないときの例外です。",
          "analogy": "手帳（TLB）に本の場所メモがない（TLBミス）のは、図書館の棚一覧（ページテーブル）を改めて確認すれば解決します。しかし棚一覧を見ても本自体が存在しない（ページフォールト）のは別の問題です。"
        }
      },
      {
        "id": "d",
        "text": "アクセスしようとした主記憶のアドレスが仮想アドレス空間の範囲外のとき",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "仮想アドレス空間の範囲外へのアクセスは「セグメンテーション違反（Segmentation Fault）」と呼ばれる例外が発生します。ページフォールトは有効な仮想アドレスに対してそのページが主記憶に存在しないときに発生するものです。",
          "analogy": "存在しない番号（仮想アドレス範囲外）に電話するのは「そんな番号はない（セグメンテーション違反）」エラーです。電話番号は正しいが相手が一時的に圏外（スワップアウト）の場合が「ページフォールト」に当たります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ページフォールトはアクセスしたい仮想ページが現在主記憶に存在しない（スワップアウトされている）ときに発生するハードウェア例外です。OSが割り込みを受けてページインを行います。",
      "keyPoint": "ページフォールト＝ページが主記憶に存在しないときの例外。TLBミスやプロテクション違反とは区別すること。",
      "relatedTopics": [
        "仮想記憶",
        "ページング",
        "スワップ（スワップアウト/スワップイン）",
        "TLBミス",
        "スラッシング"
      ],
      "studyTip": "「フォールト＝不在」と覚えましょう。ページが主記憶から「不在」になっていることが原因です。TLBミスはアドレス変換情報の不在、ページフォールトはページデータ本体の不在、と区別して覚えてください。"
    },
    "tags": ["ページフォールト", "仮想記憶", "ページング", "スワップ", "例外処理"]
  },
  {
    "questionId": "q-sh-018",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "software-hardware",
    "topic": "セマフォと排他制御",
    "level": 4,
    "question": "バイナリセマフォを用いた排他制御において、共有資源にアクセスするプロセスが実行すべき操作の順序として正しいものはどれか。ここでP操作はセマフォ値を1減らす（0なら待機）、V操作はセマフォ値を1増やす（待機中のプロセスを1つ起こす）とする。",
    "choices": [
      {
        "id": "a",
        "text": "V操作 → 共有資源へのアクセス → P操作",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは順序が逆です。V操作は「資源を解放する」操作であり、アクセス前ではなく後に行います。P操作を先に行って「資源を獲得・ロック」してから共有資源にアクセスし、終わったらV操作で「解放・アンロック」するのが正しい手順です。",
          "analogy": "お手洗い（共有資源）を使うとき、「使い終わった（V操作）→ 入る → 使い終わった（P操作）」は意味をなしません。「空き確認・施錠（P操作）→ 使用（アクセス）→ 解錠・退出（V操作）」が正しい順序です。"
        }
      },
      {
        "id": "b",
        "text": "P操作 → 共有資源へのアクセス → V操作",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "排他制御の正しい手順はP操作（資源獲得）→共有資源アクセス→V操作（資源解放）です。P操作でセマフォ値が1から0になり他のプロセスはP操作でブロックされます。アクセス終了後のV操作でセマフォ値が1に戻り、待機中のプロセスが1つ起こされます。これによりいつでも1つのプロセスだけが共有資源にアクセスできる相互排除を実現します。",
          "analogy": "共有のトイレ（共有資源）の正しい使い方です。P操作＝「空き表示を確認してドアを施錠（ロック）」、利用＝「用を足す（共有資源へのアクセス）」、V操作＝「ドアを解錠して空きにする（解放）」。施錠する前に入ったり、解錠する前に出たりしたら排他できません。",
          "deepDive": "P操作はDijkstraのオランダ語「Proberen（試みる）」、V操作は「Verhogen（増やす）」の頭文字です。バイナリセマフォ（値が0か1の2値）は相互排除（Mutual Exclusion）に使います。カウンティングセマフォ（値がN以上）はN個の資源の管理（例：N席の駐車場の空き管理）に使います。P操作とV操作は必ずペアで実装しなければ、V操作が漏れるとデッドロック、P操作が漏れると排他が崩れます。"
        }
      },
      {
        "id": "c",
        "text": "P操作 → V操作 → 共有資源へのアクセス",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "P操作の直後にV操作を行うと、アクセス前に資源を解放してしまいます。これでは排他制御の意味がなく、P操作とV操作の間に別プロセスが共有資源にアクセスできてしまいます。V操作は共有資源へのアクセスが完全に終了した後に行う必要があります。",
          "analogy": "トイレに入ってすぐにドアを解錠（V操作）したまま用を足すのは、他の人が入ってこられる状態で使うことになります。ドアは用を全部足し終えてから解錠するべきです。"
        }
      },
      {
        "id": "d",
        "text": "共有資源へのアクセス → P操作 → V操作",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "先に共有資源にアクセスしてからP操作するのでは、排他制御の意味がまったくありません。P操作（ロック）の前に共有資源を使用してしまうと、複数プロセスが同時に共有資源にアクセスする競合状態（レースコンディション）が発生します。",
          "analogy": "トイレに入って用を足してから鍵を掛けるのは、鍵を掛ける前に他の人も入れてしまいます。入る前に鍵を確認・施錠するのが正しい手順です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "セマフォを使った排他制御の手順は「P操作（ロック）→共有資源アクセス→V操作（アンロック）」です。P操作で他のプロセスをブロックし、V操作で解放します。",
      "keyPoint": "P操作＝資源獲得・ロック（値を減らす、0なら待機）。V操作＝資源解放・アンロック（値を増やす、待機プロセスを起こす）。必ずP→アクセス→Vの順。",
      "relatedTopics": [
        "セマフォ",
        "相互排除（ミューテックス）",
        "排他制御",
        "デッドロック",
        "クリティカルセクション"
      ],
      "studyTip": "「P=Pickup（取る）、V=Vacancy（返す）」のイメージで覚えましょう。P操作で資源を取ってからアクセスし、V操作で資源を返すという流れです。"
    },
    "tags": ["セマフォ", "排他制御", "P操作", "V操作", "相互排除"]
  },
  {
    "questionId": "q-sh-019",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "software-hardware",
    "topic": "ディスクスケジューリング",
    "level": 4,
    "question": "ハードディスクのディスクスケジューリングに関する説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "FCFS（First Come First Served）は到着順にリクエストを処理するため、ヘッドの移動量が最小になる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "FCFSはリクエストの到着順に処理するため、ヘッドが行ったり来たりする可能性が高く、ヘッド移動量は最小にはなりません。ヘッド移動量を最小化しようとするのはSSTF（Shortest Seek Time First）です。FCFSは公平性は高いですが効率は低いアルゴリズムです。",
          "analogy": "エレベーターが来た順に行先ボタンを処理するFCFSは、1階→10階→2階→9階のように無駄な上下移動が多発します。近いフロアからまとめて処理するSSTFの方がはるかに移動距離が短くなります。"
        }
      },
      {
        "id": "b",
        "text": "SSTF（Shortest Seek Time First）は最もシーク時間が短いリクエストを優先するため、特定のリクエストがいつまでも処理されない飢え（スタベーション）が発生することがある",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "SSTFは現在のヘッド位置から最も近いシリンダのリクエストを優先的に処理するため、全体的なヘッド移動量は少なくなります。しかし、ヘッドから遠い位置にあるリクエストは、常により近いリクエストが来るたびに後回しにされ、長時間待たされるスタベーション（飢え）が発生することがあります。",
          "analogy": "「最寄りのお客さんから先にサービスする」ウェイターは効率的ですが、遠くのテーブルのお客さんはずっと待たされます。近くに次々と新しいお客さんが来れば、遠くのお客さんはいつまでも後回しにされます（スタベーション）。",
          "deepDive": "主なディスクスケジューリングアルゴリズムの比較：①FCFS：到着順、公平だが非効率。②SSTF：最近傍優先、スループット高いがスタベーションあり。③SCAN（エレベーターアルゴリズム）：ヘッドを一方向に動かし端まで行ったら折り返す、スタベーションなし。④C-SCAN：SCANの一方向版（折り返さず端から始端に戻る）、待ち時間が均一化。現代のOSではC-SCANやその派生が使われることが多いです。"
        }
      },
      {
        "id": "c",
        "text": "SCAN（エレベーターアルゴリズム）では、ヘッドは常にディスクの中央付近で往復するため、端のシリンダのアクセスが遅くなる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "SCANでは、ヘッドはディスクの端（最外周または最内周）まで移動してから向きを変えます。「中央付近で往復」するのではなく、端から端へ往復します。端のシリンダへのアクセスが遅くなるのはSCANでもある程度起こりますが、それはヘッドが折り返し直後の場合で、端まで到達したら確実にサービスされます。",
          "analogy": "エレベーターは最上階または最下階まで行ってから折り返します。「5階と6階の間だけを往復する」わけではありません。SCAN方式のエレベーターは1階→10階→1階と端から端へ移動します。"
        }
      },
      {
        "id": "d",
        "text": "ディスクスケジューリングは主記憶のページング処理を最適化するためのアルゴリズムである",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ディスクスケジューリングはハードディスクのヘッドの移動順序を最適化し、I/Oスループットを向上させる技術です。主記憶のページング処理の最適化とは無関係です。ページング処理の最適化はページ置換アルゴリズム（LRU、FIFOなど）が担当します。",
          "analogy": "ディスクスケジューリングは「どの順番でHDDのヘッドを動かすか」の最適化です。主記憶のページング（どのページを主記憶から追い出すか）は全く別の最適化問題です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ディスクスケジューリングはHDDのヘッド移動を最適化する技術です。FCFS（到着順・公平）、SSTF（最近傍優先・高効率だがスタベーションあり）、SCAN（エレベーター方式・スタベーションなし）の特徴を押さえましょう。",
      "keyPoint": "SSTF＝効率良いがスタベーションのリスクあり。SCAN＝端から端への往復でスタベーションなし。FCFSは公平だが効率が低い。",
      "relatedTopics": [
        "FCFS（先着順）",
        "SSTF（最短シーク時間優先）",
        "SCANアルゴリズム",
        "C-SCAN",
        "スタベーション（飢え）"
      ],
      "studyTip": "ディスクスケジューリングはエレベーターに例えると覚えやすいです。SSTF＝「一番近いボタンを押したお客さんを優先」、SCAN＝「エレベーターが1階と最上階を行き来する普通の動作」と覚えましょう。"
    },
    "tags": ["ディスクスケジューリング", "FCFS", "SSTF", "SCAN", "スタベーション"]
  },
  {
    "questionId": "q-sh-020",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "software-hardware",
    "topic": "組み込みOS・リアルタイムOS",
    "level": 4,
    "question": "リアルタイムOS（RTOS）の特徴として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "汎用OSと同様に、スループット（単位時間あたりの処理量）の最大化を最優先の設計目標とする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "リアルタイムOSの設計目標はスループットの最大化ではなく、「決められた時間内に処理を完了すること（デッドライン保証）」です。スループット最大化を優先するのは汎用OSや高性能コンピューティングのOSの考え方です。RTOSではたとえ効率が下がっても、デッドライン内の応答を保証することを優先します。",
          "analogy": "救急車（RTOS）は「一日に最も多くの患者を搬送すること（スループット）」ではなく、「緊急の患者を決められた時間内に病院に届けること（デッドライン保証）」を最優先とします。"
        }
      },
      {
        "id": "b",
        "text": "処理要求に対して一定時間内（デッドライン）に必ず応答することを保証するOSであり、工場の制御システムや医療機器などに使われる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "リアルタイムOS（RTOS）はデッドライン（処理の期限）内に処理を完了することを保証するOSです。ハードリアルタイム（デッドライン超過が致命的、例：エアバッグ制御）とソフトリアルタイム（デッドライン超過は許容できるが品質が下がる、例：動画再生）があります。μITRON、VxWorks、FreeRTOSなどが代表的なRTOSです。",
          "analogy": "工場のロボットアーム制御（RTOS）は「100ミリ秒以内に次の位置に動く」という厳格な時間制約があります。遅れると製品が不良品になったり機械が壊れたりします。Webサーバー（汎用OS）は少し応答が遅れても大きな問題ではありません。",
          "deepDive": "RTOSの主な特徴：①決定論的なスケジューリング（優先度ベースのプリエンプティブスケジューリング）②タスク切り替えの低レイテンシ③優先度逆転の防止機構（優先度継承プロトコルなど）④小さなメモリフットプリント。代表的な用途：自動車のECU（エンジン制御ユニット）、航空機の飛行制御、医療機器、産業用ロボット、宇宙機器。優先度逆転（低優先度タスクが資源を保持したまま高優先度タスクをブロックする問題）はFireの宇宙探査機の制御ソフトウェア（VxWorks）で実際に問題となった有名な事例があります。"
        }
      },
      {
        "id": "c",
        "text": "複数のユーザーが同時にシステムを使えるタイムシェアリングを実現するOSであり、各ユーザーへの応答時間を公平に分配する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "タイムシェアリングは複数ユーザーに公平にCPU時間を分配する汎用OSの機能です。リアルタイムOSでは「公平な時間分配」よりも「優先度に基づく処理保証」を重視します。RTOSは通常、単一タスクまたは少数のタスクをリアルタイム制約のもとで制御するために使われます。",
          "analogy": "タイムシェアリングは「図書館の閲覧席を全員に順番に公平に貸し出す」仕組みです。RTOSは「緊急手術室の予約を優先度で管理し、重篤な患者には必ず指定時間内に部屋を確保する」仕組みです。公平さより優先度・時間保証が重要です。"
        }
      },
      {
        "id": "d",
        "text": "メモリ容量の制約がないため、汎用OSと比較して豊富な機能と多数のデバイスドライバを搭載できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "リアルタイムOSは多くの場合、組み込みシステム（マイコンなど）に搭載されるため、メモリや処理性能の制約が厳しいです。汎用OSと比べてはるかにコンパクトで、機能を必要最小限に絞っています。豊富な機能・多数のドライバを搭載するのは汎用OSの特徴です。",
          "analogy": "RTOSは特定の目的（工場の機械制御など）のために作られたシンプルな制御システムです。汎用OSはあらゆる用途に対応できる多機能なOSです。小型で高速に動くRTOSは、機能が多い汎用OSより制約の厳しい環境に向いています。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "リアルタイムOS（RTOS）はデッドライン内に処理を完了することを保証するOSです。工場・医療・自動車などの組み込み制御に使われます。スループット最大化ではなくデッドライン保証が設計目標です。",
      "keyPoint": "RTOS＝デッドライン保証・優先度ベーススケジューリング・低レイテンシ・小メモリフットプリント。汎用OSとの最大の違いは「時間制約の保証」。",
      "relatedTopics": [
        "ハードリアルタイム",
        "ソフトリアルタイム",
        "優先度逆転",
        "組み込みシステム",
        "μITRON"
      ],
      "studyTip": "「リアルタイム＝高速」ではなく「リアルタイム＝時間を守る（デッドライン保証）」と覚えましょう。処理が多少遅くても時間内に終わることが重要なのがRTOSです。"
    },
    "tags": ["リアルタイムOS", "RTOS", "デッドライン", "組み込みシステム", "優先度スケジューリング"]
  },
  {
    "questionId": "q-sh-021",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "software-hardware",
    "topic": "デッドロックの条件と回避",
    "level": 5,
    "question": "デッドロックが発生する必要条件として知られるコフマンの4条件のうち誤っているものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "相互排除（Mutual Exclusion）：資源は一度に1つのプロセスしか使用できない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "相互排除はコフマンの4条件のうちの一つで、正しい記述です。資源が複数のプロセスに同時に使われないという性質（排他性）がデッドロックの必要条件の一つです。これを取り除けばデッドロックは発生しませんが、データ一貫性のために排他制御が必要な場合が多く、この条件を外すことは難しいです。",
          "analogy": "プリンタ（資源）は1つの書類を印刷中には他の書類を印刷できない（相互排除）という性質があります。これは印刷結果をきれいに出すための必要な制約です。"
        }
      },
      {
        "id": "b",
        "text": "占有と待機（Hold and Wait）：資源を保持しつつ、別の資源を待ち続ける",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "占有と待機はコフマンの4条件のうちの一つで、正しい記述です。プロセスが一部の資源を確保したまま、まだ確保できていない別の資源を待ち続けることがデッドロックの必要条件の一つです。これを防ぐには「必要な資源を一度にすべて確保する（資源の一括割り当て）」という方法があります。",
          "analogy": "Aさんがはさみとテープのうちはさみだけを持ち（占有）、Bさんが持つテープを待っている（待機）状態です。Bさんもテープとはさみのうちテープだけを持ってAさんのはさみを待っていれば、お互い待ち続けてデッドロックになります。"
        }
      },
      {
        "id": "c",
        "text": "プリエンプション可能（Preemption）：保持している資源を強制的に取り上げることができる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "コフマンの4条件の3つ目は「非プリエンプション（No Preemption）：保持している資源は強制的に取り上げられない（プロセスが自発的に解放するまで保持し続ける）」です。「プリエンプション可能」という記述は正反対であり、これはデッドロックの発生条件ではなく、むしろデッドロックを防ぐための条件です。本問は「誤っているもの」を問うており、この選択肢が誤りです。",
          "analogy": "デッドロックが起きる状況では「一度借りた資源（図書館の本）は他の人には強制的に取り上げられない」という条件が成り立ちます。もし強制的に取り上げられる（プリエンプション可能）なら、膠着状態が解消されるためデッドロックは起きません。",
          "deepDive": "コフマンの4条件（全部そろうとデッドロックが発生しうる）：①相互排除（Mutual Exclusion）：資源は排他的に使用。②占有と待機（Hold and Wait）：資源を保持しながら別の資源を待つ。③非プリエンプション（No Preemption）：保持資源は強制的に取り上げられない。④循環待機（Circular Wait）：プロセスの資源待ちが循環している。デッドロック対策：どれか1条件を取り除けばデッドロックは発生しない。循環待機を防ぐには「資源に番号をつけて昇順にのみ資源を獲得する」という方法が有効です。"
        }
      },
      {
        "id": "d",
        "text": "循環待機（Circular Wait）：資源の待ち関係がプロセス間で循環している",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "循環待機はコフマンの4条件のうちの一つで、正しい記述です。プロセスA→B→C→Aのように資源の待ち関係が輪になっている状態がデッドロックの必要条件の一つです。これを防ぐには「資源に通し番号をつけて昇順にのみ獲得できる」ルールを設けることが有効です。",
          "analogy": "AさんがBさんのハサミを待ち、BさんがCさんのテープを待ち、CさんがAさんのノリを待つという「鬼ごっこのように誰も動けない輪（循環待機）」がデッドロックの典型的な状況です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "コフマンの4条件は「相互排除・占有と待機・非プリエンプション・循環待機」の4つです。「非プリエンプション（強制取り上げ不可）」が正しい条件であり、「プリエンプション可能」は誤りです。",
      "keyPoint": "デッドロックの4条件：①相互排除②占有と待機③非プリエンプション（取り上げ不可）④循環待機。どれか1つを取り除けばデッドロックは発生しない。",
      "relatedTopics": [
        "デッドロック",
        "コフマンの4条件",
        "デッドロック回避",
        "銀行家アルゴリズム",
        "資源割り当てグラフ"
      ],
      "studyTip": "「相・占・非・循」と4文字で覚えましょう。特に「非プリエンプション」は「プリエンプション不可」つまり「強制取り上げができない」という意味で、これを誤って「プリエンプション可能」と覚えないよう注意が必要です。"
    },
    "tags": ["デッドロック", "コフマンの4条件", "相互排除", "循環待機", "非プリエンプション"]
  },
  {
    "questionId": "q-sh-022",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "software-hardware",
    "topic": "ページ置換アルゴリズム",
    "level": 5,
    "question": "仮想記憶のページ置換アルゴリズムに関して、ページフォールトが最も少なくなることが理論的に証明されているアルゴリズムはどれか。ただし、このアルゴリズムは現実のシステムには実装できない。",
    "choices": [
      {
        "id": "a",
        "text": "FIFO（先入れ先出し）：最も古く主記憶に存在するページを置換する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "FIFOはページを存在した時間（古さ）に基づいて置換するシンプルなアルゴリズムですが、最適ではありません。最も古いページが今後も頻繁に参照される可能性があり、ページフォールトが増えることがあります。またFIFOには「主記憶フレーム数を増やすとページフォールトが増えることがある」ベラディの異常という奇妙な現象が存在します。",
          "analogy": "FIFO方式の本棚は「一番先に入れた本（古い本）から捨てる」方式です。その古い本を頻繁に使っていても捨ててしまいます。いつもよく使う本が捨てられるとまた取りに行く手間（ページフォールト）が増えます。"
        }
      },
      {
        "id": "b",
        "text": "LRU（Least Recently Used）：最後に参照されてから最も時間が経過したページを置換する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "LRUは「最近最も使われていないページ」を置換するアルゴリズムで、実用的かつ優れたアルゴリズムです。しかし理論的に最適（ページフォールト最小）であることは証明されていません。現実に実装可能な中では最も優れた部類に入りますが、理論的最適アルゴリズムとは異なります。",
          "analogy": "LRUは「最近使っていない本から捨てる」方式です。「過去の行動」を参照するLRUに対し、最適アルゴリズムは「未来の参照情報」を使って判断します。過去情報では完璧な判断はできません。"
        }
      },
      {
        "id": "c",
        "text": "OPT（最適アルゴリズム/Belady's Optimal）：今後最も長い間参照されないページを置換する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "OPT（最適ページ置換アルゴリズム）はBeladyが提案したもので、「将来最も長い間参照されないページ」を置換します。これは理論的にページフォールトを最小にすることが証明されています。ただし将来のページ参照順序を事前に知る必要があるため、現実のOSには実装できません。他のアルゴリズムの評価基準（比較の上限）として使われます。",
          "analogy": "「これから1ヶ月間全く読まない本から順番に捨てる」方式が最適（OPT）です。未来が見えれば最も無駄のない選択ができます。しかし実際は未来は見えないので、LRU（最近使っていない本から捨てる）という次善策を使います。",
          "deepDive": "主なページ置換アルゴリズムの比較：①OPT：理論的最小フォールト・現実実装不可・評価基準として利用。②LRU：時間順管理（スタックかカウンタで実装）・良好な性能・ハードウェアサポートが必要。③FIFO：実装が最も簡単・ベラディの異常が存在。④Clock（第2チャンスアルゴリズム）：参照ビットを使ったFIFOの改良版・LRUの近似・実用的。Linuxなどの実際のOSではClockアルゴリズムの変形が多く使われています。"
        }
      },
      {
        "id": "d",
        "text": "LFU（Least Frequently Used）：参照回数が最も少ないページを置換する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "LFUは参照頻度（回数）が最も少ないページを置換するアルゴリズムです。初期に多く参照されたが現在は使われなくなったページが残り続けるという問題があります。理論的に最適であることは証明されておらず、現実に実装できないという制約もありません（実装はできます）。",
          "analogy": "LFUは「これまでの読んだ回数が少ない本から捨てる」方式です。昔はよく読んだが今は読まない本（歴史的人気がある）を残してしまいます。現在の使用状況をうまく反映できないため最適ではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "理論的に最小のページフォールト数を達成するのはOPT（最適アルゴリズム）です。将来の参照順序の知識が必要で実装不可ですが、他アルゴリズムの評価基準として用いられます。実用アルゴリズムとしてはLRUが広く使われます。",
      "keyPoint": "OPT＝理論的最適・実装不可。LRU＝実用的最良・過去参照情報を使用。FIFO＝最も単純・ベラディの異常あり。Clock＝LRUの実用的近似。",
      "relatedTopics": [
        "ページ置換アルゴリズム",
        "LRU（最近最少使用）",
        "FIFO",
        "ベラディの異常",
        "スラッシング"
      ],
      "studyTip": "「OPT＝未来を使う理想形・実装不可」「LRU＝過去を使う現実解・実用的」と対比して覚えましょう。試験では「理論的に最適だが実装できないアルゴリズム」はOPTと答えることを押さえてください。"
    },
    "tags": ["ページ置換アルゴリズム", "OPT", "LRU", "FIFO", "仮想記憶"]
  },
  {
    "questionId": "q-sh-023",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "software-hardware",
    "topic": "ファイルシステムのi-node",
    "level": 5,
    "question": "UNIX系OSのファイルシステムにおけるi-node（iノード）の説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ファイルの名前とファイルの実データを対応付けるために使用される構造体である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ファイル名とi-nodeを対応付けるのはディレクトリエントリの役割です。ディレクトリはファイル名→i-node番号のマッピングを保持します。i-node自体はファイル名を持たず、メタデータとデータブロックの位置を保持します。ファイル名はディレクトリのみが知っており、i-nodeは知りません。",
          "analogy": "i-nodeは本の「中身の情報（著者・ページ数・保管場所）」を持つカードです。本の「タイトル（ファイル名）」はカタログ（ディレクトリ）に書いてあり、カードそのものには書かれていません。"
        }
      },
      {
        "id": "b",
        "text": "ファイルのメタデータ（所有者・パーミッション・タイムスタンプ・ファイルサイズ・データブロックの位置など）を格納する構造体である",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "i-nodeはUNIXファイルシステムにおける重要なデータ構造で、1ファイルにつき1つのi-nodeが割り当てられます。i-nodeには所有者（UID/GID）・パーミッション（読み/書き/実行）・タイムスタンプ（作成/アクセス/変更時刻）・ファイルサイズ・ハードリンク数・データブロックへのポインタ群などのメタデータが含まれます。ファイル名はディレクトリエントリが保持し、i-node自体には含まれません。",
          "analogy": "i-nodeは本の「書誌情報カード（著者・出版社・ページ数・保管場所・貸出状態）」に相当します。図書館のカタログ（ディレクトリ）がタイトル（ファイル名）と書誌情報カード番号（i-node番号）を結びつけ、書誌情報カードが本の実物の保管場所（データブロック位置）を指し示します。",
          "deepDive": "i-nodeのデータブロックポインタ構造：①直接ポインタ（数個）：小さいファイル向け、直接データブロックを指す。②間接ポインタ（シングル・ダブル・トリプル）：大きいファイル向け、ポインタのブロックを経由してデータブロックを指す。ハードリンクは同じi-nodeを参照する複数のディレクトリエントリです（i-nodeのリンクカウントが増える）。シンボリックリンクは別i-nodeを持つファイルで、そのデータが元ファイルのパス名を格納しています。`ls -i`コマンドでファイルのi-node番号を確認できます。"
        }
      },
      {
        "id": "c",
        "text": "ハードディスクの物理的なセクタとファイルシステムの論理ブロックを対応付けるための変換テーブルである",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "物理セクタと論理ブロックの対応付けはディスクドライバやファイルシステムのブロック管理が行います。i-nodeはこのような物理→論理変換テーブルではなく、ファイルのメタデータとデータブロックへのポインタを保持するデータ構造です。",
          "analogy": "セクタと論理ブロックの対応付けはファイルシステムの地図（配置図）の仕事です。i-nodeは各ファイルの書誌情報カードであり、地図そのものではありません。"
        }
      },
      {
        "id": "d",
        "text": "ファイルの実データ（コンテンツ）が格納されるディスク上の領域を指す",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ファイルの実データが格納されるのはデータブロック（データ領域）です。i-nodeはデータブロックの場所（ポインタ）を記録するメタデータ構造体であり、実データを直接含みません。i-nodeとデータブロックはファイルシステム上の異なる領域に存在します。",
          "analogy": "本の書誌情報カード（i-node）が「5番の棚に保管中」と書いてあっても、カード自体が本の本文（実データ）ではありません。本文（データブロック）は棚（ディスクの別の領域）にあります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "i-nodeはUNIX系ファイルシステムにおける1ファイル1割り当てのメタデータ構造体です。所有者・パーミッション・タイムスタンプ・データブロックポインタなどを含みますが、ファイル名は含みません。",
      "keyPoint": "i-node＝ファイルメタデータ（ファイル名は除く）+データブロックポインタ。ファイル名→i-node番号の対応はディレクトリが保持。",
      "relatedTopics": [
        "ディレクトリエントリ",
        "ハードリンク",
        "シンボリックリンク",
        "ブロックポインタ（直接・間接）",
        "UNIXファイルシステム"
      ],
      "studyTip": "「i-nodeにファイル名はない」を必ず覚えましょう。ファイル名とi-nodeを結びつけるのはディレクトリです。ハードリンクとシンボリックリンクの違いを理解するためにもi-nodeの概念は重要です。"
    },
    "tags": ["i-node", "ファイルシステム", "メタデータ", "UNIX", "ディレクトリエントリ"]
  },
  {
    "questionId": "q-sh-024",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "software-hardware",
    "topic": "コンパイラの最適化",
    "level": 5,
    "question": "コンパイラが行う最適化の手法に関する説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ループ展開（Loop Unrolling）は、ループの繰り返し回数を増やすことでループ内の処理を並列に実行できるようにする手法である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ループ展開は「繰り返し回数を増やす」のではなく、「ループを展開してループの繰り返し（オーバーヘッド）を減らす」手法です。例えば100回のループを50回の2倍処理ループに変換することで、ループ条件判定・分岐の回数を半減させます。繰り返し回数を増やすことが目的ではありません。",
          "analogy": "ループ展開は「料理のレシピを『材料を1個切る×10回』から『材料を2個切る×5回』に書き換える」ことです。全体の材料（処理量）は同じですが、包丁を持ち直す（ループオーバーヘッド）回数が減って効率的です。"
        }
      },
      {
        "id": "b",
        "text": "定数畳み込み（Constant Folding）は、コンパイル時に計算できる定数式を事前に計算して定数値に置き換える最適化である",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "定数畳み込みは、コンパイル時に値が確定している式（例：`2 * 3 + 4`）をコンパイル時に計算して定数（`10`）に置き換える最適化です。実行時の計算コストをゼロにできます。C言語などで`#define SIZE 100 * 100`のような定数式も定数畳み込みで処理されます。コンパイラの基本的かつ重要な最適化の一つです。",
          "analogy": "定数畳み込みは「レシピに4人分の量（2×2人分）と書いてあるとき、印刷前に計算して4人分と直接書いてしまう」ことです。料理中（実行時）にいちいち2×2を計算する手間がなくなります。",
          "deepDive": "コンパイラの主な最適化手法の例：①定数畳み込み（Constant Folding）：コンパイル時に定数式を計算。②定数伝播（Constant Propagation）：変数に定数が代入された後、その変数の使用箇所を定数に置換。③共通部分式削除（CSE: Common Subexpression Elimination）：同じ計算が複数回登場する場合、1回だけ計算して結果を再利用。④デッドコード除去（Dead Code Elimination）：実行されることのないコードを削除。⑤ループ不変式移動（Loop Invariant Code Motion）：ループ内の変わらない計算をループ外に移動。⑥インライン展開（Inlining）：関数呼び出しを関数本体で置き換え、呼び出しオーバーヘッドを削除。"
        }
      },
      {
        "id": "c",
        "text": "インライン展開（Inlining）は、コンパイラがプログラムの実行順序を変えて最も効率的な命令スケジューリングを行う手法である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "インライン展開は「関数呼び出しをその関数の本体コードに置き換える」最適化です。命令スケジューリング（命令の実行順序最適化）とは別の概念です。インライン展開の目的は関数呼び出しのオーバーヘッド（スタックフレーム作成・引数コピー・返り値の受け取りなど）をなくすことです。",
          "analogy": "インライン展開は「レシピに『ソース作り（別紙参照）』と書いてある場合、別紙を参照する手間を省くため、ソース作りの手順をそのままレシピに書き込んでしまう」ことです。別紙への参照（関数呼び出し）のコストがなくなります。"
        }
      },
      {
        "id": "d",
        "text": "デッドコード除去（Dead Code Elimination）は、実行時に動的に使われないコードを検出して最適化する実行時コンパイラ（JIT）の手法である",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "デッドコード除去はJIT（実行時コンパイラ）だけの手法ではなく、通常の静的コンパイラでも行う最適化です。到達不能なコード（`return`文の後のコード、常に偽の条件分岐など）を静的解析でコンパイル時に削除します。JITはプロファイリング情報を使ったより高度なデッドコード除去も行いますが、デッドコード除去はJIT限定ではありません。",
          "analogy": "デッドコード除去は「印刷する前のレシピ見直しで、絶対に使わない手順を削除する編集作業」です。印刷後（実行時）ではなく、印刷前（コンパイル時）に行う一般的な最適化です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "コンパイラの最適化には定数畳み込み・定数伝播・共通部分式削除・デッドコード除去・ループ展開・インライン展開など多種類があります。定数畳み込みはコンパイル時に定数式を計算して代入する基本的な最適化です。",
      "keyPoint": "定数畳み込み＝コンパイル時に確定できる式を事前計算。インライン展開＝関数呼び出しを本体で置き換え。ループ展開＝ループオーバーヘッド削減。デッドコード除去＝実行不可能なコードの削除。",
      "relatedTopics": [
        "定数伝播",
        "共通部分式削除（CSE）",
        "ループ不変式移動",
        "インライン展開",
        "JITコンパイル"
      ],
      "studyTip": "「定数畳み込み」は「コンパイラが電卓代わりに事前計算する」イメージです。各最適化の名前と目的を1行で説明できるようにしておきましょう。FE試験では手法名と説明の組み合わせを問われます。"
    },
    "tags": ["コンパイラ最適化", "定数畳み込み", "インライン展開", "デッドコード除去", "ループ展開"]
  },
  {
    "questionId": "q-sh-025",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "software-hardware",
    "topic": "リンカとローダ",
    "level": 5,
    "question": "プログラムの翻訳・実行における「リンカ」と「ローダ」の役割に関する説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "リンカはソースコードを機械語のオブジェクトファイルに変換し、ローダはオブジェクトファイルを人間が読めるアセンブリ言語に逆変換する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ソースコードを機械語オブジェクトファイルに変換するのはコンパイラ（またはアセンブラ）の役割です。リンカはすでに変換済みのオブジェクトファイル同士を結合して実行可能ファイルを生成します。ローダが「アセンブリ言語に逆変換する」というのも完全に誤りです。ローダは実行可能ファイルを主記憶にロードしてCPUに実行させます。",
          "analogy": "コンパイラは「原稿（ソースコード）を活字（機械語）に組み直す職人」です。リンカは「複数の章の活字版（オブジェクトファイル）を1冊の本にまとめる製本職人」です。ローダは「本（実行可能ファイル）を読者の机（主記憶）に置く書店員」です。"
        }
      },
      {
        "id": "b",
        "text": "リンカは複数のオブジェクトファイルとライブラリを結合して実行可能ファイルを生成し、ローダは実行可能ファイルを主記憶に読み込んでCPUに実行させる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "リンカ（Linker）は複数のオブジェクトファイル（.oや.objファイル）とライブラリ（静的ライブラリ.aや.libなど）のシンボル（関数・変数名）の参照を解決し、アドレスを割り当てて1つの実行可能ファイル（.exeや.outなど）を生成します。ローダ（Loader）はOSの一部として実行可能ファイルをディスクから読み込んで主記憶の適切なアドレスに配置し、動的ライブラリをリンクしてプログラムを実行開始します。",
          "analogy": "プログラムのビルド・実行は本の出版に例えられます。①コンパイラ：各章の原稿（ソース）→各章の活字版（オブジェクトファイル）。②リンカ：複数の章の活字版＋参照資料（ライブラリ）→1冊の完成本（実行可能ファイル）。③ローダ：完成本を倉庫（ディスク）から読者の机（主記憶）に取り出して開く（実行開始）。",
          "deepDive": "リンクの種類：①静的リンク：コンパイル時にライブラリをすべて実行可能ファイルに組み込む。実行ファイルが大きくなるが依存関係が単純。②動的リンク（動的ライブラリ、DLL/shared object）：実行時にロード時または実行中にライブラリを読み込む。複数プロセスでライブラリを共有でき、メモリ効率が良い。ローダの処理ステップ：①実行可能ファイルのヘッダを読み込む→②主記憶に各セグメント（テキスト・データ・BSS）を確保・ロード→③動的ライブラリのロードとシンボル解決→④スタック・ヒープの初期設定→⑤エントリポイントへジャンプ（実行開始）。"
        }
      },
      {
        "id": "c",
        "text": "リンカとローダは同じ役割を持つ同義語であり、どちらも実行可能ファイルを主記憶にロードしてプロセスを起動する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "リンカとローダは別々の役割を持つ異なるツール・機能です。リンカはオブジェクトファイルを結合して実行可能ファイルを生成する段階（コンパイル後・実行前）に動作します。ローダは実行可能ファイルを主記憶に配置して実行する段階（実行時）に動作します。両者は処理のタイミングも目的も異なります。",
          "analogy": "製本職人（リンカ）と書店員（ローダ）は全くの別職種です。製本職人が本（実行可能ファイル）を完成させ、書店員が本を棚（主記憶）に並べてお客さん（CPU）が読める状態にします。仕事が違います。"
        }
      },
      {
        "id": "d",
        "text": "リンカはプログラムの実行中に外部ライブラリを動的に読み込む役割を持ち、ローダはソースコードをコンパイルしてオブジェクトコードを生成する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "実行中に動的ライブラリを読み込むのは動的リンカ（ランタイムリンカ、ld.soなど）またはローダの動的リンク処理であり、通常のリンカの説明としては不正確です。また「ソースコードをコンパイルしてオブジェクトコードを生成する」のはコンパイラの役割であり、ローダの役割ではありません。",
          "analogy": "この選択肢はリンカとローダとコンパイラの役割をごちゃ混ぜにしています。コンパイラ→リンカ→ローダという明確な役割分担があります。コンパイラが本の原稿を作り、リンカが本を完成させ、ローダが本を読者の机に置きます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "リンカは複数のオブジェクトファイルとライブラリを結合して実行可能ファイルを生成します。ローダは実行可能ファイルを主記憶にロードしてCPUに実行させます。コンパイラ→リンカ→ローダという処理の流れを理解しましょう。",
      "keyPoint": "コンパイラ：ソース→オブジェクトファイル。リンカ：オブジェクトファイル→実行可能ファイル（シンボル解決・アドレス割り当て）。ローダ：実行可能ファイル→主記憶へロード→実行開始。",
      "relatedTopics": [
        "コンパイラ",
        "アセンブラ",
        "静的リンク・動的リンク",
        "共有ライブラリ（DLL）",
        "実行可能ファイルの構造"
      ],
      "studyTip": "「リンク＝つなぐ（複数ファイルを1つに）」「ロード＝積み込む（実行可能ファイルをメモリに）」という語感で覚えましょう。プログラム実行までの流れ（ソース→コンパイル→リンク→ロード→実行）を順序で頭に入れると混乱しません。"
    },
    "tags": ["リンカ", "ローダ", "コンパイラ", "オブジェクトファイル", "静的リンク", "動的リンク"]
  }
]
