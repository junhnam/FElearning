[
  {
    "questionId": "q-db-ext-001",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "テーブルと主キー",
    "level": 1,
    "question": "関係データベースのテーブルに関する説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "テーブルの1列には必ず複数の異なる値が存在しなければならない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "テーブルの列には同じ値が複数行に存在しても問題ありません。例えば「性別」列には「男」「女」が繰り返し現れます。一意性が求められるのは主キー列だけです。",
          "analogy": "クラスの出席簿で「出席」「欠席」の欄に同じ値が並んでも問題がないのと同じです。すべての欄が違う値でなければならないわけではありません。"
        }
      },
      {
        "id": "b",
        "text": "テーブルの行の順序は意味を持たず、どのような順で格納されていてもよい",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "関係データベースのテーブル（リレーション）では、行（タプル）の集合はあくまで「集合」として扱われるため、行の順序に意味はありません。特定の順序で取得したい場合は、SELECT文にORDER BY句を使って明示的に指定します。",
          "analogy": "トランプのカードが何枚かあるとき、袋の中ではどの順番で入っていても「同じカードの束」です。並べ方（ORDER BY）を指定したときに初めて順番が決まります。",
          "deepDive": "集合論では集合の要素に順序はありません。関係データベースはこの集合論に基づいているため、テーブルの行（タプル）も順序のない集合です。格納順序が気になる場合はCLUSTERED INDEXや物理的な配置を検討しますが、論理モデル上は順序に意味はないと理解することが重要です。"
        }
      },
      {
        "id": "c",
        "text": "テーブルには必ずインデックスを設定しなければならない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "インデックスはデータ検索を高速化するための補助的な仕組みであり、必須ではありません。インデックスがなくてもテーブルは機能しますが、全件走査（フルスキャン）となるため検索速度が遅くなる可能性があります。",
          "analogy": "本に索引がなくても読めますが、特定の単語を探すときに全ページをめくらなければならなくなるのと同じです。索引は便利な補助機能です。"
        }
      },
      {
        "id": "d",
        "text": "テーブルの列数（属性数）は2以上でなければならない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "テーブルは1列だけでも構成できます。例えば「禁止ワードリスト」として1つの文字列型の列だけを持つテーブルも設計上あり得ます。列数に関する下限の制約はありません。",
          "analogy": "Excel でも1列だけのシートを作ることができます。列が1つだけでも立派な表（テーブル）です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "関係データベースのテーブルは集合論に基づいており、行の順序には意味がありません。特定の順序が必要な場合はORDER BY句で明示的に指定します。",
      "keyPoint": "テーブルの行は順序のない集合。順序が必要なときはORDER BYで指定する。",
      "relatedTopics": ["SELECT文", "ORDER BY", "インデックス", "主キー"],
      "studyTip": "関係データベースが集合論に基づいていることを意識すると、テーブルの性質（行の順序なし、重複行なし）が自然に理解できます。"
    },
    "tags": ["テーブル", "リレーショナルデータベース", "集合論", "ORDER BY"]
  },
  {
    "questionId": "q-db-ext-002",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "テーブルと主キー",
    "level": 1,
    "question": "主キーの制約条件として、正しい組み合わせはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "一意性：あり、NULL許容：あり",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "主キーはNULL値を許可しません。主キーの値が空（NULL）では、その行を一意に識別できなくなるためです。NULLを許可しつつ一意性だけを持つ制約はUNIQUE制約です。",
          "analogy": "学校の出席番号で「番号なし」という人がいると、誰かを呼ぶときに困ります。主キーは必ず値がなければなりません。"
        }
      },
      {
        "id": "b",
        "text": "一意性：あり、NULL許容：なし",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "主キーには①一意性（テーブル内で同じ値が存在しない）と②非NULL（空値を許可しない）の2つの制約が必ずセットで課されます。どちらか一方でも欠けると主キーとしての役割を果たせません。",
          "analogy": "パスポートのパスポート番号のようなものです。世界で唯一の番号（一意性）であり、番号なしのパスポートは発行されません（非NULL）。この2条件が揃って初めて「正しい身分証明書」として機能します。",
          "deepDive": "主キーはDBMSによって自動的にUNIQUE制約とNOT NULL制約が付与されます。また、主キーにはデフォルトでクラスタードインデックスが作成されるDBMSも多く、物理的なデータ格納順序の基準にもなります。1つのテーブルに主キーは1つだけ設定できます（複合主キーも1つの主キーの定義として数えます）。"
        }
      },
      {
        "id": "c",
        "text": "一意性：なし、NULL許容：なし",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "主キーには一意性が必須です。一意性がなければ、同じ主キー値の行が複数存在することになり、どの行を指しているか特定できなくなります。",
          "analogy": "同じ学籍番号を持つ学生が複数いたら、成績表で誰の記録かわからなくなってしまいます。"
        }
      },
      {
        "id": "d",
        "text": "一意性：なし、NULL許容：あり",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "主キーには一意性と非NULLの両方が必要です。一意性もNULL禁止もない列は、通常の一般的な列と変わらず、主キーにはなれません。",
          "analogy": "誰でも同じ名前でNULLでもOKな識別番号では、個人を特定する手段として機能しません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "主キーの条件は①一意性（重複不可）と②非NULL（空値禁止）の2つです。この2条件が揃ってはじめてテーブルの各行を一意に識別できます。",
      "keyPoint": "主キー＝一意性あり かつ NULL不可",
      "relatedTopics": ["UNIQUE制約", "NOT NULL制約", "候補キー", "外部キー"],
      "studyTip": "主キーとUNIQUE制約の違い（NULLを許可するかどうか）を整理して覚えましょう。"
    },
    "tags": ["主キー", "一意性", "NULL", "整合性制約"]
  },
  {
    "questionId": "q-db-ext-003",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "リレーショナルDB概念",
    "level": 2,
    "question": "関係データベースにおける「ビュー（View）」の説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ビューはデータを物理的に格納するため、基となるテーブルを削除してもビューのデータは残る",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ビューは仮想テーブルであり、データを物理的に格納しません。基となるテーブル（基底テーブル）を削除すると、ビューは機能しなくなります（エラーになります）。",
          "analogy": "鏡に映った像は鏡の中に「保存」されているわけではありません。元の物体がなくなれば鏡に何も映らなくなります。"
        }
      },
      {
        "id": "b",
        "text": "ビューとは、1つ以上のテーブルに対するSELECT文を定義した仮想的なテーブルである",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ビューはSELECT文として定義された仮想テーブルです。ビューを参照すると、背後で定義されたSELECT文が実行されて結果が返されます。複数テーブルをJOINしたビューや、特定の列・行だけに絞り込んだビューを作成できます。",
          "analogy": "カスタマイズした「検索条件の保存」のようなものです。例えば「東京都在住の顧客一覧」というビューを作ると、毎回WHERE句を書かなくても、そのビューを参照するだけで同じ結果が得られます。テレビのチャンネル登録に似ており、「チャンネル5」を選ぶだけで特定の放送局（データ）を表示できます。",
          "deepDive": "ビューの用途は①アクセス制御（特定の列・行だけを見せる）②複雑なSQLの簡略化③データの論理的な独立性の確保などです。マテリアライズドビューはビューの結果を物理的にキャッシュする特殊なビューで、参照パフォーマンスを向上させますが、定期的な更新が必要です。"
        }
      },
      {
        "id": "c",
        "text": "ビューはインデックスと同じ役割を持ち、検索を高速化するためだけに使用する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ビューの主な目的は検索の高速化ではなく、複雑なSQLの簡略化、セキュリティ（必要な列・行だけ公開）、論理的な独立性の確保です。検索の高速化はインデックスの役割です。",
          "analogy": "ビューは「よく使う検索パターンを名前を付けて保存する」機能で、「索引の付いた早引き表」（インデックス）とは別物です。"
        }
      },
      {
        "id": "d",
        "text": "ビューを使用すると、元のテーブルのデータを変更できなくなる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ビューを作成してもテーブルへのアクセス権限は変わりません。また、単純なビューであればビューを通じて元テーブルのデータを更新（INSERT・UPDATE・DELETE）できる場合もあります。",
          "analogy": "窓から庭を見ても庭そのものには触れますし、窓があるからといって庭への扉が閉まるわけではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ビューはSELECT文として定義された仮想テーブルです。データを物理的に持たず、参照時に定義されたSELECT文が実行されます。SQLの簡略化やアクセス制御に活用されます。",
      "keyPoint": "ビュー＝SELECT文を名前で保存した仮想テーブル（データは物理的に持たない）",
      "relatedTopics": ["SELECT文", "アクセス制御", "マテリアライズドビュー", "論理的独立性"],
      "studyTip": "ビュー・インデックス・テーブルの違いを整理し、それぞれの目的を覚えましょう。"
    },
    "tags": ["ビュー", "仮想テーブル", "SELECT", "アクセス制御"]
  },
  {
    "questionId": "q-db-ext-004",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "SELECT文基礎",
    "level": 2,
    "question": "次のSQL文の実行結果として正しいものはどれか。\n\nSELECT DISTINCT 部門名 FROM 社員\n\n※社員テーブルのデータ（部門名列のみ）：\n営業, 技術, 営業, 総務, 技術, 技術",
    "choices": [
      {
        "id": "a",
        "text": "3行（営業, 技術, 総務）が返される",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "DISTINCT句は重複する値を排除して一意な値だけを返します。「営業」「技術」「営業」「総務」「技術」「技術」という6行のデータから重複を除くと、「営業」「技術」「総務」の3種類になります。",
          "analogy": "くじ引きの箱に赤玉・青玉・赤玉・白玉・青玉・青玉が入っているとき、「どんな色の玉があるか」を調べると「赤・青・白」の3色だけが答えになります。DISTINCT は「種類を調べる」操作です。",
          "deepDive": "DISTINCTはSELECT句の直後に一度だけ記述します。複数列に適用すると「列の組み合わせ」の重複を除きます（例：SELECT DISTINCT 部門名, 役職 FROM 社員）。パフォーマンス面では、内部的にソートやハッシュ処理が行われるため、大量データでのDISTINCTは負荷が高くなります。GROUP BYで代替できる場合もあります。"
        }
      },
      {
        "id": "b",
        "text": "6行（全データ）が返される",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "DISTINCTなしの「SELECT 部門名 FROM 社員」ならば6行返されますが、DISTINCT句があるため重複が除かれます。DISTINCTを無視した場合の誤りです。",
          "analogy": "「どんな種類の玉があるか」ではなく「玉の数」を数えてしまっています。DISTINCTは種類を数えるためのキーワードです。"
        }
      },
      {
        "id": "c",
        "text": "1行（最初の行の値：営業）だけが返される",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "DISTINCTは先頭の1行だけを返す操作ではありません。重複を除いたすべての一意な値を返します。先頭行だけを返すにはLIMIT 1などを使います。",
          "analogy": "DISTINCTは「先頭だけ取る」操作ではなく「重複を取り除く」操作です。全種類を網羅して返します。"
        }
      },
      {
        "id": "d",
        "text": "エラーになり結果は返されない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「SELECT DISTINCT 列名 FROM テーブル名」は正しいSQL構文です。エラーにはなりません。DISTINCTはSELECTと組み合わせて使う有効なキーワードです。",
          "analogy": "文法的に正しい日本語の文章は読めます。「DISTINCT」は文法的に正しいSQL予約語なので、エラーにはなりません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "DISTINCT句は重複行を除去して一意な値のみを返します。「営業」「技術」「総務」の3種類の部門名が結果として返されます。",
      "keyPoint": "DISTINCT＝重複を取り除き一意な値だけを返す",
      "relatedTopics": ["SELECT文", "GROUP BY", "COUNT(DISTINCT)", "WHERE句"],
      "studyTip": "DISTINCTとGROUP BYはどちらも重複排除に使えますが、GROUP BYは集約関数と組み合わせる点が異なります。使い分けを覚えましょう。"
    },
    "tags": ["SELECT", "DISTINCT", "重複排除", "SQL基礎"]
  },
  {
    "questionId": "q-db-ext-005",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "WHERE句",
    "level": 3,
    "question": "次のSQL文で使用されているLIKE演算子の説明として、正しいものはどれか。\n\nSELECT * FROM 商品 WHERE 商品名 LIKE '鉛筆%'",
    "choices": [
      {
        "id": "a",
        "text": "商品名が「鉛筆」と完全に一致する行を取得する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "完全一致の場合は「LIKE '鉛筆'」や「= '鉛筆'」を使います。「鉛筆%」の「%」はワイルドカードで「任意の0文字以上の文字列」を表すため、完全一致ではありません。「鉛筆%」は「鉛筆」の後に何か続く（もしくは何もない）文字列にマッチします。",
          "analogy": "「田中」で完全一致検索するのと、「田中で始まる名前」を検索するのは違います。%はあいまい検索のための「省略記号」です。"
        }
      },
      {
        "id": "b",
        "text": "商品名の末尾に「鉛筆」が含まれる行を取得する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「鉛筆%」は「鉛筆」で始まる文字列を意味します。末尾に「鉛筆」を含む場合は「'%鉛筆'」と書きます。%の位置が前後で意味が変わります。",
          "analogy": "%を前に置くか後に置くかで意味が逆になります。「鉛筆%」は「鉛筆から始まる」、「%鉛筆」は「鉛筆で終わる」です。"
        }
      },
      {
        "id": "c",
        "text": "商品名が「鉛筆」で始まる行を取得する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "LIKE演算子のパターン「鉛筆%」は「鉛筆で始まり、その後に任意の0文字以上の文字列が続く」という意味です。「鉛筆」「鉛筆（赤）」「鉛筆2B」などがマッチします。「%」は0文字以上の任意の文字列を表すワイルドカードです。",
          "analogy": "電話帳で「田中」で始まる名前を検索するようなものです。「田中さん」「田中太郎さん」「田中花子さん」がすべてヒットします。後ろに何が続いても「田中」で始まっていればOKです。",
          "deepDive": "LIKEのワイルドカードには「%」（0文字以上の任意の文字列）と「_」（任意の1文字）の2種類があります。例：「_鉛筆」は「赤鉛筆」はマッチするが「鉛筆」は不一致。「%鉛筆%」は「鉛筆」を含む任意の文字列。LIKEはインデックスが使われないことが多く（特に前方一致以外）、大量データでは注意が必要です。"
        }
      },
      {
        "id": "d",
        "text": "商品名に「鉛筆」という文字が1文字でも含まれる行を取得する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「鉛筆」という文字が含まれる行を取得するには「LIKE '%鉛筆%'」と前後に%を付けます。「鉛筆%」は前方一致（「鉛筆」で始まる）の検索です。",
          "analogy": "「田中」を含む名前を検索するなら「%田中%」、「田中」で始まる名前を検索するなら「田中%」、「田中」で終わる名前なら「%田中」です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "LIKE演算子で「文字列%」は前方一致（指定した文字列で始まる）を意味します。%は0文字以上の任意の文字列を表すワイルドカードです。",
      "keyPoint": "'文字列%'＝前方一致、'%文字列'＝後方一致、'%文字列%'＝部分一致",
      "relatedTopics": ["WHERE句", "パターンマッチング", "インデックス", "正規表現"],
      "studyTip": "LIKEのワイルドカード（%と_）の使い方と意味を、具体例とともに覚えましょう。"
    },
    "tags": ["LIKE", "WHERE", "ワイルドカード", "パターンマッチング"]
  },
  {
    "questionId": "q-db-ext-006",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "GROUP BY/HAVING",
    "level": 3,
    "question": "次のSQL文に関する説明として、正しいものはどれか。\n\nSELECT 部門名, COUNT(*) AS 人数\nFROM 社員\nGROUP BY 部門名\nHAVING COUNT(*) >= 3",
    "choices": [
      {
        "id": "a",
        "text": "WHERE句の代わりにHAVING句を使っているので、条件指定の方法として誤りである",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "HAVING句はGROUP BYの集計結果に対して条件を付けるための正しい構文です。WHERE句が行に対する条件であるのに対し、HAVING句はグループ（集計結果）に対する条件です。この使い方は正しいです。",
          "analogy": "WHERE句は「材料を選ぶ」段階、HAVING句は「料理が完成した後に絞り込む」段階です。どちらも適切な場面で使えば正しい使い方です。"
        }
      },
      {
        "id": "b",
        "text": "部門ごとの人数を集計し、人数が3人以上の部門のみを表示する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "GROUP BY 部門名でデータを部門ごとにグループ化し、COUNT(*)で各グループの行数（人数）を集計します。HAVING COUNT(*) >= 3は集計後のグループに対して「3人以上」という条件を適用し、条件を満たす部門のみを結果として返します。",
          "analogy": "会社のサークル活動の集計に例えると、まず「サークル別に人数を数え」（GROUP BY + COUNT）、「3人以上のサークルだけ一覧に載せる」（HAVING）という流れです。",
          "deepDive": "GROUP BY と HAVING の実行順序：FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY。WHEREはGROUP BY前に実行される（グループ化前の行を絞り込む）のに対し、HAVINGはGROUP BY後に実行される（グループ化後の集計結果を絞り込む）という点が重要です。集約関数（COUNT, SUM, AVG等）を条件にする場合はHAVINGを使います。"
        }
      },
      {
        "id": "c",
        "text": "社員数が3人以上の社員のレコードを表示する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "このSQL文は個々の社員レコードではなく、部門名と部門ごとの社員数（COUNT）を返します。GROUP BYを使うと結果は集計単位（部門）ごとの行となり、個々の社員レコードは表示されません。",
          "analogy": "「各クラスの生徒数」を出す操作で、個々の生徒の情報ではなく「クラスA:30人、クラスB:28人」のような集計結果が返されます。"
        }
      },
      {
        "id": "d",
        "text": "HAVING句はSELECT句の後に評価されるため、このSQL文の列エイリアス「人数」をHAVING句で使えばより簡潔に書ける",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "SQLの多くのデータベース実装では、HAVING句でSELECT句のエイリアスを参照することは標準SQL的には認められていません。標準SQLではHAVING句でCOUNT(*)を直接記述する必要があります（一部のDBMSは独自拡張でエイリアスを許可しています）。",
          "analogy": "レポートを書くときに、まず本文を書いてから目次を作るのが正式な手順です。目次（エイリアス）を本文（HAVING）の中で参照するのは、多くのルールで認められていません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "GROUP BY 部門名でグループ化、COUNT(*)で各グループの件数を集計し、HAVING句で集計結果が3以上のグループのみを絞り込む処理です。",
      "keyPoint": "HAVING句はGROUP BYで集計した結果に対する条件。WHERE句はGROUP BY前の行に対する条件。",
      "relatedTopics": ["WHERE句との違い", "集約関数", "ORDER BY", "サブクエリ"],
      "studyTip": "SQL文の実行順序（FROM→WHERE→GROUP BY→HAVING→SELECT→ORDER BY）を覚えると、WHERE とHAVING の使い分けが自然に理解できます。"
    },
    "tags": ["GROUP BY", "HAVING", "COUNT", "集計"]
  },
  {
    "questionId": "q-db-ext-007",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "ORDER BY",
    "level": 3,
    "question": "次のSQL文の結果の並び順として、正しいものはどれか。\n\nSELECT 商品名, 価格 FROM 商品 ORDER BY 価格 DESC, 商品名 ASC",
    "choices": [
      {
        "id": "a",
        "text": "価格の昇順、同額の場合は商品名の降順で並ぶ",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "DESCは降順（大きい順）、ASCは昇順（小さい順）です。「価格 DESC」は価格の降順です。「価格の昇順」という説明は誤りです。",
          "analogy": "DESCはDescending（下降する）の略で「高い→低い」、ASCはAscending（上昇する）の略で「低い→高い」です。"
        }
      },
      {
        "id": "b",
        "text": "商品名の昇順、同名の場合は価格の降順で並ぶ",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ORDER BYには複数の列を指定できますが、先に書いた列が主キーで優先されます。「ORDER BY 価格 DESC, 商品名 ASC」は「まず価格の降順で並べ、価格が同じ場合に商品名の昇順で並べる」という意味です。商品名が主キーではありません。",
          "analogy": "「年齢の多い順に並び、同年齢の場合は名前のあいうえお順にする」という場合、まず年齢で大まかに並び、次に同年齢の中でのみ名前順が適用されます。"
        }
      },
      {
        "id": "c",
        "text": "価格の降順、価格が同じ場合は商品名の昇順で並ぶ",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ORDER BY句では複数の列を指定でき、左から優先順位が高くなります。「価格 DESC」が第1ソートキーで価格の降順（高い順）に並べ、価格が同じ行が複数ある場合は第2ソートキー「商品名 ASC」で商品名の昇順（あいうえお順）に並べます。",
          "analogy": "成績表を「点数の高い順（DESC）に並べ、同点の場合は名前のあいうえお順（ASC）に並べる」のと同じです。まず点数で大きく分類し、同点グループの中でのみ名前順が適用されます。",
          "deepDive": "ORDER BY句では最大で全列数まで指定できます。ソートキーが多いほどDBの処理負荷が増えます。ORDER BYを省略した場合、結果の並び順は保証されません（DBMSの実装によって異なります）。NULLの扱いはDBMSによって異なり（先頭・末尾）、NULLS FIRST / NULLS LASTで明示的に指定できるDBMSもあります。"
        }
      },
      {
        "id": "d",
        "text": "商品名の昇順だけで並ぶ（価格のDESCは無効）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ORDER BYに複数の列を指定した場合、すべてのソートキーが有効です。先に書いた列が優先されるだけで、後の列指定が無効になることはありません。",
          "analogy": "「まず会社名順、次に部署名順」という並べ方では、会社名と部署名の両方の指定が有効に機能します。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ORDER BY 価格 DESC, 商品名 ASCは「価格の高い順に並べ、同額の場合は商品名のあいうえお順（昇順）に並べる」という意味です。",
      "keyPoint": "ORDER BY の複数列指定では左が優先。DESC＝降順、ASC＝昇順（省略時もASC）",
      "relatedTopics": ["SELECT文", "複合ソート", "NULL値の扱い", "インデックスとソート"],
      "studyTip": "DESC（降順）とASC（昇順）のどちらがデフォルトか（ASCがデフォルト）を覚え、複数キーのソートは左から優先されると覚えましょう。"
    },
    "tags": ["ORDER BY", "DESC", "ASC", "ソート"]
  },
  {
    "questionId": "q-db-ext-008",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "INSERT/UPDATE/DELETE",
    "level": 4,
    "question": "次のSQL文について、正しい説明はどれか。\n\nUPDATE 社員 SET 給与 = 給与 * 1.1 WHERE 部門 = '営業'",
    "choices": [
      {
        "id": "a",
        "text": "営業部門の全社員の給与を一律10万円増加させる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "「給与 = 給与 * 1.1」は現在の給与に1.1を掛ける計算であり、一律の金額を加算する操作ではありません。例えば現在の給与が30万円なら33万円に、50万円なら55万円になります（10%増）。",
          "analogy": "「全員に10万円のボーナス」（定額加算）ではなく、「全員の給与を10%アップ」（割合増）の操作です。"
        }
      },
      {
        "id": "b",
        "text": "営業部門の全社員の給与を現在の1.1倍（10%増）に更新する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "WHERE 部門 = '営業'で営業部門の社員行を対象とし、SET 給与 = 給与 * 1.1 で現在の給与値に1.1を掛けた値（10%増）に更新します。UPDATEは条件に合う行の既存の値を新しい値で上書きする命令です。",
          "analogy": "給与計算システムで「営業部全員の給与を10%ベースアップする」処理に相当します。現在30万円の社員は33万円に、50万円の社員は55万円になります。それぞれの元の給与を基準に計算される点がポイントです。",
          "deepDive": "UPDATEのSET句では「列名 = 式」の形式で更新値を指定します。式には定数だけでなく、現在の列の値を使った計算も使えます。WHERE句を省略するとテーブルの全行が更新されるため、誤ってWHERE句を忘れると全データが書き換わる危険があります。本番環境では必ずトランザクション内でUPDATEを実行し、ロールバックできる状態にしておくことが重要です。"
        }
      },
      {
        "id": "c",
        "text": "営業部門の行を削除して、給与を1.1倍にした新しい行を挿入する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "UPDATEは既存の行の値を変更する命令です。行を削除してから新規挿入するわけではありません。行の他の列（氏名、社員番号など）はそのまま保持されます。",
          "analogy": "鉛筆で書いた数字を消しゴムで消してから書き直す（DELETE + INSERT）ではなく、修正液で上書きする（UPDATE）イメージです。"
        }
      },
      {
        "id": "d",
        "text": "WHERE句がないのでエラーになる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "WHERE句なしのUPDATEはエラーにはなりません。WHERE句を省略すると、テーブルの全行が更新されます。このSQL文にはWHERE句がありますが、仮になかったとしてもSQLとして有効です。",
          "analogy": "WHERE句なしのUPDATEは「全員の給与を一括変更する」という意味で有効な命令です。ただし全行が対象になるため、実行には細心の注意が必要です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "UPDATE文のSET句では計算式を使って現在値を基準にした更新ができます。「給与 = 給与 * 1.1」は10%増の計算です。WHERE句で対象行を絞り込みます。",
      "keyPoint": "UPDATE テーブル SET 列 = 値または式 WHERE 条件。WHERE省略で全行更新。",
      "relatedTopics": ["INSERT", "DELETE", "WHERE句", "トランザクション"],
      "studyTip": "UPDATE実行前にSELECT文で同じWHERE条件を確認し、対象行が正しいかチェックする習慣をつけましょう。"
    },
    "tags": ["UPDATE", "SET", "WHERE", "データ操作"]
  },
  {
    "questionId": "q-db-ext-009",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "CREATE TABLE",
    "level": 4,
    "question": "次のCREATE TABLE文に関する説明として、正しいものはどれか。\n\nCREATE TABLE 受注 (\n  受注番号 INTEGER PRIMARY KEY,\n  顧客ID  INTEGER NOT NULL,\n  受注日  DATE,\n  金額    DECIMAL(10,2) CHECK (金額 > 0)\n)",
    "choices": [
      {
        "id": "a",
        "text": "受注日列にはNULL値を挿入できない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "受注日列にはNOT NULL制約が付いていないため、NULL値を挿入できます。NULL値を禁止するにはNOT NULL制約を明示的に付ける必要があります。NOT NULLが付いているのは顧客ID列だけです。",
          "analogy": "申請書の「備考欄」のように、記入が任意の欄（NOT NULL制約なし）は空欄（NULL）でも受け付けます。"
        }
      },
      {
        "id": "b",
        "text": "金額列には0以下の値を挿入しようとするとエラーになる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "CHECK (金額 > 0) はチェック制約であり、金額列に挿入・更新する値が「0より大きい」という条件を常に満たすことを強制します。0や負の値を挿入しようとすると、データベースがエラーを返して拒否します。",
          "analogy": "注文書の「金額」欄に「チェック：金額は必ず正の数」というルールを設けるようなものです。担当者が0円や負の数を誤入力しようとすると「入力エラー」で弾かれます。",
          "deepDive": "CHECK制約はISO SQL標準の制約の一つで、列の値に対してビジネスルールを適用します。DECIMAL(10,2)は合計10桁、小数点以下2桁の数値型です（例：99999999.99が最大値）。CREATE TABLE文で指定できる制約：PRIMARY KEY（主キー）、FOREIGN KEY（外部キー）、UNIQUE（一意）、NOT NULL（非NULL）、CHECK（検査制約）、DEFAULT（既定値）。"
        }
      },
      {
        "id": "c",
        "text": "受注番号が重複する行を挿入できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "受注番号にPRIMARY KEY制約が付いているため、重複する値は挿入できません。主キー制約は一意性を保証し、重複する値の挿入を防ぎます。",
          "analogy": "受注番号は注文書の番号のようなもので、同じ番号の注文書が2枚存在したら混乱します。主キー制約がこれを防ぎます。"
        }
      },
      {
        "id": "d",
        "text": "顧客ID列にNULL値を挿入できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "顧客ID列にはNOT NULL制約が付いているため、NULL値は挿入できません。誰からの注文かわからない（顧客IDが空）状態は業務上も問題があるため、NOT NULL制約で防いでいます。",
          "analogy": "注文書に「お客様の氏名（必須）」と書かれていれば、空欄では提出できません。NOT NULL制約は「この項目は必須入力」というルールを強制します。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "CREATE TABLE文の各制約（PRIMARY KEY、NOT NULL、CHECK）の意味を理解することが重要です。CHECK (金額 > 0) により、0以下の金額はエラーになります。",
      "keyPoint": "CHECK制約＝列の値が条件を満たさない場合にエラー。NOT NULL制約＝NULL挿入を禁止。",
      "relatedTopics": ["PRIMARY KEY", "FOREIGN KEY", "UNIQUE制約", "ALTER TABLE"],
      "studyTip": "CREATE TABLE文の各制約を1つずつ覚え、どの制約がどのエラーを防ぐかを整理しましょう。"
    },
    "tags": ["CREATE TABLE", "CHECK制約", "NOT NULL", "DDL"]
  },
  {
    "questionId": "q-db-ext-010",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "外部キーと参照整合性",
    "level": 5,
    "question": "参照整合性制約に関する説明として、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "外部キーの値は、参照先テーブルの主キーに存在しない値でも挿入できる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "参照整合性制約（外部キー制約）により、外部キーの値は参照先テーブルの主キーに存在する値でなければなりません。存在しない値を挿入しようとするとエラーになります。",
          "analogy": "「部署コード：99」という社員を登録しようとしても、部署テーブルに「部署コード：99」が存在しなければ、「そんな部署はない」と弾かれます。"
        }
      },
      {
        "id": "b",
        "text": "参照先テーブルの行を削除すると、それを参照する行が存在する場合はデフォルトでエラーになる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "外部キー制約が設定されている場合、参照先テーブルの行を削除しようとしたとき、その主キー値を外部キーとして参照している行が他テーブルに存在すると、参照整合性違反としてデフォルトでエラーになります（RESTRICT動作）。これにより「孤立した参照」が生まれることを防ぎます。",
          "analogy": "会社の組織図で「営業部」を削除しようとしても、「営業部所属」の社員が残っていれば「この部署はまだ社員がいるから削除できない」とシステムが拒否します。整合性を保つための安全装置です。",
          "deepDive": "外部キー制約の参照動作（ON DELETE / ON UPDATE）の種類：①RESTRICT（デフォルト）：参照されている場合はエラー。②CASCADE：参照元も連動して削除・更新。③SET NULL：参照元の外部キーをNULLに設定。④SET DEFAULT：参照元の外部キーをデフォルト値に設定。⑤NO ACTION：トランザクション終了時まで整合性チェックを遅延。用途に応じて適切な参照動作を選択することが重要です。"
        }
      },
      {
        "id": "c",
        "text": "外部キー制約を設定すると、参照先テーブルより参照元テーブルを先に作成しなければならない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "外部キー制約を設定する場合、参照先テーブル（親テーブル）を先に作成する必要があります。参照先テーブルが存在しない状態で外部キーを含むテーブルを作ると、参照先が見つからずエラーになります。順序は「参照先→参照元」です。",
          "analogy": "「部署テーブルを参照する社員テーブル」を作るには、まず部署テーブルを作らないと「参照先が存在しない」エラーになります。"
        }
      },
      {
        "id": "d",
        "text": "外部キーの値にはNULLを設定できない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "外部キー列にNOT NULL制約を付けない限り、外部キーにNULLを設定できます。NULLは「参照先が未定」や「関連なし」を表す場合に使います。例えば「上司がいない（NULLの上司ID）」という社員レコードは外部キーがNULLで許容されます。",
          "analogy": "新入社員の「担当部署未定」（部署IDがNULL）という状態は、部署テーブルに存在しない値ではなく「まだ決まっていない」ことを表し、多くのDBMSで許容されます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "参照整合性制約では、参照先の行を削除しようとした際、参照元の外部キーから参照されている場合はデフォルトでエラーになります。ON DELETE CASCADEなどの参照動作で挙動を変更できます。",
      "keyPoint": "外部キー制約のデフォルト動作＝参照されている親行を削除するとエラー（RESTRICT）",
      "relatedTopics": ["外部キー", "ON DELETE CASCADE", "ON DELETE SET NULL", "参照整合性"],
      "studyTip": "参照整合性の動作オプション（RESTRICT, CASCADE, SET NULL, SET DEFAULT）とその用途の違いを整理して覚えましょう。"
    },
    "tags": ["外部キー", "参照整合性", "FOREIGN KEY", "CASCADE"]
  }
]
