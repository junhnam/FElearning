[
  {
    "questionId": "q-db-041",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "ビュー",
    "level": 1,
    "question": "関係データベースにおけるビューに関する記述として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ビューはデータを物理的に格納する実テーブルである",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ビューは実テーブルではなく、SELECT文の定義を保存した仮想テーブルです。データそのものを物理的に持つことはありません。",
          "analogy": "ビューはカメラのファインダーのようなもので、景色（データ）そのものではなく、見え方を定義するフレームです。"
        }
      },
      {
        "id": "b",
        "text": "ビューに対してINSERT文やUPDATE文は一切実行できない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "単純なビュー（1つのテーブルに対して集約関数やGROUP BYを使用していないもの）であれば、INSERT文やUPDATE文を実行できる場合があります。すべてのビューで一切不可とは限りません。",
          "analogy": "ガラス窓から中の物を移動させることが可能な場合もあるように、条件を満たすビューであれば更新操作も行えます。"
        }
      },
      {
        "id": "c",
        "text": "ビューはSELECT文の結果を仮想的なテーブルとして参照できるようにしたものである",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ビューはCREATE VIEW文でSELECT文の定義を保存したもので、あたかもテーブルのように参照できる仮想テーブルです。データへのアクセスをシンプルにしたり、セキュリティ上必要なデータだけを見せたりする目的で使われます。",
          "analogy": "ショーウインドウのようなもので、倉庫（実テーブル）にある商品の一部だけをお客さん（利用者）に見せる仕組みです。倉庫の中身が変われば、ショーウインドウの内容も自動的に変わります。",
          "deepDive": "ビューの主な利点は、①複雑なSELECT文を簡略化できる、②不要な列を隠してセキュリティを確保できる、③アプリケーションとテーブル構造の間に抽象層を設けてデータ独立性を高められる、の3点です。ただし、ビューは問い合わせのたびにSELECT文が実行されるため、パフォーマンスに影響を与える場合があります。"
        }
      },
      {
        "id": "d",
        "text": "ビューを定義すると、元のテーブルのデータが自動的にコピーされる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ビューはデータのコピーを作成しません。ビューにアクセスするたびに、元のテーブルに対してSELECT文が実行され、その時点のデータが返されます。",
          "analogy": "写真（コピー）ではなくライブカメラ映像のようなもので、元の場所のリアルタイムの状態がそのまま映し出されます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ビューはSELECT文の定義を保存した仮想テーブルで、データを物理的に持たず、元テーブルを参照して結果を返します。",
      "keyPoint": "ビュー＝仮想テーブル（SELECT文の定義を保存したもので、実データは持たない）",
      "relatedTopics": ["SELECT文", "CREATE VIEW", "データ独立性", "セキュリティ"],
      "studyTip": "ビューは「よく使う問い合わせに名前を付けて保存したもの」と覚えると理解しやすいです。"
    },
    "tags": ["ビュー", "仮想テーブル", "CREATE VIEW", "データベース基礎"]
  },
  {
    "questionId": "q-db-042",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "SQL基礎",
    "level": 1,
    "question": "SQL文においてテーブルからデータを取得するために使用する命令はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "INSERT",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "INSERTはテーブルに新しい行（レコード）を挿入するための命令です。データの取得には使用しません。",
          "analogy": "ノートに新しいメモを書き加えるのがINSERTです。既に書いてあるメモを読む操作ではありません。"
        }
      },
      {
        "id": "b",
        "text": "UPDATE",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "UPDATEはテーブル内の既存データを更新（変更）するための命令です。データの取得ではなく、書き換えを行います。",
          "analogy": "ノートに書いてあるメモの内容を書き直すのがUPDATEです。読むだけの操作ではありません。"
        }
      },
      {
        "id": "c",
        "text": "DELETE",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "DELETEはテーブルから行を削除するための命令です。データの取得ではなく、消去を行います。",
          "analogy": "ノートからメモを消しゴムで消すのがDELETEです。メモを読む操作とは異なります。"
        }
      },
      {
        "id": "d",
        "text": "SELECT",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "SELECTはテーブルからデータを検索・取得するためのSQL文です。SELECT 列名 FROM テーブル名 WHERE 条件 の形式で使用し、条件に合致するデータを返します。",
          "analogy": "図書館の蔵書検索のようなもので、条件（著者名や出版年など）を指定して、該当する本（データ）を探し出す命令です。",
          "deepDive": "SQLの操作はCRUD（Create, Read, Update, Delete）に分類できます。SELECTはRead（読み取り）に対応します。SELECTにはWHERE（条件指定）、ORDER BY（並べ替え）、GROUP BY（集約）、HAVING（集約条件）など多くの句を組み合わせて使用できます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "SQLの基本操作はSELECT（取得）、INSERT（挿入）、UPDATE（更新）、DELETE（削除）の4つです。データの取得にはSELECTを使います。",
      "keyPoint": "SELECT＝データ取得、INSERT＝挿入、UPDATE＝更新、DELETE＝削除",
      "relatedTopics": ["DML", "CRUD", "WHERE句", "ORDER BY句"],
      "studyTip": "SQLの4つの基本操作（SELECT/INSERT/UPDATE/DELETE）とCRUDの対応を覚えておくと、SQL問題の基本が理解できます。"
    },
    "tags": ["SQL", "SELECT", "DML", "データベース基礎"]
  },
  {
    "questionId": "q-db-043",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "正規化",
    "level": 2,
    "question": "関係データベースの正規化に関する記述として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "正規化を行うとテーブル数が減少し、データベースの構造が単純になる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "正規化を行うとデータの重複を排除するためにテーブルが分割されるので、テーブル数は増加します。構造が単純になるのではなく、データの整合性が向上します。",
          "analogy": "大きな引き出し1つに何でも放り込むよりも、小さな引き出しに分類して収納するイメージです。引き出しの数は増えますが、整理整頓されます。"
        }
      },
      {
        "id": "b",
        "text": "正規化を行うとデータの冗長性が排除され、更新時の矛盾を防止できる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "正規化はデータの冗長性（同じデータの重複）を排除し、挿入異常・更新異常・削除異常といった問題を防ぐためのテーブル設計手法です。段階的に第1正規形、第2正規形、第3正規形と進みます。",
          "analogy": "住所録で同じ人の住所を10か所に書いていると、引っ越し時に全箇所を書き換えなければなりません。正規化は住所を1か所にまとめ、参照で管理する方法です。",
          "deepDive": "正規化の段階：第1正規形では繰り返し項目を排除し、第2正規形では部分関数従属を排除し、第3正規形では推移的関数従属を排除します。実務ではボイスコッド正規形（BCNF）まで行うことが多いですが、試験では第3正規形までを理解しておけば十分です。"
        }
      },
      {
        "id": "c",
        "text": "正規化を進めるほど、データの検索速度が常に向上する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "正規化を進めるとテーブルが分割されるため、データの検索時にテーブル間の結合（JOIN）が増え、検索速度が低下する場合があります。正規化はデータの整合性を重視した手法であり、速度向上を目的としたものではありません。",
          "analogy": "書類を細かく分類してファイルキャビネットに分けると整理は完璧ですが、1つの報告書を作るために複数のキャビネットを開けなければならなくなります。"
        }
      },
      {
        "id": "d",
        "text": "正規化はテーブル作成後には実施できない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "正規化はテーブル設計の段階で行うのが理想ですが、既存のテーブルに対しても構造を変更することで実施できます。ALTER TABLE文やデータ移行を使ってテーブルを再設計することが可能です。",
          "analogy": "部屋の模様替えはいつでもできるように、データベースの設計もあとから見直して改善することができます。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "正規化はデータの冗長性を排除してデータの整合性を保つためのテーブル設計手法です。正規化するとテーブル数は増えますが、更新時の矛盾を防止できます。",
      "keyPoint": "正規化の目的＝データの冗長性排除と更新異常の防止",
      "relatedTopics": ["第1正規形", "第2正規形", "第3正規形", "関数従属"],
      "studyTip": "正規化のメリット（整合性向上）とデメリット（結合増加による性能低下の可能性）の両面を理解しましょう。"
    },
    "tags": ["正規化", "冗長性", "データ整合性", "テーブル設計"]
  },
  {
    "questionId": "q-db-044",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "ER図",
    "level": 2,
    "question": "E-R図（Entity-Relationship Diagram）で表現される要素の組み合わせとして、正しいものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "エンティティ（実体）とリレーションシップ（関連）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "E-R図はエンティティ（Entity：実体）とリレーションシップ（Relationship：関連）を使ってデータ構造を視覚的に表現するための図法です。エンティティは長方形で、リレーションシップはひし形で表されます。",
          "analogy": "登場人物の相関図のようなもので、登場人物（エンティティ）と人物間の関係（リレーションシップ）を線で結んで表現します。",
          "deepDive": "E-R図にはさらに属性（アトリビュート：楕円で表現）も含まれます。リレーションシップには1対1、1対多、多対多の3種類の多重度があります。Peter Chenが1976年に提唱したモデルが基本ですが、現在はUMLのクラス図やIE記法（カラスの足記法）など派生した表記法も広く使われています。"
        }
      },
      {
        "id": "b",
        "text": "プロセス（処理）とデータフロー（データの流れ）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "プロセスとデータフローはDFD（データフロー図）の構成要素です。E-R図はデータの構造（静的な関係）を表すもので、処理の流れ（動的な処理）は扱いません。",
          "analogy": "「誰がどんな仕事をしているか」を表す組織図がDFD的なもので、「どんな部署があってどう繋がっているか」を表す組織図がE-R図的なものです。"
        }
      },
      {
        "id": "c",
        "text": "状態（ステート）と遷移（トランジション）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "状態と遷移は状態遷移図（ステートマシン図）の構成要素です。E-R図はデータ間の静的な関係を表現するもので、状態の変化は扱いません。",
          "analogy": "信号機の「赤→青→黄→赤」という変化を表すのが状態遷移図であり、E-R図とは目的が異なります。"
        }
      },
      {
        "id": "d",
        "text": "クラスとメソッド",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "クラスとメソッドはオブジェクト指向におけるUMLのクラス図の構成要素です。E-R図はデータベース設計に特化した図法で、メソッド（処理）は表現しません。",
          "analogy": "レシピ（メソッド）ではなく、食材の種類と組み合わせ（エンティティとリレーションシップ）を整理するのがE-R図の役割です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "E-R図はエンティティ（実体）とリレーションシップ（関連）でデータ構造を表現する図法です。データベースの概念設計で用いられます。",
      "keyPoint": "E-R図の構成要素＝エンティティ（実体）＋リレーションシップ（関連）＋属性",
      "relatedTopics": ["概念設計", "多重度", "DFD", "UML"],
      "studyTip": "E-R図はDFD（データの流れ）や状態遷移図（状態の変化）とは目的が異なることを区別して覚えましょう。"
    },
    "tags": ["ER図", "エンティティ", "リレーションシップ", "概念設計"]
  },
  {
    "questionId": "q-db-045",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "SQL応用",
    "level": 3,
    "question": "次のSQL文を実行した結果として、正しいものはどれか。\n\nSELECT 部署名, COUNT(*) AS 人数\nFROM 社員\nGROUP BY 部署名\nHAVING COUNT(*) >= 5;",
    "choices": [
      {
        "id": "a",
        "text": "社員テーブルの全行を部署名で並べ替えて表示する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "並べ替えを行うのはORDER BY句です。GROUP BY句はグループ化を行うためのもので、並べ替えとは異なります。",
          "analogy": "クラスで名前順に並ばせるのがORDER BY、出身地ごとにグループ分けするのがGROUP BYです。"
        }
      },
      {
        "id": "b",
        "text": "社員が5名以上いる部署ごとに部署名と所属人数を表示する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "GROUP BY部署名で部署ごとにグループ化し、COUNT(*)で各部署の人数を集計します。さらにHAVING COUNT(*) >= 5で集計結果が5以上のグループだけに絞り込みます。",
          "analogy": "学校のクラス分けで、各クラスの人数を数えて（GROUP BY + COUNT）、5人以上のクラスだけリストアップする（HAVING）ようなイメージです。",
          "deepDive": "WHERE句とHAVING句の違いを理解することが重要です。WHERE句はグループ化の前に個々の行を絞り込むのに対し、HAVING句はグループ化の後にグループ単位で絞り込みます。実行順序は FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY です。"
        }
      },
      {
        "id": "c",
        "text": "社員テーブルから先頭5行を部署名付きで表示する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "先頭N行を取得するにはLIMIT句やTOP句を使用します。HAVINGはグループ化後の条件指定であり、行数の制限とは関係ありません。",
          "analogy": "「5ページ目まで読む」のがLIMIT、「5冊以上ある棚だけ見る」のがHAVINGです。まったく異なる操作です。"
        }
      },
      {
        "id": "d",
        "text": "社員テーブルから社員番号が5以上のレコードを部署別に表示する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "個々のレコードの条件（社員番号 >= 5）で絞り込むのはWHERE句の役割です。HAVING句はグループ化後の集約結果に対して条件を適用するもので、個別レコードのフィルタリングには使いません。",
          "analogy": "一人ひとりの身長を測って条件で振り分けるのがWHERE、グループの平均身長で条件を付けるのがHAVINGです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "GROUP BY句でグループ化し、HAVING句でグループ単位の条件を指定します。WHEREは行単位、HAVINGはグループ単位の絞り込みです。",
      "keyPoint": "WHERE＝行の絞り込み（GROUP BY前）、HAVING＝グループの絞り込み（GROUP BY後）",
      "relatedTopics": ["GROUP BY", "HAVING", "WHERE", "集約関数", "COUNT"],
      "studyTip": "SQLの実行順序（FROM→WHERE→GROUP BY→HAVING→SELECT→ORDER BY）を覚えると、WHEREとHAVINGの違いが自然に理解できます。"
    },
    "tags": ["SQL", "GROUP BY", "HAVING", "集約関数", "COUNT"]
  },
  {
    "questionId": "q-db-046",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "トランザクション",
    "level": 4,
    "question": "データベースのトランザクションにおけるACID特性のうち、「原子性（Atomicity）」の説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "トランザクションの処理結果は永続的に保存され、障害が発生しても失われない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「耐久性（Durability）」の説明です。コミットされたデータがハードウェア障害等でも消失しないことを保証する特性です。",
          "analogy": "銀行に預けたお金が、銀行の建物が壊れても記録として残るのが耐久性です。"
        }
      },
      {
        "id": "b",
        "text": "トランザクションの処理は「すべて実行される」か「まったく実行されない」かのどちらかである",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "原子性（Atomicity）は、トランザクション内の一連の操作が「全部成功」か「全部取り消し」のどちらかであることを保証する特性です。途中で失敗した場合は、それまでの変更もすべてロールバック（取り消し）されます。",
          "analogy": "銀行振込で「Aさんの口座から引き落とし」と「Bさんの口座に入金」は2つでワンセットです。引き落としだけ成功して入金が失敗したら、引き落としも取り消されます。「半分だけ完了」は許されません。",
          "deepDive": "原子性を実現する仕組みとして、データベースはトランザクションログ（WAL: Write-Ahead Logging）を使用します。変更操作の前にログを記録し、障害時にはログを使ってロールバックを行います。これにより、中途半端な状態が発生しないことを保証します。"
        }
      },
      {
        "id": "c",
        "text": "複数のトランザクションが同時に実行されても、それぞれが順番に実行された場合と同じ結果になる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「独立性（Isolation）」の説明です。同時に実行されるトランザクション間で互いの処理が干渉しないことを保証する特性です。",
          "analogy": "レジが複数あっても、各お客さんの会計が他のお客さんの会計に影響しないのが独立性です。"
        }
      },
      {
        "id": "d",
        "text": "トランザクションの実行前後で、データベースの整合性制約が保たれる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「一貫性（Consistency）」の説明です。トランザクションの実行により、データベースが矛盾のない状態から別の矛盾のない状態に遷移することを保証します。",
          "analogy": "帳簿の借方と貸方の合計が常に一致するように、トランザクション前後でデータの整合性が保たれるのが一貫性です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ACID特性は原子性（Atomicity：全部か無か）、一貫性（Consistency：整合性維持）、独立性（Isolation：相互非干渉）、耐久性（Durability：永続的保存）の4つです。",
      "keyPoint": "A＝全部か無か、C＝整合性維持、I＝相互非干渉、D＝永続保存",
      "relatedTopics": ["コミット", "ロールバック", "トランザクションログ", "排他制御"],
      "studyTip": "ACID特性は4つの頭文字と意味をセットで正確に覚えましょう。試験ではそれぞれの説明を入れ替えて出題されることが多いです。"
    },
    "tags": ["ACID特性", "原子性", "トランザクション", "データベース管理"]
  },
  {
    "questionId": "q-db-047",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "排他制御",
    "level": 4,
    "question": "データベースの排他制御でデッドロックが発生する条件として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "1つのトランザクションが同じテーブルに対して2回ロックを取得した場合",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1つのトランザクションが同じリソースに複数回ロックを取得するのは再入ロック（リエントラントロック）であり、通常は問題なく処理されます。デッドロックは複数のトランザクション間で発生する現象です。",
          "analogy": "自分で自分の部屋の鍵を2回かけても問題はありません。デッドロックは2人が互いの部屋の鍵を持ち合っている状態です。"
        }
      },
      {
        "id": "b",
        "text": "2つのトランザクションが互いに相手がロックしているリソースを待ち合っている場合",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "デッドロックは、2つ以上のトランザクションが互いに相手がロックしているリソースの解放を待ち、永久に処理が進まなくなる状態です。例えば、トランザクションAがテーブルXをロックしてテーブルYの解放を待ち、トランザクションBがテーブルYをロックしてテーブルXの解放を待つと、デッドロックが発生します。",
          "analogy": "狭い廊下で2人が正面から来て、互いに「あなたが先にどいてください」と言い合って動けなくなる状態がデッドロックです。",
          "deepDive": "デッドロックの検出にはタイムアウト方式とデッドロック検出（待ちグラフ方式）があります。検出されると、一方のトランザクションが強制的にロールバックされます。デッドロックの予防策としては、①リソースのロック順序を統一する、②ロック保持時間を最小にする、③必要最小限の範囲でロックする、などがあります。"
        }
      },
      {
        "id": "c",
        "text": "ロックを取得せずに複数のトランザクションが同時にデータを更新した場合",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ロックなしで同時更新すると、更新内容が失われる「ロストアップデート（更新消失）」が起きる可能性がありますが、これはデッドロックとは異なる問題です。デッドロックはロックが取得されている状態で発生します。",
          "analogy": "2人が同時にホワイトボードに書くと文字が重なってしまうのがロストアップデートで、デッドロックとは別の問題です。"
        }
      },
      {
        "id": "d",
        "text": "トランザクションがロックを長時間保持し続けた場合",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ロックの長時間保持は他のトランザクションの待ち時間を増加させますが、それだけではデッドロックにはなりません。デッドロックには「互いに相手のロックを待つ」という循環的な依存関係が必要です。",
          "analogy": "一人がトイレを長時間使って他の人が待つのは「待ち行列」で、デッドロックではありません。デッドロックは2つのトイレを2人が互いに占有し合っている状態です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "デッドロックは、複数のトランザクションが互いに相手のロック解放を待ち合い、処理が進まなくなる状態です。循環的な待ち関係が発生条件です。",
      "keyPoint": "デッドロック＝複数トランザクションの循環的ロック待ち（互いに相手を待つ）",
      "relatedTopics": ["ロック", "排他制御", "ロールバック", "ACID特性"],
      "studyTip": "デッドロックは「互いに」がポイントです。一方的に待つだけではデッドロックにはならないことを理解しましょう。"
    },
    "tags": ["デッドロック", "排他制御", "ロック", "トランザクション"]
  },
  {
    "questionId": "q-db-048",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "インデックス",
    "level": 5,
    "question": "関係データベースにおけるB木インデックスに関する記述として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "B木インデックスは常にデータの挿入順序を保持して格納する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "B木インデックスはキー値の順序で木構造を構成しており、データの挿入順序を保持するものではありません。挿入順序を保持するのはログ構造やシーケンスなどです。",
          "analogy": "辞書は「あいうえお順」で整理されており、「最初に登録された単語順」ではありません。B木も同様にキー値の順で管理されます。"
        }
      },
      {
        "id": "b",
        "text": "B木インデックスを使用すると、データの更新処理（INSERT/UPDATE/DELETE）が常に高速化される",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "インデックスはデータ検索を高速化しますが、更新処理時にはインデックス自体の更新も必要になるため、更新処理はかえって遅くなることがあります。",
          "analogy": "本に索引を付けると検索は速くなりますが、本の内容を変更するたびに索引も書き直さなければならないので、変更作業は大変になります。"
        }
      },
      {
        "id": "c",
        "text": "B木インデックスはルートノードからリーフノードまでの距離が均一であり、検索性能が安定する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "B木（Balanced Tree）は平衡木であり、ルート（根）からすべてのリーフ（葉）までの深さが常に同じです。これにより、どのキー値を検索してもほぼ同じ回数のディスクアクセスで済み、安定した検索性能を実現します。",
          "analogy": "トーナメント表のように全ての選手（データ）が同じ回戦数で決勝（ルート）に到達する構造です。どの選手を探しても同じステップ数で見つけられます。",
          "deepDive": "B木はデータベースのインデックスとして最も広く使われる木構造です。B+木はB木の改良版で、すべてのデータをリーフノードに格納し、リーフノード同士をリンクで接続することで範囲検索を効率化しています。多くのRDBMSでは実際にはB+木が使用されています。"
        }
      },
      {
        "id": "d",
        "text": "B木インデックスはハッシュインデックスと同様に、等値検索のみをサポートする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ハッシュインデックスは等値検索（=）のみですが、B木インデックスは等値検索に加えて範囲検索（<, >, BETWEEN）や順序検索（ORDER BY）もサポートします。",
          "analogy": "ハッシュは「特定のロッカー番号で直接開ける」方式で、B木は「辞書で言葉の範囲を調べられる」方式です。B木のほうが柔軟な検索が可能です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "B木インデックスは平衡木構造で、ルートからリーフまでの深さが一定です。検索性能が安定し、等値検索と範囲検索の両方をサポートします。",
      "keyPoint": "B木＝平衡木（深さが均一で検索性能が安定）、等値検索＋範囲検索に対応",
      "relatedTopics": ["B+木", "ハッシュインデックス", "検索性能", "ディスクアクセス"],
      "studyTip": "B木の「B」はBalanced（平衡）に由来します。平衡であることが最大の特徴で、検索性能の安定性につながることを覚えておきましょう。"
    },
    "tags": ["B木", "インデックス", "平衡木", "検索性能"]
  },
  {
    "questionId": "q-db-049",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "ストアドプロシージャ",
    "level": 7,
    "question": "ストアドプロシージャを使用する利点として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "SQL文がクライアント側に保存されるため、デバッグが容易になる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ストアドプロシージャはクライアント側ではなく、データベースサーバ側に保存されます。デバッグはサーバ側で行う必要があり、むしろクライアント側のSQL文よりデバッグが複雑になる場合があります。",
          "analogy": "レストランの厨房で調理するレシピ（ストアドプロシージャ）は厨房に保管されるもので、お客さんのテーブル（クライアント側）に置くものではありません。"
        }
      },
      {
        "id": "b",
        "text": "あらかじめコンパイルされた処理をサーバ側で実行するため、ネットワーク通信量の削減とパフォーマンスの向上が期待できる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ストアドプロシージャはデータベースサーバに事前にコンパイル・格納されるため、①クライアントから長いSQL文を毎回送信する必要がなくネットワーク通信量が削減される、②実行のたびにSQL文を解析・コンパイルする必要がなくパフォーマンスが向上する、③複数のSQL文を1回の呼び出しで実行できる、といった利点があります。",
          "analogy": "毎回「ハンバーガーのパンを焼いて、レタスを洗って、パティを焼いて...」と細かく指示する代わりに、「Aセットお願いします」と一言で伝えるようなものです。手順はサーバ（厨房）に保存済みなので、通信量も調理開始までの時間も減ります。",
          "deepDive": "ストアドプロシージャのその他の利点として、セキュリティの向上（テーブルへの直接アクセスを禁止し、プロシージャ経由のみにできる）や、ビジネスロジックのサーバ集約（複数アプリケーションから共通処理を呼び出せる）があります。一方、デメリットとしてデバッグの複雑さやDBMS依存のコードになる点があります。"
        }
      },
      {
        "id": "c",
        "text": "データベースのテーブル構造を自動的に最適化してくれる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ストアドプロシージャはSQL文やロジックを事前に格納して実行する仕組みであり、テーブル構造の最適化を行う機能ではありません。テーブル構造の最適化は正規化やインデックスの設計で行います。",
          "analogy": "マニュアル通りに仕事をする従業員（ストアドプロシージャ）が、オフィスのレイアウト（テーブル構造）を自動的に変えるわけではありません。"
        }
      },
      {
        "id": "d",
        "text": "ストアドプロシージャを使用すると、トランザクション管理が不要になる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ストアドプロシージャ内でもトランザクション管理（BEGIN/COMMIT/ROLLBACK）は必要です。むしろ、プロシージャ内で複数の更新操作を行う場合は、適切なトランザクション管理がより重要になります。",
          "analogy": "作業マニュアル（ストアドプロシージャ）があっても、「ミスがあったら全部やり直し」というルール（トランザクション管理）は依然として必要です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ストアドプロシージャはDBサーバに事前コンパイルされた処理を格納する仕組みで、ネットワーク通信量の削減、パフォーマンスの向上、セキュリティの強化に寄与します。",
      "keyPoint": "ストアドプロシージャの利点＝通信量削減＋パフォーマンス向上＋セキュリティ強化",
      "relatedTopics": ["トリガ", "ファンクション", "SQL", "クライアントサーバ"],
      "studyTip": "ストアドプロシージャとトリガの違いも理解しておきましょう。ストアドプロシージャは明示的に呼び出すもの、トリガはイベント（INSERT等）で自動実行されるものです。"
    },
    "tags": ["ストアドプロシージャ", "パフォーマンス", "ネットワーク通信", "セキュリティ"]
  },
  {
    "questionId": "q-db-050",
    "examType": "科目A",
    "category": "テクノロジ系",
    "subcategory": "database",
    "topic": "データベース設計",
    "level": 8,
    "question": "データベースの3層スキーマアーキテクチャ（外部スキーマ、概念スキーマ、内部スキーマ）の目的として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "データベースへのアクセス速度を3倍に向上させる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "3層スキーマアーキテクチャは性能向上を目的としたものではなく、データ独立性を実現するための論理的な抽象化の仕組みです。むしろ、抽象層が増えることでオーバーヘッドが生じる可能性もあります。",
          "analogy": "会社の組織を「経営層・管理層・実務層」に分けるのは業務効率を3倍にするためではなく、各層の役割を分離して独立性を確保するためです。"
        }
      },
      {
        "id": "b",
        "text": "データの論理的な構造と物理的な格納方法を分離し、データ独立性を実現する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "3層スキーマアーキテクチャの目的は「データ独立性」の実現です。外部スキーマ（利用者の視点：ビュー）、概念スキーマ（全体の論理構造：テーブル定義）、内部スキーマ（物理的格納方法：ファイル配置やインデックス）を分離することで、ある層の変更が他の層に影響しないようにします。",
          "analogy": "レストランで例えると、メニュー（外部スキーマ：お客さんに見せる情報）、レシピ（概念スキーマ：料理の全体構成）、冷蔵庫の配置（内部スキーマ：食材の物理的な保管方法）を分けて管理するようなものです。冷蔵庫を変えてもレシピは変わらず、レシピが変わってもメニューの見せ方は独立に変更できます。",
          "deepDive": "データ独立性には「論理データ独立性」（概念スキーマを変更しても外部スキーマに影響しない）と「物理データ独立性」（内部スキーマを変更しても概念スキーマに影響しない）の2種類があります。この3層スキーマはANSI/SPARCが1975年に提唱したモデルであり、現代のRDBMSの基盤となる考え方です。"
        }
      },
      {
        "id": "c",
        "text": "3人のデータベース管理者が同時にスキーマを編集できるようにする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "3層スキーマの「3」は管理者の数ではなく、データの抽象化レベル（外部・概念・内部）の数です。複数人での同時編集を実現するための仕組みではありません。",
          "analogy": "「3階建てのビル」は3人が住むための建物ではなく、フロアごとに機能を分ける（1階は店舗、2階はオフィス、3階は住居）ための構造です。"
        }
      },
      {
        "id": "d",
        "text": "データベースのバックアップを3世代にわたって保持する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "3層スキーマアーキテクチャはバックアップの世代管理とは全く関係がありません。バックアップの世代管理は運用管理の領域であり、データベースの設計構造の概念とは異なります。",
          "analogy": "建物の設計図（スキーマ）と、建物の保険（バックアップ）は全く別の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "3層スキーマアーキテクチャは、外部スキーマ・概念スキーマ・内部スキーマの3層に分離することで、データ独立性（論理データ独立性と物理データ独立性）を実現する仕組みです。",
      "keyPoint": "3層スキーマ＝外部（利用者視点）・概念（論理構造）・内部（物理格納）→データ独立性の実現",
      "relatedTopics": ["データ独立性", "ANSI/SPARC", "概念設計", "物理設計"],
      "studyTip": "3つのスキーマの対応関係を覚えましょう：外部スキーマ＝ビュー、概念スキーマ＝テーブル定義、内部スキーマ＝ファイル配置・インデックス。"
    },
    "tags": ["3層スキーマ", "データ独立性", "外部スキーマ", "概念スキーマ", "内部スキーマ"]
  }
]
