[
  {
    "questionId": "q-dev-011",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "スクラム",
    "level": 1,
    "question": "アジャイル開発のフレームワークであるスクラムにおいて、開発チームが一定期間で成果物を作る開発サイクルを何と呼ぶか。",
    "choices": [
      {
        "id": "a",
        "text": "スプリント",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "スクラムでは、1〜4週間程度の固定された期間で開発を行うサイクルを「スプリント」と呼びます。各スプリントの終わりに動作するソフトウェアを完成させることが目標です。",
          "analogy": "料理のコース料理のようなものです。一度に全品を出すのではなく、前菜→スープ→メイン→デザートと、一品ずつ完成させて提供していきます。各スプリントは一品を完成させる期間です。",
          "deepDive": "スプリントの長さはプロジェクト開始時に決定し、原則として途中で変更しません。スプリント中にスプリントプランニング、デイリースクラム、スプリントレビュー、スプリントレトロスペクティブといったイベントが行われます。"
        }
      },
      {
        "id": "b",
        "text": "イテレーション",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "イテレーションは反復型開発全般で使われる用語で、スクラム固有の用語ではありません。スクラムではこの反復サイクルを特に「スプリント」と呼びます。",
          "analogy": "「走る」が一般的な表現なら、「スプリント（短距離走）」はより具体的な表現です。同じ概念ですが、スクラムでは専用の名前があります。"
        }
      },
      {
        "id": "c",
        "text": "フェーズ",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "フェーズはウォーターフォールモデルなどで使われる「工程」を表す用語です。スクラムの反復サイクルを指す用語ではありません。",
          "analogy": "フェーズは「建設の第1期工事、第2期工事」のような段階的な進め方で、繰り返しのサイクルとは異なります。"
        }
      },
      {
        "id": "d",
        "text": "マイルストーン",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "マイルストーンはプロジェクトの主要な節目や目標地点を示す用語で、開発サイクルそのものを指す言葉ではありません。",
          "analogy": "マラソンの「5km地点」「10km地点」のような目印であり、走り方（サイクル）そのものではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "スクラムにおける固定期間の開発サイクルは「スプリント」と呼ばれ、通常1〜4週間で設定されます。",
      "keyPoint": "スクラムの開発サイクル＝スプリント（1〜4週間の固定期間）",
      "relatedTopics": [
        "アジャイル開発",
        "スクラムマスター",
        "プロダクトバックログ"
      ],
      "studyTip": "スクラムの3つの役割（プロダクトオーナー、スクラムマスター、開発チーム）と5つのイベントをセットで覚えましょう。"
    },
    "tags": [
      "スクラム",
      "アジャイル",
      "スプリント"
    ]
  },
  {
    "questionId": "q-dev-012",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "レビュー技法",
    "level": 1,
    "question": "ソフトウェア開発において、作成者がレビュー参加者に成果物の内容を説明しながら問題点を発見するレビュー技法はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "インスペクション",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "インスペクションは、モデレータ（司会者）が主導し、チェックリストなどを用いて体系的に欠陥を検出する最も形式的なレビュー技法です。作成者が説明するウォークスルーとは進め方が異なります。",
          "analogy": "建物の公式な検査（インスペクション）では、検査官が主導してチェックリストで確認します。住人が案内するのとは違います。"
        }
      },
      {
        "id": "b",
        "text": "ウォークスルー",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ウォークスルーは、成果物の作成者がレビュー参加者に内容を順を追って説明（ウォークスルー＝歩いて通る）しながら、問題点や改善点を発見するレビュー技法です。",
          "analogy": "不動産の内覧と同じです。物件のオーナー（作成者）が「ここがリビングで、こちらがキッチンです」と案内しながら、参加者が気づいた問題を指摘します。",
          "deepDive": "ウォークスルーはインスペクションほど形式的ではなく、作成者主導で進められます。比較的気軽に実施でき、設計書やコードなど様々な成果物に対して行えます。"
        }
      },
      {
        "id": "c",
        "text": "ラウンドロビン",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ラウンドロビンは、参加者が順番に意見を述べるレビュー方式で、作成者が説明するウォークスルーとは進め方が異なります。",
          "analogy": "円卓会議のように全員が順番に発言する方式で、ガイド付きの案内とは異なります。"
        }
      },
      {
        "id": "d",
        "text": "パスアラウンド",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "パスアラウンドは、成果物を回覧してレビュー者が個別にコメントする方式です。作成者が説明する場を設けるウォークスルーとは異なります。",
          "analogy": "回覧板のように書類を回して各自がコメントを書き込む方式で、対面で説明を受けるのとは違います。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ウォークスルーは作成者がレビュー参加者に成果物を説明しながら問題点を見つけるレビュー技法です。インスペクションより形式的でなく、作成者主導で進められます。",
      "keyPoint": "ウォークスルー＝作成者が説明、インスペクション＝モデレータが主導",
      "relatedTopics": [
        "インスペクション",
        "ピアレビュー",
        "品質管理"
      ],
      "studyTip": "レビュー技法は形式の度合いで区別しましょう。形式的な順にインスペクション＞ウォークスルー＞パスアラウンドです。"
    },
    "tags": [
      "レビュー技法",
      "ウォークスルー",
      "品質管理"
    ]
  },
  {
    "questionId": "q-dev-013",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "UML",
    "level": 2,
    "question": "UML（統一モデリング言語）のダイアグラムのうち、オブジェクト間のメッセージのやり取りを時系列で表現するものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "クラス図",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "クラス図はシステムの静的な構造（クラスの属性やメソッド、クラス間の関係）を表す図であり、時系列のメッセージのやり取りは表現しません。",
          "analogy": "クラス図は建物の設計図のようなもので、部屋の配置や構造は分かりますが、住人の動きは分かりません。"
        }
      },
      {
        "id": "b",
        "text": "ユースケース図",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ユースケース図はシステムの機能とアクター（利用者）の関係を表す図であり、オブジェクト間の詳細なメッセージのやり取りは表現しません。",
          "analogy": "レストランのメニュー表のように「何ができるか」は分かりますが、「どういう順番でやるか」は分かりません。"
        }
      },
      {
        "id": "c",
        "text": "シーケンス図",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "シーケンス図は、オブジェクト間のメッセージのやり取りを時系列に沿って上から下に表現するUMLの図です。縦軸が時間の流れ、横軸にオブジェクトを配置し、矢印でメッセージを示します。",
          "analogy": "LINEのグループチャットの履歴のようなものです。誰が誰にいつメッセージを送ったかが、時間順に上から下に並んでいます。",
          "deepDive": "シーケンス図は相互作用図の一種で、特にメッセージの順序が重要な場面で使用されます。同期メッセージ（実線矢印）と非同期メッセージ（点線矢印）、戻り値なども表現できます。"
        }
      },
      {
        "id": "d",
        "text": "状態遷移図",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "状態遷移図はオブジェクトの状態変化とその契機（イベント）を表す図です。オブジェクト間のメッセージのやり取りを時系列で表すものではありません。",
          "analogy": "信号機が「青→黄→赤」と状態が変わる様子を表す図で、信号機同士の会話ではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "シーケンス図は、UMLにおいてオブジェクト間のメッセージのやり取りを時系列で表現する図です。",
      "keyPoint": "シーケンス図＝オブジェクト間のメッセージを時系列で表現",
      "relatedTopics": [
        "クラス図",
        "ユースケース図",
        "コミュニケーション図"
      ],
      "studyTip": "UMLの各図の目的を整理しましょう。構造を表す図（クラス図等）と振る舞いを表す図（シーケンス図等）に大別できます。"
    },
    "tags": [
      "UML",
      "シーケンス図",
      "設計"
    ]
  },
  {
    "questionId": "q-dev-014",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "モジュール結合度",
    "level": 2,
    "question": "モジュール間の結合度において、最も結合度が低い（望ましい）ものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "内容結合",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "内容結合は、あるモジュールが別のモジュールの内部データや処理を直接参照・変更するもので、最も結合度が高い（望ましくない）結合です。",
          "analogy": "他人の家に勝手に入って、冷蔵庫の中身を動かすようなものです。完全にプライバシー侵害で、最悪の関係です。"
        }
      },
      {
        "id": "b",
        "text": "共通結合",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "共通結合は、複数のモジュールがグローバル変数（共有データ）を介してデータをやり取りするもので、結合度は高い方に分類されます。",
          "analogy": "シェアハウスの共有冷蔵庫のようなもので、誰かが中身を変えると他の住人にも影響が出ます。"
        }
      },
      {
        "id": "c",
        "text": "データ結合",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "データ結合は、モジュール間で必要なデータだけを引数として受け渡す結合で、最も結合度が低い（望ましい）結合です。各モジュールの独立性が最も高くなります。",
          "analogy": "宅配便のようなものです。必要な荷物（データ）だけを受け渡しし、送り主の家の中に入る必要はありません。お互いの生活に干渉しない理想的な関係です。",
          "deepDive": "結合度は低い方から高い方へ、データ結合→スタンプ結合→制御結合→外部結合→共通結合→内容結合の順です。設計ではできるだけ低い結合度を目指します。"
        }
      },
      {
        "id": "d",
        "text": "制御結合",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "制御結合は、あるモジュールが別のモジュールの処理を制御するためのフラグ（制御情報）を渡す結合で、データ結合より結合度が高いです。",
          "analogy": "リモコンで他の人の行動を操作するようなもので、データだけの受け渡しより干渉度が高くなります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "モジュール結合度は低いほど望ましく、データ結合が最も結合度が低い（最も望ましい）結合です。必要なデータだけを引数で受け渡します。",
      "keyPoint": "結合度：低い方が良い。データ結合（最低）→スタンプ→制御→外部→共通→内容（最高）",
      "relatedTopics": [
        "モジュール凝集度",
        "ソフトウェア設計",
        "構造化設計"
      ],
      "studyTip": "結合度は「低いほど良い」、凝集度は「高いほど良い」です。結合度の6段階を順番に覚えましょう。"
    },
    "tags": [
      "モジュール結合度",
      "ソフトウェア設計",
      "構造化設計"
    ]
  },
  {
    "questionId": "q-dev-015",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "ソフトウェア品質",
    "level": 3,
    "question": "ソフトウェアの品質特性を定義したISO/IEC 25010において、ソフトウェアが指定された条件の下で使用されたとき、明示的ニーズ及び暗黙のニーズを満足させる度合いを示す特性はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "機能適合性",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "機能適合性は、ソフトウェアが明示的ニーズ及び暗黙のニーズを満足させる機能を提供する度合いを示す品質特性です。機能完全性、機能正確性、機能適切性の3つの副特性を持ちます。",
          "analogy": "レストランで注文した料理が「メニュー通りに出てくるか」「期待通りの味か」ということです。お客さんの注文（明示的ニーズ）も、言わなくても期待すること（暗黙のニーズ：適切な温度、清潔な食器）も満たすことです。",
          "deepDive": "ISO/IEC 25010は8つの品質特性（機能適合性、性能効率性、互換性、使用性、信頼性、セキュリティ、保守性、移植性）を定義しています。旧規格ISO/IEC 9126からの改訂版です。"
        }
      },
      {
        "id": "b",
        "text": "信頼性",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "信頼性は、ソフトウェアが指定された条件の下で、指定された期間、故障なく機能し続ける度合いです。ニーズの満足度ではなく、安定して動き続けることに焦点を当てています。",
          "analogy": "車が故障せずに走り続ける能力のことで、車が目的地に正しく着けるか（機能適合性）とは別の話です。"
        }
      },
      {
        "id": "c",
        "text": "使用性",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "使用性は、ソフトウェアがユーザーにとって理解しやすく、使いやすい度合いです。機能がニーズを満たすかではなく、その機能をどれだけ簡単に使えるかに焦点があります。",
          "analogy": "リモコンのボタンが分かりやすく配置されているかどうかで、リモコンが正しく機能するかとは別の話です。"
        }
      },
      {
        "id": "d",
        "text": "保守性",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "保守性は、ソフトウェアの修正や改良のしやすさの度合いです。利用者のニーズの満足度ではなく、開発者がメンテナンスしやすいかに焦点があります。",
          "analogy": "車のエンジンが整備しやすい構造かどうかで、車が目的地に着けるかとは別の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ISO/IEC 25010における機能適合性は、明示的・暗黙的ニーズを満足させる度合いを示す品質特性です。",
      "keyPoint": "機能適合性＝ニーズを満たす機能を提供する度合い（ISO/IEC 25010の8特性の1つ）",
      "relatedTopics": [
        "ISO/IEC 25010",
        "品質特性",
        "非機能要件"
      ],
      "studyTip": "ISO/IEC 25010の8つの品質特性を覚えて、それぞれが何を測定するかを理解しましょう。"
    },
    "tags": [
      "品質特性",
      "ISO/IEC 25010",
      "機能適合性"
    ]
  },
  {
    "questionId": "q-dev-016",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "テスト技法",
    "level": 3,
    "question": "境界値分析のテストケースとして適切なものはどれか。入力値の有効範囲が1〜100の整数の場合を考える。",
    "choices": [
      {
        "id": "a",
        "text": "0, 1, 100, 101をテストする",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "境界値分析では、有効範囲の境界とその前後の値をテストします。有効範囲が1〜100の場合、下限の境界値（0, 1）と上限の境界値（100, 101）をテストすることで、境界付近のバグを効率的に検出できます。",
          "analogy": "プールの水深制限が1m〜2mの場合、ちょうど制限ライン付近（0.9m, 1.0m, 2.0m, 2.1m）をチェックするのが境界値分析です。ラインぎりぎりでミスが起きやすいからです。",
          "deepDive": "境界値分析は同値分割法と組み合わせて使うことが多いです。バグは境界付近に集中する傾向があるため、少ないテストケースで効率的にバグを発見できます。"
        }
      },
      {
        "id": "b",
        "text": "50だけをテストする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "50は有効範囲の中間値であり、境界値ではありません。境界値分析では範囲の端とその前後をテストします。",
          "analogy": "プールの中央で泳いでも安全なのは当たり前で、制限ラインぎりぎりをチェックすることが重要です。"
        }
      },
      {
        "id": "c",
        "text": "1, 50, 100をテストする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "1と100は境界値ですが、50は中間値であり境界値分析のテストケースとしては不十分です。また、境界の外側（0と101）のテストが欠けています。",
          "analogy": "プールの端だけでなく、端の一歩外側も確認しないと、制限が正しく機能しているか分かりません。"
        }
      },
      {
        "id": "d",
        "text": "-100, 0, 200をテストする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これらは境界値から大きく離れた値であり、境界値分析のテストケースとしては適切ではありません。境界値分析では境界のすぐ内側と外側をテストします。",
          "analogy": "プールの水深制限をチェックするのに、地上10mや海底100mを調べても意味がありません。制限ラインの前後を調べるべきです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "境界値分析では、有効範囲の境界値とその直前・直後の値をテストケースとして使用します。",
      "keyPoint": "境界値分析＝有効範囲の端とその前後（例：0,1,100,101）をテスト",
      "relatedTopics": [
        "同値分割法",
        "ブラックボックステスト",
        "テスト設計"
      ],
      "studyTip": "「バグは境界に潜む」と覚えましょう。有効範囲の内側ぎりぎりと外側ぎりぎりの値をテストします。"
    },
    "tags": [
      "境界値分析",
      "テスト技法",
      "ブラックボックステスト"
    ]
  },
  {
    "questionId": "q-dev-017",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "アジャイル開発",
    "level": 4,
    "question": "エクストリームプログラミング（XP）のプラクティスとして、適切でないものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ペアプログラミング",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ペアプログラミングはXPの代表的なプラクティスです。2人1組でプログラミングを行い、リアルタイムでコードレビューすることで品質を高めます。",
          "analogy": "ペアプログラミングは、運転手とナビゲーターが協力してドライブするようなものです。2人で確認するのでミスが減ります。"
        }
      },
      {
        "id": "b",
        "text": "テスト駆動開発（TDD）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "テスト駆動開発はXPのプラクティスの1つです。コードを書く前にテストを先に書き、テストが通るようにコードを実装する手法です。",
          "analogy": "テストを先に書くのは、答え合わせの基準を先に決めてから問題を解くようなものです。何が正解か明確にしてから作業します。"
        }
      },
      {
        "id": "c",
        "text": "継続的インテグレーション（CI）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "継続的インテグレーションはXPのプラクティスです。コードの変更を頻繁にメインラインに統合し、自動テストで問題を早期発見します。",
          "analogy": "毎日部屋を少しずつ掃除して、常にきれいな状態を保つのと同じです。まとめてやると大変ですが、こまめにやれば楽です。"
        }
      },
      {
        "id": "d",
        "text": "ガントチャートによる進捗管理",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ガントチャートはウォーターフォール型の計画駆動型プロジェクトで主に使われる進捗管理ツールです。XPでは、ストーリーカードやバーンダウンチャートなどアジャイル固有の手法で進捗を管理するため、ガントチャートはXPのプラクティスには含まれません。",
          "analogy": "ガントチャートは長距離列車の時刻表のようなもので、あらかじめ全行程を計画します。XPは気ままな旅のように、状況に応じて柔軟にルートを変えるスタイルです。",
          "deepDive": "XPの主要プラクティスには、ペアプログラミング、TDD、CI、リファクタリング、小規模リリース、共同所有、計画ゲーム、シンプルデザインなどがあります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ガントチャートはウォーターフォール型の進捗管理手法であり、XPのプラクティスではありません。XPではペアプログラミング、TDD、CIなどを実践します。",
      "keyPoint": "XPプラクティス＝ペアプログラミング、TDD、CI、リファクタリング等。ガントチャートはXPに含まれない",
      "relatedTopics": [
        "アジャイル開発",
        "スクラム",
        "リーン開発"
      ],
      "studyTip": "XPの主要プラクティスを一覧で覚え、ウォーターフォール的な手法との違いを理解しましょう。"
    },
    "tags": [
      "XP",
      "アジャイル",
      "開発プラクティス"
    ]
  },
  {
    "questionId": "q-dev-018",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "モジュール凝集度",
    "level": 4,
    "question": "モジュールの凝集度（コヒージョン）に関する記述のうち、最も凝集度が高い（望ましい）ものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "モジュール内のすべての処理が、単一の機能を実現するために必要な処理だけで構成されている",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "これは「機能的凝集」の説明であり、凝集度が最も高い（最も望ましい）タイプです。モジュール内のすべての処理が1つの明確な目的のために存在し、無関係な処理が含まれていません。",
          "analogy": "専門店のようなものです。パン屋さんはパンだけを作る専門店で、余計なものは作りません。1つのことに集中しているので品質が高くなります。",
          "deepDive": "凝集度は高い方から低い方へ、機能的凝集→情報的凝集→連絡的凝集→手順的凝集→時間的凝集→論理的凝集→偶発的凝集の7段階があります。"
        }
      },
      {
        "id": "b",
        "text": "モジュール内の処理が、実行する順序だけが関連している",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「手順的凝集」の説明で、凝集度は中程度です。処理の順序は決まっていますが、各処理が同じ目的のためにあるとは限りません。",
          "analogy": "朝のルーティン（起床→歯磨き→着替え→朝食）のように順番は決まっていますが、それぞれ別の目的です。"
        }
      },
      {
        "id": "c",
        "text": "モジュール内の処理が、同じ時点で実行される必要があるという理由だけで集められている",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「時間的凝集」の説明で、凝集度は低い方に分類されます。同じタイミングで実行されるだけで、機能的な関連は弱いです。",
          "analogy": "年末の大掃除のように、「年末だから」という理由で無関係な作業がまとめられている状態です。"
        }
      },
      {
        "id": "d",
        "text": "モジュール内の処理が、たまたま同じモジュールに含まれているだけで関連性がない",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これは「偶発的凝集」の説明で、凝集度が最も低い（最も望ましくない）タイプです。処理間に全く関連がありません。",
          "analogy": "引き出しに適当に物を詰め込んだ状態で、ハサミ、お菓子、電池が無関係に入っている「ガラクタ引き出し」です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "凝集度が最も高いのは機能的凝集で、モジュール内の全処理が単一の機能の実現に集中しています。",
      "keyPoint": "凝集度：高い方が良い。機能的凝集（最高）→偶発的凝集（最低）の7段階",
      "relatedTopics": [
        "モジュール結合度",
        "構造化設計",
        "ソフトウェアアーキテクチャ"
      ],
      "studyTip": "結合度は「低い方が良い」、凝集度は「高い方が良い」です。凝集度の7段階を語呂合わせで覚えましょう。"
    },
    "tags": [
      "凝集度",
      "ソフトウェア設計",
      "モジュール設計"
    ]
  },
  {
    "questionId": "q-dev-019",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "DevOps",
    "level": 5,
    "question": "DevOpsの説明として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "開発チーム（Dev）と運用チーム（Ops）が連携・協力し、ソフトウェアの開発からリリース、運用までを迅速かつ確実に行う考え方",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "DevOpsは、Development（開発）とOperations（運用）を組み合わせた造語で、開発チームと運用チームが密に連携し、継続的にソフトウェアを改善・デリバリーするための文化・プラクティス・ツールの総称です。",
          "analogy": "料理人（開発）とホールスタッフ（運用）が仕切りなく協力するレストランのようなものです。「料理を作る人」と「お客様に届ける人」が密にコミュニケーションすることで、お客様の要望に素早く応えられます。",
          "deepDive": "DevOpsの主要な実践には、CI/CD、Infrastructure as Code、監視・ログ管理、マイクロサービス、コンテナ化などがあります。ツールとしてはGit、Jenkins、Docker、Kubernetesなどが代表的です。"
        }
      },
      {
        "id": "b",
        "text": "データベースの設計と運用を専門的に行うチーム体制のこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "DevOpsはデータベース専門のチーム体制ではありません。ソフトウェア全体の開発と運用の連携を指す概念です。",
          "analogy": "レストランの厨房全体の話をしているのに、食器洗い係だけの話と勘違いしている状態です。"
        }
      },
      {
        "id": "c",
        "text": "開発環境と本番環境を完全に分離して管理する手法のこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "DevOpsは開発と運用の「連携」を重視する考え方であり、環境を分離して管理する手法のことではありません。むしろ環境の差異を減らし、一貫した方法で管理することを目指します。",
          "analogy": "壁で仕切るのではなく、壁を取り払って協力する考え方です。"
        }
      },
      {
        "id": "d",
        "text": "ソフトウェア開発を外部の企業に委託して行うこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "外部委託はアウトソーシングであり、DevOpsとは全く異なる概念です。DevOpsは組織内の開発チームと運用チームの協力体制に関する考え方です。",
          "analogy": "家事を外注するのと、家族が協力して家事を分担するのは全く違う話です。DevOpsは後者に近い考え方です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "DevOpsは開発（Dev）と運用（Ops）が連携して、ソフトウェアの迅速かつ確実なデリバリーを実現する考え方・文化です。",
      "keyPoint": "DevOps＝開発と運用の連携・協力により、迅速で確実なソフトウェアデリバリーを実現",
      "relatedTopics": [
        "CI/CD",
        "アジャイル開発",
        "Infrastructure as Code"
      ],
      "studyTip": "DevOpsは単なるツールではなく「文化・考え方」であることを理解しましょう。CI/CDとの関連もセットで覚えます。"
    },
    "tags": [
      "DevOps",
      "開発運用",
      "CI/CD"
    ]
  },
  {
    "questionId": "q-dev-020",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "CI/CD",
    "level": 5,
    "question": "継続的インテグレーション（CI）に関する記述として、最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "開発者がコードの変更をリポジトリに頻繁に統合し、自動的にビルドとテストを実行することで問題を早期に発見する手法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "CIは、開発者が作成・変更したコードを共有リポジトリに頻繁に（少なくとも1日1回以上）統合し、その都度自動的にビルドとテストを実行する手法です。これにより統合時の問題を早期に発見・修正できます。",
          "analogy": "毎日少しずつ部屋を片付けるのと同じです。散らかったままにすると年末の大掃除が大変ですが、毎日片付ければ常にきれいな状態を保てます。コードも毎日統合すれば、大きな問題が溜まりません。",
          "deepDive": "CIの主要なツールにはJenkins、GitHub Actions、GitLab CI、CircleCIなどがあります。CDはCIの延長で、継続的デリバリー（テスト済みのコードを自動でステージング環境にデプロイ）と継続的デプロイメント（本番環境まで自動デプロイ）があります。"
        }
      },
      {
        "id": "b",
        "text": "月に一度、全ての変更をまとめてテストし、リリースする手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "月に一度のまとめてテスト・リリースはCIの考え方とは正反対です。CIは「頻繁に」統合・テストを行うことがポイントです。",
          "analogy": "月に一度の大掃除では、途中で大きな問題が発生していても気づけません。毎日チェックするのがCIの考え方です。"
        }
      },
      {
        "id": "c",
        "text": "本番環境にデプロイする前に、手動で確認テストを行うこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "手動での確認テストはCIの特徴ではありません。CIの核心は「自動的に」ビルドとテストを実行することにあります。",
          "analogy": "毎日人間がチェックするのは大変ですが、自動掃除ロボットが毎日掃除してくれるようなものがCIです。"
        }
      },
      {
        "id": "d",
        "text": "ソフトウェアの設計書を継続的に更新し続けること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "設計書の継続的な更新はCIの定義ではありません。CIはソースコードの統合とビルド・テストの自動化に焦点を当てた手法です。",
          "analogy": "書類を更新し続けることと、実際の製品を頻繁にチェックすることは別の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "CIは、コード変更を頻繁にリポジトリに統合し、自動ビルド・テストで問題を早期発見する手法です。",
      "keyPoint": "CI＝頻繁なコード統合＋自動ビルド・テスト→問題の早期発見",
      "relatedTopics": [
        "CD（継続的デリバリー/デプロイメント）",
        "DevOps",
        "自動テスト"
      ],
      "studyTip": "CI（統合の自動化）とCD（デリバリー/デプロイの自動化）の違いを明確にしましょう。"
    },
    "tags": [
      "CI/CD",
      "継続的インテグレーション",
      "DevOps"
    ]
  },
  {
    "questionId": "q-dev-021",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "ウォーターフォールモデル",
    "level": 6,
    "question": "ウォーターフォールモデルの特徴として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "各工程を順番に進め、前の工程には原則として戻らない",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "ウォーターフォールモデルは要件定義→設計→実装→テスト→運用の各工程を滝の水が流れるように順に進め、前工程に戻らないことを原則とする開発モデルです。",
          "analogy": "滝の水が上から下に一方通行で流れるように、前の工程には戻りません。マンション建設で基礎工事→骨組み→内装と順番に進めるのと似ています。",
          "deepDive": "実際には手戻りが発生することがあり、その際のコストが大きいことが課題です。大規模で要件が明確なプロジェクトに適しています。"
        }
      },
      {
        "id": "b",
        "text": "短い期間のサイクルを繰り返して段階的に開発する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはアジャイル開発や反復型開発の特徴です。ウォーターフォールモデルは反復ではなく一方通行で進めます。",
          "analogy": "料理を少しずつ作って味見するのがアジャイル、レシピ通りに最後まで一気に作るのがウォーターフォールです。"
        }
      },
      {
        "id": "c",
        "text": "プロトタイプを先に作成して要件を確認する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "プロトタイプ先行はプロトタイピングモデルの特徴です。ウォーターフォールでは最初に要件を確定させてから設計・実装に進みます。",
          "analogy": "試食品を先に出すのがプロトタイピング、メニューを決めてからフルコースを作るのがウォーターフォールです。"
        }
      },
      {
        "id": "d",
        "text": "ユーザーのフィードバックを毎週受けて方向性を修正する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "頻繁なフィードバックはアジャイル開発の特徴です。ウォーターフォールでは各工程の完了後にレビューを行います。",
          "analogy": "毎週お客さんに試食してもらうのがアジャイル、完成してから評価してもらうのがウォーターフォールです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "ウォーターフォールモデルは各工程を順番に進める一方通行型の開発モデルです。大規模で要件が明確なプロジェクトに適しています。",
      "keyPoint": "ウォーターフォール＝順次進行・手戻りなし、アジャイル＝反復・柔軟",
      "relatedTopics": [
        "アジャイル開発",
        "Vモデル",
        "スパイラルモデル"
      ],
      "studyTip": "各開発モデルの特徴と適用場面を比較表にまとめて覚えましょう。"
    },
    "tags": [
      "ウォーターフォール",
      "開発モデル",
      "ソフトウェア開発"
    ]
  },
  {
    "questionId": "q-dev-022",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "ホワイトボックステスト",
    "level": 6,
    "question": "ホワイトボックステストにおいて、プログラム中の全ての分岐（判定条件の真偽両方）を少なくとも1回は実行するカバレッジ基準はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "命令網羅（ステートメントカバレッジ）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "命令網羅は全ての命令文を1回実行することが基準で、分岐の真偽両方を網羅する必要はありません。",
          "analogy": "遊園地のアトラクション全部に1回乗ればOKだが、各アトラクションの別ルートは通らなくてもいい基準です。"
        }
      },
      {
        "id": "b",
        "text": "分岐網羅（ブランチカバレッジ）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "分岐網羅（判定条件網羅）は、プログラム中の全ての分岐で真と偽の両方を少なくとも1回は実行するカバレッジ基準です。命令網羅より厳しい基準です。",
          "analogy": "遊園地の全ての分かれ道で、右ルートと左ルートの両方を最低1回は通る基準です。",
          "deepDive": "カバレッジの強さ：命令網羅＜分岐網羅＜条件網羅＜複合条件網羅の順で厳しくなります。"
        }
      },
      {
        "id": "c",
        "text": "経路網羅（パスカバレッジ）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "経路網羅は全ての実行経路を網羅する基準で、分岐網羅より厳しいです。ループがある場合は経路が無限になることもあり、実用的でない場合があります。",
          "analogy": "遊園地の全ての道の組み合わせを通る基準で、非常に大変です。"
        }
      },
      {
        "id": "d",
        "text": "条件網羅（コンディションカバレッジ）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "条件網羅は各条件式の中の個々の条件が真偽両方を取ることを求める基準で、分岐網羅とは異なる概念です。",
          "analogy": "分岐の判断理由（条件）の一つ一つを検査する基準で、分岐結果を検査する分岐網羅とは視点が違います。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "分岐網羅は全ての分岐で真偽両方を実行するカバレッジ基準です。命令網羅より厳しく、経路網羅より緩い基準です。",
      "keyPoint": "カバレッジ強度：命令網羅＜分岐網羅＜条件網羅＜経路網羅",
      "relatedTopics": [
        "ホワイトボックステスト",
        "テストカバレッジ",
        "構造テスト"
      ],
      "studyTip": "各カバレッジ基準の違いを具体的なコード例で理解しましょう。"
    },
    "tags": [
      "ホワイトボックステスト",
      "カバレッジ",
      "テスト技法"
    ]
  },
  {
    "questionId": "q-dev-023",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "リファクタリング",
    "level": 6,
    "question": "リファクタリングの説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "外部から見た動作を変えずに、プログラムの内部構造を改善すること",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "リファクタリングは、ソフトウェアの外部的な振る舞い（機能）を変えずに、内部のコード構造を改善する作業です。保守性や可読性を向上させます。",
          "analogy": "家の外観は変えずに内装をリフォームするようなものです。住み心地（保守性）は良くなりますが、外から見た家の形（機能）は変わりません。",
          "deepDive": "リファクタリングの代表的な手法：メソッドの抽出、変数名の変更、重複コードの統合など。マーチン・ファウラーの著書が有名です。"
        }
      },
      {
        "id": "b",
        "text": "新しい機能を追加してソフトウェアをバージョンアップすること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "機能追加は機能拡張であり、リファクタリングではありません。リファクタリングは「動作を変えない」ことが前提です。",
          "analogy": "家に新しい部屋を増築するのは機能追加であり、内装のリフォーム（リファクタリング）とは別です。"
        }
      },
      {
        "id": "c",
        "text": "バグを修正してソフトウェアを正しく動作させること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "バグ修正は動作を変える作業であり、リファクタリングの定義とは異なります。",
          "analogy": "壊れた水道管を修理するのはバグ修正で、きれいに配管し直すのがリファクタリングです。"
        }
      },
      {
        "id": "d",
        "text": "古いシステムを新しい技術で作り直すこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "システムの作り直しはリライトやマイグレーションであり、リファクタリングとは規模が異なります。",
          "analogy": "家を建て替えるのは「作り直し」、内装だけリフォームするのが「リファクタリング」です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "リファクタリングは外部動作を変えずに内部構造を改善する作業です。保守性と可読性の向上が目的です。",
      "keyPoint": "リファクタリング＝動作を変えずに構造を改善（内装リフォーム）",
      "relatedTopics": [
        "クリーンコード",
        "技術的負債",
        "コードレビュー"
      ],
      "studyTip": "リファクタリングは「動作を変えない」のがポイントです。テストが必要な理由も理解しましょう。"
    },
    "tags": [
      "リファクタリング",
      "コード品質",
      "保守性"
    ]
  },
  {
    "questionId": "q-dev-024",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "スパイラルモデル",
    "level": 6,
    "question": "スパイラルモデルの特徴として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "計画→リスク分析→開発→評価のサイクルを繰り返しながら段階的にシステムを成長させる",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "スパイラルモデルは計画、リスク分析、開発（エンジニアリング）、評価の4つのフェーズを渦巻状に繰り返しながらシステムを段階的に構築するモデルです。リスク管理を重視する点が特徴です。",
          "analogy": "渦巻き状に回りながら上昇する螺旋階段のように、同じステップを繰り返しながらもシステムは徐々に完成に近づきます。各周回でリスクを確認してから次に進みます。",
          "deepDive": "バリー・ベームが提唱しました。ウォーターフォールの計画性とプロトタイピングの柔軟性を組み合わせたモデルで、大規模でリスクの高いプロジェクトに適しています。"
        }
      },
      {
        "id": "b",
        "text": "全工程を一度だけ順番に実行する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "一度だけ順番に実行するのはウォーターフォールモデルの特徴です。スパイラルモデルはサイクルを繰り返します。",
          "analogy": "一度だけ通る一方通行の道（ウォーターフォール）ではなく、何周も回る螺旋道路です。"
        }
      },
      {
        "id": "c",
        "text": "最初にプロトタイプを完成させてからのみ開発を進める",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "プロトタイプ先行のみの開発はプロトタイピングモデルです。スパイラルモデルはプロトタイピングを含みますが、リスク分析を中心に繰り返し開発を行う点が異なります。",
          "analogy": "試作品を1つだけ作って確認するのではなく、何度も改良を繰り返しながら完成度を上げます。"
        }
      },
      {
        "id": "d",
        "text": "テスト工程を省略して開発速度を上げる",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "テストの省略はどの開発モデルでも推奨されません。スパイラルモデルでは各サイクルで評価（テスト含む）を行います。",
          "analogy": "安全確認を省くのは近道に見えて事故のもとです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "スパイラルモデルはリスク分析を重視しながらサイクルを繰り返して段階的にシステムを構築するモデルです。",
      "keyPoint": "スパイラルモデル＝計画→リスク分析→開発→評価の繰り返し（リスク管理重視）",
      "relatedTopics": [
        "ウォーターフォール",
        "アジャイル",
        "プロトタイピング"
      ],
      "studyTip": "各開発モデルの特徴とリスクへのアプローチの違いを整理しましょう。"
    },
    "tags": [
      "スパイラルモデル",
      "開発モデル",
      "リスク管理"
    ]
  },
  {
    "questionId": "q-dev-025",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "統合テスト",
    "level": 7,
    "question": "モジュールの統合テストにおいて、上位モジュールから下位モジュールへ順に統合していくテスト手法はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "トップダウンテスト",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "トップダウンテストは上位モジュールから開始し、下位モジュールをスタブ（仮のモジュール）で代用しながら段階的に統合していく手法です。システム全体の骨組みを先に確認できます。",
          "analogy": "家を建てるとき、屋根→壁→床の順に上から作るイメージです。下の部分は仮の支え（スタブ）で代用しながら進めます。",
          "deepDive": "スタブは下位モジュールの代替として、固定値を返すなどの簡易的な動作をします。対照的にボトムアップテストではドライバが上位モジュールの代替として使われます。"
        }
      },
      {
        "id": "b",
        "text": "ボトムアップテスト",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ボトムアップテストは下位モジュールから上位へ統合していく手法で、ドライバを使用します。トップダウンとは逆方向です。",
          "analogy": "家の基礎→壁→屋根と下から建てていく方式です。"
        }
      },
      {
        "id": "c",
        "text": "ビッグバンテスト",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ビッグバンテストは全モジュールを一度に統合してテストする方法で、段階的な統合は行いません。問題の特定が困難です。",
          "analogy": "全ての部品を一気に組み立てる「一発勝負」で、どこが悪いか分かりにくいです。"
        }
      },
      {
        "id": "d",
        "text": "回帰テスト",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "回帰テスト（リグレッションテスト）は変更後に既存機能が正常に動作するか確認するテストで、統合の方向とは無関係です。",
          "analogy": "修理後に他の場所が壊れていないか確認するテストです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "トップダウンテストは上位から下位へ段階的に統合するテスト手法で、スタブを使用します。",
      "keyPoint": "トップダウン＝上位→下位（スタブ使用）、ボトムアップ＝下位→上位（ドライバ使用）",
      "relatedTopics": [
        "ボトムアップテスト",
        "スタブ",
        "ドライバ",
        "結合テスト"
      ],
      "studyTip": "トップダウン→スタブ、ボトムアップ→ドライバの対応を必ず覚えましょう。"
    },
    "tags": [
      "統合テスト",
      "トップダウン",
      "スタブ"
    ]
  },
  {
    "questionId": "q-dev-026",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "Vモデル",
    "level": 7,
    "question": "ソフトウェア開発のVモデルにおいて、詳細設計に対応するテストレベルはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "単体テスト",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "Vモデルでは、開発工程とテスト工程がV字型に対応します。詳細設計に対応するのは単体テスト（ユニットテスト）で、個々のモジュールが詳細設計通りに動作するかを検証します。",
          "analogy": "設計図の各部品（詳細設計）がちゃんと動くか、部品ごとに検査する（単体テスト）ようなものです。",
          "deepDive": "Vモデルの対応：要件定義→受入テスト、基本設計→システムテスト、詳細設計→結合テスト/単体テスト。"
        }
      },
      {
        "id": "b",
        "text": "結合テスト",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "結合テストは基本設計（外部設計）に対応するテストレベルで、モジュール間のインタフェースが正しく動作するかを検証します。",
          "analogy": "部品同士を組み合わせたときにちゃんと動くかの検査です。"
        }
      },
      {
        "id": "c",
        "text": "システムテスト",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "システムテストは要件定義に対応し、システム全体が要件を満たしているかを検証します。",
          "analogy": "完成品全体が注文通りの仕様を満たしているかの最終検査です。"
        }
      },
      {
        "id": "d",
        "text": "受入テスト",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "受入テストはユーザーの要件（ビジネス要件）に対応し、ユーザーが実際に使って合格判定するテストです。",
          "analogy": "お客さんが完成品を見て「これでOK」と判断する検収テストです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "Vモデルでは詳細設計に対応するのは単体テストです。開発工程とテスト工程がV字型に対応関係を持ちます。",
      "keyPoint": "要件定義↔受入テスト、基本設計↔結合テスト、詳細設計↔単体テスト",
      "relatedTopics": [
        "ウォーターフォール",
        "テストレベル",
        "品質保証"
      ],
      "studyTip": "Vモデルの対応関係をV字の図で覚えましょう。左が開発、右がテストです。"
    },
    "tags": [
      "Vモデル",
      "テストレベル",
      "開発モデル"
    ]
  },
  {
    "questionId": "q-dev-027",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "オブジェクト指向",
    "level": 7,
    "question": "オブジェクト指向の概念において、既存クラスの属性やメソッドを引き継いで新しいクラスを作成する機能はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "カプセル化",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "カプセル化はデータと操作を一体化し、外部から直接アクセスできないようにする機能です。クラスの引き継ぎとは異なります。",
          "analogy": "カプセル化は「薬のカプセル」のように中身を隠して、決められた方法でだけ使えるようにすることです。"
        }
      },
      {
        "id": "b",
        "text": "継承（インヘリタンス）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "継承は親クラス（スーパークラス）の属性やメソッドを子クラス（サブクラス）が引き継ぐ機能です。コードの再利用性を高め、階層的なクラス構造を実現します。",
          "analogy": "親から子に受け継がれる「遺伝」のようなもので、親クラスの性質を子クラスが自然に持ちます。子クラスは親にない新しい特徴を追加することもできます。",
          "deepDive": "継承には単一継承と多重継承があります。Javaでは単一継承のみ、C++では多重継承をサポートしています。"
        }
      },
      {
        "id": "c",
        "text": "ポリモーフィズム（多態性）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ポリモーフィズムは同じメソッド名でもオブジェクトの型によって異なる振る舞いをする機能です。",
          "analogy": "「鳴く」という同じ命令でも、犬は「ワン」、猫は「ニャー」と鳴くように、型によって動作が変わることです。"
        }
      },
      {
        "id": "d",
        "text": "抽象化",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "抽象化は共通の特徴を抽出して一般化する概念で、具体的な機能名としては使いません。",
          "analogy": "犬・猫・鳥に共通する「動物」という概念を作ることが抽象化です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "継承は親クラスの機能を子クラスが引き継ぐオブジェクト指向の重要な機能です。コードの再利用性を高めます。",
      "keyPoint": "オブジェクト指向の三大要素：カプセル化・継承・ポリモーフィズム",
      "relatedTopics": [
        "カプセル化",
        "ポリモーフィズム",
        "クラス図",
        "UML"
      ],
      "studyTip": "オブジェクト指向の三大要素（カプセル化・継承・ポリモーフィズム）を例と共に覚えましょう。"
    },
    "tags": [
      "オブジェクト指向",
      "継承",
      "クラス設計"
    ]
  },
  {
    "questionId": "q-dev-028",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "デザインパターン",
    "level": 7,
    "question": "ソフトウェアの設計において、クラスのインスタンスが1つだけ存在することを保証するデザインパターンはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "シングルトンパターン",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "シングルトンパターンは、あるクラスのインスタンスが1つだけ生成されることを保証し、そのインスタンスへのグローバルなアクセスポイントを提供するデザインパターンです。",
          "analogy": "会社の社長は1人だけです。「社長室に行けば必ず同じ社長がいる」のがシングルトンで、社長が2人いたら混乱します。",
          "deepDive": "GoF（Gang of Four）デザインパターンの1つで、データベース接続やログ管理などで使われます。スレッドセーフな実装が必要な場合があります。"
        }
      },
      {
        "id": "b",
        "text": "ファクトリパターン",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ファクトリパターンはインスタンスの生成を専用のメソッドに委譲するパターンで、複数のインスタンスを生成できます。",
          "analogy": "ファクトリ（工場）は製品を何個でも作れます。1つだけ保証するシングルトンとは目的が異なります。"
        }
      },
      {
        "id": "c",
        "text": "オブザーバパターン",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "オブザーバパターンはオブジェクトの状態変化を他のオブジェクトに通知する仕組みで、インスタンス数の制限とは関係ありません。",
          "analogy": "SNSの「フォロー」のように、更新があったら通知する仕組みです。"
        }
      },
      {
        "id": "d",
        "text": "ストラテジパターン",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ストラテジパターンはアルゴリズムをクラスとして切り出し、動的に切り替え可能にするパターンです。",
          "analogy": "カーナビの「最短ルート」「高速優先」のように、戦略（アルゴリズム）を切り替える仕組みです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "シングルトンパターンはインスタンスを1つだけ保証するデザインパターンです。グローバルに共有するリソースの管理に使われます。",
      "keyPoint": "シングルトン＝インスタンスは1つだけ（社長は1人）",
      "relatedTopics": [
        "GoFデザインパターン",
        "ファクトリパターン",
        "オブジェクト指向設計"
      ],
      "studyTip": "代表的なデザインパターン（シングルトン、ファクトリ、オブザーバ、ストラテジ）の用途を覚えましょう。"
    },
    "tags": [
      "デザインパターン",
      "シングルトン",
      "設計"
    ]
  },
  {
    "questionId": "q-dev-029",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "CMMI",
    "level": 8,
    "question": "CMMI（能力成熟度モデル統合）の成熟度レベルにおいて、プロセスが定義され組織全体で標準化されている段階はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "レベル2：管理された",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "レベル2はプロジェクト単位でプロセスが管理されている段階ですが、組織全体での標準化はされていません。",
          "analogy": "各店舗が独自のやり方で運営しているが、一応は管理されている状態です。"
        }
      },
      {
        "id": "b",
        "text": "レベル3：定義された",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "レベル3は組織全体でプロセスが標準化・文書化され、全プロジェクトがその標準プロセスに従って開発を行う段階です。",
          "analogy": "全国チェーンのファストフード店のように、どの店舗でも同じマニュアルに従って同じ品質のサービスを提供している状態です。",
          "deepDive": "CMMIの5段階：レベル1（初期）→レベル2（管理された）→レベル3（定義された）→レベル4（定量的に管理された）→レベル5（最適化している）。"
        }
      },
      {
        "id": "c",
        "text": "レベル4：定量的に管理された",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "レベル4は統計的手法を用いてプロセスのパフォーマンスを定量的に管理する段階で、レベル3より上位です。",
          "analogy": "マニュアル通りに運営するだけでなく、数値データを分析して品質を科学的に管理している状態です。"
        }
      },
      {
        "id": "d",
        "text": "レベル5：最適化している",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "レベル5は継続的なプロセス改善を行っている最上位の段階です。",
          "analogy": "常に最高の方法を追求し、自律的に改善し続けている理想の状態です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "CMMIレベル3「定義された」は、組織全体でプロセスが標準化されている段階です。全プロジェクトが共通プロセスに従います。",
      "keyPoint": "CMMI: Lv1=初期, Lv2=プロジェクト管理, Lv3=組織標準化, Lv4=定量管理, Lv5=継続改善",
      "relatedTopics": [
        "品質管理",
        "プロセス改善",
        "ISO 12207"
      ],
      "studyTip": "CMMIの5段階を1つずつの特徴と一緒に覚えましょう。"
    },
    "tags": [
      "CMMI",
      "プロセス改善",
      "品質管理"
    ]
  },
  {
    "questionId": "q-dev-030",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "コードメトリクス",
    "level": 8,
    "question": "ソフトウェアの複雑さを測定する指標として、プログラム中の独立した実行経路の数を数える指標はどれか。",
    "choices": [
      {
        "id": "a",
        "text": "サイクロマティック複雑度",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "サイクロマティック複雑度（循環的複雑度）は、プログラムの制御フローグラフにおける独立した実行経路の数を測定する指標です。値が大きいほどプログラムが複雑で、テストやメンテナンスが困難になります。",
          "analogy": "迷路の分かれ道の数のようなもので、分かれ道が多いほど迷路は複雑になります。プログラムも分岐が多いほど複雑です。",
          "deepDive": "計算式：M = E - N + 2P（E=辺の数、N=ノード数、P=連結成分数）。一般に10以下が望ましく、20を超えると複雑すぎるとされます。"
        }
      },
      {
        "id": "b",
        "text": "LOC（Lines of Code）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "LOCはプログラムの行数を数える指標で、複雑さではなく規模を測定します。行数が多くても複雑でない場合もあります。",
          "analogy": "本のページ数（LOC）が多いからといって、内容が複雑とは限りません。"
        }
      },
      {
        "id": "c",
        "text": "ファンクションポイント",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ファンクションポイントはソフトウェアの機能量を測定する指標で、プログラムの複雑さの直接的な指標ではありません。",
          "analogy": "レストランのメニュー数（機能量）が多いことと、各料理の調理工程が複雑なことは別の話です。"
        }
      },
      {
        "id": "d",
        "text": "コードカバレッジ",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "コードカバレッジはテストがコードのどれだけの部分を実行したかを示す指標で、コードの複雑さとは異なります。",
          "analogy": "カバレッジは「迷路のどこまで探検したか」で、迷路の複雑さ自体ではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "サイクロマティック複雑度は独立した実行経路の数でプログラムの複雑さを測る指標です。値が10以下が望ましいとされます。",
      "keyPoint": "サイクロマティック複雑度＝分岐の多さ＝プログラムの複雑さ",
      "relatedTopics": [
        "コードメトリクス",
        "品質管理",
        "テスト設計"
      ],
      "studyTip": "サイクロマティック複雑度＝分岐の多さと覚えましょう。テストケース数の最小値の目安にもなります。"
    },
    "tags": [
      "サイクロマティック複雑度",
      "メトリクス",
      "品質"
    ]
  },
  {
    "questionId": "q-dev-031",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "テスト自動化",
    "level": 8,
    "question": "回帰テスト（リグレッションテスト）の目的として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ソフトウェアの変更により、既存機能に影響が出ていないことを確認する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "回帰テストは、ソフトウェアに変更（バグ修正、機能追加等）を加えた後、その変更によって既存の正常に動作していた機能に悪影響（デグレード）が出ていないかを確認するテストです。",
          "analogy": "車の修理後に、修理した箇所だけでなく他の部分も正常に動くか確認する「修理後の総点検」のようなものです。",
          "deepDive": "回帰テストは自動化の効果が最も高いテストの一つです。変更のたびに繰り返し実行するため、CI/CDパイプラインに組み込んで自動実行することが一般的です。"
        }
      },
      {
        "id": "b",
        "text": "新しく追加した機能が要件通りに動作するか確認する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "新機能の動作確認は機能テストであり、回帰テストの主な目的とは異なります。回帰テストは既存機能への影響確認です。",
          "analogy": "新しい部品が動くかの確認と、新しい部品を付けたことで他が壊れていないかの確認は別のテストです。"
        }
      },
      {
        "id": "c",
        "text": "性能要件（応答時間やスループット）を満たしているか確認する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "性能の確認は性能テスト（パフォーマンステスト）であり、回帰テストではありません。",
          "analogy": "車の速度テストと修理後の総点検は別の目的のテストです。"
        }
      },
      {
        "id": "d",
        "text": "セキュリティの脆弱性がないか確認する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "セキュリティの脆弱性チェックはセキュリティテストや脆弱性診断であり、回帰テストとは異なります。",
          "analogy": "防犯チェックと修理後の動作チェックは目的が異なります。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "回帰テストはソフトウェア変更後に既存機能への悪影響がないことを確認するテストです。CI/CDで自動化されることが多いです。",
      "keyPoint": "回帰テスト＝変更後に既存機能が壊れていないか確認（デグレード検知）",
      "relatedTopics": [
        "CI/CD",
        "テスト自動化",
        "デグレード"
      ],
      "studyTip": "回帰テスト＝「元に戻っていないか（回帰していないか）」の確認と覚えましょう。"
    },
    "tags": [
      "回帰テスト",
      "テスト技法",
      "品質保証"
    ]
  },
  {
    "questionId": "q-dev-032",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "マイクロサービス",
    "level": 8,
    "question": "マイクロサービスアーキテクチャの特徴として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "アプリケーションを小さな独立したサービスの集合として構築し、各サービスが独立してデプロイ可能である",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "マイクロサービスアーキテクチャは、大きなアプリケーションを機能ごとの小さなサービスに分割し、各サービスが独立して開発・テスト・デプロイできる設計手法です。APIを通じてサービス間が連携します。",
          "analogy": "大きなレストラン1つではなく、専門の小さな店（寿司屋、ラーメン屋、カフェ）がフードコートのように集まって、全体として大きなサービスを提供するイメージです。",
          "deepDive": "対比されるのがモノリシックアーキテクチャ（一枚岩）で、全機能が一体化しています。マイクロサービスはDockerやKubernetesとの親和性が高く、クラウドネイティブな開発で広く採用されています。"
        }
      },
      {
        "id": "b",
        "text": "全ての機能を1つの大きなアプリケーションとして一体的に開発する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "これはモノリシックアーキテクチャの特徴です。マイクロサービスは機能を分割して独立させます。",
          "analogy": "一つの巨大な工場（モノリシック）ではなく、専門工場の集合体（マイクロサービス）です。"
        }
      },
      {
        "id": "c",
        "text": "クライアント側でデータ処理を行い、サーバの負荷を軽減する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "クライアント側処理はクライアントサーバモデルの話で、マイクロサービスの特徴ではありません。",
          "analogy": "お客さんに自分で料理させる（クライアント処理）のと、専門店を分ける（マイクロサービス）のは別の話です。"
        }
      },
      {
        "id": "d",
        "text": "データベースを1つに統合して全サービスで共有する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "マイクロサービスでは各サービスが自分専用のデータストアを持つことが推奨されます。共有データベースはモノリシック的な設計です。",
          "analogy": "各専門店が独自の冷蔵庫を持つのがマイクロサービス流で、全店共有の冷蔵庫1つではありません。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "マイクロサービスは機能ごとの独立したサービスの集合体としてアプリケーションを構築する設計手法です。",
      "keyPoint": "マイクロサービス＝小さな独立サービスの集合（各自がデプロイ可能）",
      "relatedTopics": [
        "モノリシック",
        "Docker",
        "Kubernetes",
        "API"
      ],
      "studyTip": "マイクロサービスとモノリシックの違いを比較して理解しましょう。"
    },
    "tags": [
      "マイクロサービス",
      "アーキテクチャ",
      "クラウドネイティブ"
    ]
  },
  {
    "questionId": "q-dev-033",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "コンテナ技術",
    "level": 9,
    "question": "コンテナ技術の特徴として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "OSカーネルを共有し、アプリケーションとその依存関係を軽量にパッケージ化して実行する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "コンテナはホストOSのカーネルを共有し、アプリケーションとライブラリ等の実行環境を軽量にパッケージ化して隔離実行する技術です。仮想マシンよりも起動が速く、リソース消費が少ないのが特徴です。",
          "analogy": "仮想マシンが「家ごと引っ越す」なら、コンテナは「スーツケース1つで引っ越す」ようなもので、必要最小限のものだけ持ち運びます。基盤（OS）は共有します。",
          "deepDive": "代表的なコンテナ技術にDockerがあります。コンテナオーケストレーション（Kubernetes）を使うと、大量のコンテナの管理・スケーリングが自動化できます。"
        }
      },
      {
        "id": "b",
        "text": "各アプリケーションに専用のOSを割り当てて完全に隔離する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "専用OSの割り当ては仮想マシン（VM）の特徴です。コンテナはOSカーネルを共有するため、VMより軽量です。",
          "analogy": "VMは各人に家（OS）を丸ごと用意しますが、コンテナは同じ家を間仕切り（名前空間）で区切って住みます。"
        }
      },
      {
        "id": "c",
        "text": "プログラミング言語に依存しないバイトコードで実行する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "バイトコード実行はJava仮想マシン（JVM）の特徴であり、コンテナの特徴ではありません。",
          "analogy": "翻訳機（JVM）を使うのとは違い、コンテナは実行環境そのものをパッケージ化します。"
        }
      },
      {
        "id": "d",
        "text": "物理サーバを増設してスケールアウトする",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "物理サーバの増設はインフラ層の話で、コンテナ技術の特徴ではありません。コンテナはソフトウェアレベルの仮想化です。",
          "analogy": "建物を増やすのはハードウェア、部屋の間取りを変えるのがコンテナです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "コンテナはOSカーネルを共有して軽量にアプリケーションを実行する技術です。VMより起動が速く、リソース効率が高いです。",
      "keyPoint": "コンテナ＝OSカーネル共有＋軽量な隔離実行（VM＝OS丸ごと分離）",
      "relatedTopics": [
        "Docker",
        "Kubernetes",
        "仮想マシン",
        "DevOps"
      ],
      "studyTip": "コンテナとVMの違いを図で理解しましょう。コンテナはOS層を共有する点がポイントです。"
    },
    "tags": [
      "コンテナ",
      "Docker",
      "仮想化"
    ]
  },
  {
    "questionId": "q-dev-034",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "ソフトウェアメトリクス",
    "level": 9,
    "question": "ソフトウェアの信頼性を評価する指標として、単位時間あたりの障害発生件数の逆数で表されるものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "MTBF（平均故障間隔）",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "MTBF（Mean Time Between Failures）は故障と故障の間の平均稼働時間で、値が大きいほど信頼性が高いことを示します。単位時間あたりの障害件数（故障率）の逆数です。",
          "analogy": "MTBFは「車が故障せずに走れる平均距離」のようなもので、長いほど信頼できる車（ソフトウェア）です。",
          "deepDive": "関連指標：MTTR（平均修復時間）＝修理にかかる平均時間。稼働率＝MTBF/(MTBF+MTTR)で計算されます。"
        }
      },
      {
        "id": "b",
        "text": "MTTR（平均修復時間）",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "MTTRは障害発生から復旧までの平均時間で、修復の速さを示す保守性の指標です。信頼性（故障しにくさ）とは異なります。",
          "analogy": "MTTRは「病気になったときの治療時間」で、病気のなりにくさ（MTBF）とは別です。"
        }
      },
      {
        "id": "c",
        "text": "稼働率",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "稼働率はシステムが正常に動作している時間の割合で、MTBF/(MTBF+MTTR)で計算されます。障害発生件数の逆数そのものではありません。",
          "analogy": "稼働率は「1年のうち何日営業できたか」の割合で、故障間隔そのものではありません。"
        }
      },
      {
        "id": "d",
        "text": "スループット",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "スループットは単位時間あたりの処理量を示す性能指標で、信頼性の指標ではありません。",
          "analogy": "スループットは「1時間に何個の製品を作れるか」で、機械が壊れにくいかとは別の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "MTBFは故障間の平均稼働時間で、ソフトウェアの信頼性を表す指標です。値が大きいほど信頼性が高いです。",
      "keyPoint": "MTBF＝信頼性（壊れにくさ）、MTTR＝保守性（直しやすさ）、稼働率＝MTBF/(MTBF+MTTR)",
      "relatedTopics": [
        "MTTR",
        "稼働率",
        "可用性",
        "信頼性工学"
      ],
      "studyTip": "MTBF、MTTR、稼働率の関係式を必ず覚えましょう。計算問題が頻出です。"
    },
    "tags": [
      "MTBF",
      "信頼性",
      "メトリクス"
    ]
  },
  {
    "questionId": "q-dev-035",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "Infrastructure as Code",
    "level": 9,
    "question": "Infrastructure as Code（IaC）の説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "インフラ構成をコードとして定義し、自動的に環境を構築・管理する手法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "IaCはサーバ、ネットワーク、ストレージなどのインフラ構成を設定ファイル（コード）として記述し、バージョン管理・自動構築を可能にする手法です。手動操作を排除して再現性と効率を高めます。",
          "analogy": "IaCは「料理のレシピ」のようなもので、レシピ通りに作れば誰でも同じ料理（環境）が再現できます。手作業（目分量）だと毎回違う結果になるリスクがあります。",
          "deepDive": "代表的なIaCツールにTerraform、Ansible、AWS CloudFormation、Puppetなどがあります。GitOpsの考え方ではIaCコードをGitで管理し、変更をPRベースで承認します。"
        }
      },
      {
        "id": "b",
        "text": "ハードウェアをプログラミング言語で直接制御する技術",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ハードウェアの直接制御は組み込みプログラミングやファームウェアの領域で、IaCとは異なります。",
          "analogy": "機械の部品を直接動かすのではなく、「こういう環境を作って」という設計書（コード）で管理するのがIaCです。"
        }
      },
      {
        "id": "c",
        "text": "開発者がインフラ構築のスキルを持つこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "人のスキルセットの話ではなく、インフラ管理の手法の名称です。",
          "analogy": "料理の腕前（スキル）とレシピ（IaC）は別物です。"
        }
      },
      {
        "id": "d",
        "text": "クラウドサービスを利用してインフラを借りること",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "クラウド利用はIaaS等のサービスモデルであり、IaCとは異なる概念です。IaCはオンプレミスでも使えます。",
          "analogy": "キッチンを借りる（クラウド）のとレシピを用意する（IaC）は別の話です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "IaCはインフラ構成をコードで定義して自動管理する手法です。再現性、バージョン管理、自動化のメリットがあります。",
      "keyPoint": "IaC＝インフラ構成をコード化して自動管理（レシピ通りの環境構築）",
      "relatedTopics": [
        "DevOps",
        "Terraform",
        "クラウド",
        "GitOps"
      ],
      "studyTip": "IaCはDevOpsの重要プラクティスです。「コードとしてバージョン管理できる」点がポイントです。"
    },
    "tags": [
      "IaC",
      "DevOps",
      "自動化"
    ]
  },
  {
    "questionId": "q-dev-036",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "技術的負債",
    "level": 9,
    "question": "技術的負債（Technical Debt）の説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "短期的な開発速度を優先した結果、将来的に追加コストが必要になるソフトウェアの品質上の問題",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "技術的負債は、速度優先のために適切でない設計や実装を行った結果、将来の変更・保守にかかるコストが増大する問題です。借金のように「利子」が膨らみ続けます。",
          "analogy": "急いで建てた仮設住宅のようなもので、目先は安く速く建てられますが、後から修理費用がどんどんかかります。きちんと建てておけば後の費用は少なくて済みます。",
          "deepDive": "技術的負債の種類：意図的な負債（期限を優先して意図的に妥協）と非意図的な負債（スキル不足による質の低いコード）があります。定期的なリファクタリングで返済します。"
        }
      },
      {
        "id": "b",
        "text": "IT投資に失敗して発生した金銭的な損失",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "技術的負債は金銭的な借金ではなく、ソフトウェア品質の比喩的な「負債」です。",
          "analogy": "実際のお金を借りたわけではなく、コード品質の「借り」が溜まっている状態です。"
        }
      },
      {
        "id": "c",
        "text": "レガシーシステムの運用コスト",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "レガシーシステムの運用コストは技術的負債の結果の一つですが、定義そのものではありません。新しいシステムでも技術的負債は発生します。",
          "analogy": "借金の返済（運用コスト）は負債の結果であり、負債そのものではありません。"
        }
      },
      {
        "id": "d",
        "text": "開発ツールのライセンス費用",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "ライセンス費用は通常の開発コストであり、技術的負債とは無関係です。",
          "analogy": "工具の購入費は正当な経費であり、「手抜き工事の後始末」とは違います。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "技術的負債は速度優先の結果として蓄積される品質問題で、将来の保守コスト増大につながります。",
      "keyPoint": "技術的負債＝短期優先の代償として将来のコストが増加（借金の利子が膨らむ）",
      "relatedTopics": [
        "リファクタリング",
        "コード品質",
        "保守性"
      ],
      "studyTip": "技術的負債は「借金」の比喩で理解しましょう。返さないと利子（追加コスト）が膨らみます。"
    },
    "tags": [
      "技術的負債",
      "品質管理",
      "開発プロセス"
    ]
  },
  {
    "questionId": "q-dev-037",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "形式手法",
    "level": 10,
    "question": "ソフトウェア開発における形式手法（フォーマルメソッド）の説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "数学的な記法と論理を用いてソフトウェアの仕様を厳密に定義・検証する手法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "形式手法は数学的な記法（形式言語）を用いてソフトウェアの仕様を厳密に記述し、数学的な証明によって正しさを検証する手法です。安全性が特に重要なシステム（航空機、医療機器等）で使用されます。",
          "analogy": "通常の設計書が「日本語の説明文」なら、形式手法は「数学の証明」のようなもので、曖昧さがなく論理的に正しいことを証明できます。",
          "deepDive": "代表的な形式手法にはZ記法、VDM、Bメソッド、モデル検査（SPIN等）があります。全てのシステムに適用するのはコストが高いため、安全性重視の部分に限定して適用することが多いです。"
        }
      },
      {
        "id": "b",
        "text": "テストケースを自動生成してテストを効率化する手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "テストケースの自動生成はテスト自動化の手法であり、形式手法とは異なります。形式手法はテストではなく証明に基づきます。",
          "analogy": "実験（テスト）で確認するのではなく、数学的な証明で正しさを示すのが形式手法です。"
        }
      },
      {
        "id": "c",
        "text": "書類のフォーマットを統一して品質管理を行う手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "書類フォーマットの統一は文書管理であり、形式手法の「形式」とは意味が異なります。",
          "analogy": "「形式」は「書式」ではなく「数学的形式」を意味します。"
        }
      },
      {
        "id": "d",
        "text": "チーム開発の作法やルールを定めた開発規約のこと",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "開発規約はコーディングスタンダードなどであり、数学的な検証手法である形式手法とは異なります。",
          "analogy": "チームのルールブック（規約）と数学の証明（形式手法）は別物です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "形式手法は数学的記法で仕様を厳密に定義・検証する手法で、安全性が特に重要なシステムで使用されます。",
      "keyPoint": "形式手法＝数学的に正しさを証明する厳密な手法",
      "relatedTopics": [
        "Z記法",
        "モデル検査",
        "安全性検証",
        "高信頼性システム"
      ],
      "studyTip": "形式手法は「数学による証明」がキーワードです。テストとの違いを理解しましょう。"
    },
    "tags": [
      "形式手法",
      "検証",
      "高信頼性"
    ]
  },
  {
    "questionId": "q-dev-038",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "見積り手法",
    "level": 10,
    "question": "ソフトウェア開発の見積り手法であるCOCOMO（Constructive Cost Model）に関する説明として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ソフトウェアの規模（LOC等）から開発工数やコストを数学的モデルで算出する手法",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "COCOMOはバリー・ベームが提唱した見積りモデルで、ソフトウェアの規模（KLOC: 千行単位のコード行数）と各種コスト要因から開発工数と期間を算出します。",
          "analogy": "家の建築で「床面積（規模）×単価×難易度係数」で建設費を見積もるのと似ています。ソフトウェアの規模から工数を計算式で導き出します。",
          "deepDive": "COCOMOには基本型、中間型、詳細型の3段階があります。後継のCOCOMO IIはオブジェクト指向やプロトタイピングにも対応しています。"
        }
      },
      {
        "id": "b",
        "text": "過去の類似プロジェクトの実績値をそのまま適用する手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "過去の実績をそのまま使うのは類推見積り（アナロジー法）であり、数学的モデルを使うCOCOMOとは異なります。",
          "analogy": "前回の家の建築費をそのまま使うのが類推法、面積から計算式で出すのがCOCOMOです。"
        }
      },
      {
        "id": "c",
        "text": "チームメンバーの合意に基づいて見積り値を決定する手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "チーム合意による見積りはプランニングポーカー等のアジャイル見積り手法で、COCOMOとは異なります。",
          "analogy": "全員で話し合って決めるのがアジャイル見積り、数式で算出するのがCOCOMOです。"
        }
      },
      {
        "id": "d",
        "text": "機能の数と複雑さから開発規模を算出する手法",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "機能の数と複雑さから算出するのはファンクションポイント法です。COCOMOはLOC（コード行数）ベースの見積りモデルです。",
          "analogy": "ファンクションポイントは「機能の数」、COCOMOは「コードの行数」がベースです。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "COCOMOはソフトウェアの規模（LOC）から数学的モデルで開発工数・コストを算出する見積り手法です。",
      "keyPoint": "COCOMO＝LOCベースの数学的見積りモデル、FP法＝機能ベースの見積り",
      "relatedTopics": [
        "ファンクションポイント法",
        "見積り",
        "プロジェクト計画"
      ],
      "studyTip": "COCOMOとファンクションポイント法の違い（コード行数 vs 機能量）を押さえましょう。"
    },
    "tags": [
      "COCOMO",
      "見積り",
      "プロジェクト管理"
    ]
  },
  {
    "questionId": "q-dev-039",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "ソフトウェア品質保証",
    "level": 10,
    "question": "静的解析ツールの主な機能として最も適切なものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "ソースコードを実行せずに、構文エラーや潜在的なバグ、コーディング規約違反を検出する",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "静的解析ツールはプログラムを実行（動的テスト）せずに、ソースコードを解析して問題を検出します。構文エラー、型の不整合、未使用変数、セキュリティ脆弱性、コーディング規約違反などを自動的に発見します。",
          "analogy": "建物を実際に使う前に設計図を見てチェックするのが静的解析です。実際に住んでみて問題を見つけるのが動的テストです。",
          "deepDive": "代表的なツール：SonarQube、ESLint、FindBugs、Coverity、PMDなど。CI/CDパイプラインに組み込んで自動実行することが一般的です。"
        }
      },
      {
        "id": "b",
        "text": "プログラムを実行して性能測定を行う",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "プログラムを実行しての性能測定はプロファイリングや性能テスト（動的テスト）であり、静的解析ではありません。",
          "analogy": "実際に走ってタイムを計る（動的テスト）のではなく、走る前にフォームを分析する（静的解析）のです。"
        }
      },
      {
        "id": "c",
        "text": "テストケースを自動的に実行して結果を判定する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "テストケースの自動実行はテスト自動化フレームワーク（JUnit等）の機能で、静的解析ではありません。",
          "analogy": "練習問題を解いて採点する（テスト実行）のと、解く前に問題文のミスを見つける（静的解析）のは違います。"
        }
      },
      {
        "id": "d",
        "text": "ユーザーインタフェースの操作性を評価する",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "UI操作性の評価はユーザビリティテストであり、静的解析ツールの機能ではありません。",
          "analogy": "使い心地のテストと設計図のチェックは別の作業です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "静的解析はソースコードを実行せずに潜在的な問題を検出する手法です。開発の早い段階で品質問題を発見できます。",
      "keyPoint": "静的解析＝実行せずにコードを分析（設計図チェック）、動的テスト＝実行して確認",
      "relatedTopics": [
        "動的テスト",
        "コードレビュー",
        "CI/CD",
        "品質保証"
      ],
      "studyTip": "静的（実行しない）と動的（実行する）の区別を明確にしましょう。"
    },
    "tags": [
      "静的解析",
      "品質保証",
      "開発ツール"
    ]
  },
  {
    "questionId": "q-dev-040",
    "examType": "科目A",
    "category": "マネジメント系",
    "subcategory": "development",
    "topic": "共通フレーム",
    "level": 10,
    "question": "共通フレーム2013において定義されているソフトウェアライフサイクルプロセスの主要なプロセスグループとして、適切でないものはどれか。",
    "choices": [
      {
        "id": "a",
        "text": "合意プロセス",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "合意プロセス（取得プロセスと供給プロセス）は共通フレームの主要なプロセスグループの一つです。",
          "analogy": "契約を結ぶ（合意する）過程は開発ライフサイクルの重要な一部です。"
        }
      },
      {
        "id": "b",
        "text": "テクニカルプロセス",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "テクニカルプロセスは要件定義、設計、実装、テスト等の技術的な開発プロセスを含み、共通フレームの主要グループです。",
          "analogy": "実際にモノを作る工程は当然ライフサイクルの主要部分です。"
        }
      },
      {
        "id": "c",
        "text": "マーケティングプロセス",
        "isCorrect": true,
        "explanation": {
          "whyCorrect": "マーケティングプロセスは共通フレーム2013（SLCP-JCF2013）のプロセスグループには含まれていません。共通フレームは合意、テクニカル、プロジェクト、組織のイネーブリング、テクニカルマネジメントなどのプロセスグループで構成されます。",
          "analogy": "建物の建設ライフサイクル（設計→建築→検査）に「広告宣伝」が含まれないのと同じで、マーケティングはソフトウェア開発のライフサイクルプロセスには含まれません。",
          "deepDive": "共通フレーム2013はISO/IEC 12207をベースに日本独自の拡張を加えたもので、IPAが発行しています。ソフトウェア開発の標準的なプロセス体系を定めています。"
        }
      },
      {
        "id": "d",
        "text": "プロジェクトプロセス",
        "isCorrect": false,
        "explanation": {
          "whyWrong": "プロジェクトプロセスはプロジェクト管理に関するプロセスを含み、共通フレームの主要グループです。",
          "analogy": "プロジェクトの管理・運営は開発ライフサイクルの重要な一部です。"
        }
      }
    ],
    "overallExplanation": {
      "summary": "共通フレーム2013にはマーケティングプロセスは含まれません。合意、テクニカル、プロジェクト、組織のイネーブリングなどが主要プロセスです。",
      "keyPoint": "共通フレーム＝ISO/IEC 12207ベースのソフトウェアライフサイクルプロセス標準",
      "relatedTopics": [
        "ISO/IEC 12207",
        "SLCP",
        "IPA",
        "プロセス改善"
      ],
      "studyTip": "共通フレームの主要プロセスグループの名前を覚えましょう。マーケティングは含まれません。"
    },
    "tags": [
      "共通フレーム",
      "SLCP",
      "プロセス標準"
    ]
  }
]